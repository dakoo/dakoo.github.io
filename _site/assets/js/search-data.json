{
  "0": {
    "id": "0",
    "title": "Design - 좋은 UML 툴 추천",
    "content": "UML diagram 툴 경험 지금까지 많은 UML diagram 툴들을 써왔다. 소프트웨어 디자인을 잘하려면 모델링을 잘해야 한다고 생각해서 회사에서 제공하는 비싸고 전문적인 디자인 툴부터 가벼운 온라인 버전까지 많은 툴들을 프로젝트를 위해 사용해 보았다. 개발 경력이 쌓여갈수록 툴에 대한 요구사항도 까다롭게 되어 툴들을 다양하게 써보았다. UML 툴들 중 최악은 회사 SE 팀에서 추천한 최신 기능과 표준 스펙으로 무장한 쇳덩이 툴이었다. 툴은 툴일뿐 너무 많은 기능과 익숙치 않은 표준은 개발자에게 전혀 도움을 주지 못한다. visual studio ultimate 제일 좋다고 생각했던 것은 visual studio ultimate가 제공하는 모델링 툴이다. 사실, 개발자 간, 혹은 매니저와의 커뮤니케이션을 위해서 가장 많이 사용되는 것은 layered architecture이다. 안타깝게도 많은 UML 툴들이 layered architecture를 제대로 지원하지 않기에 Powerpoint를 이용해 그리곤 했다. 그런데 visual studio ultimate를 사용하면 layered architecture diagram을 쉽고 빠르고, 이쁘게 그릴 수 있다. 그것만으로도 충분히 좋은 툴이라고 생각하는데, 다른 diagram을 그리는 것도 쉽고 편하다. umlet 무료 uml 툴인 umlet은 java기반으로 만들어져 Windows, OSX, Ubuntu에서 동작하며, markdown스러운 접근법을 사용하고 있다. 모든 종류의 diagram을 지원한다. Eclipse plugin의 경우 property를 수정하지 못하는 문제가 보고되었다. 혹시 문제가 있다면 standalone버전을 사용하자. websequencediagrams 온라인 UML 툴인 websequencediagrams을 써보고 Sequence diagram만은 websequencediagrams이 최고라는 생각이 들었다. text를 통해 diagram을 그린다는 마크다운스러운 접근법과 직관적인 사용법이 너무나 맘에 들었다. 많은 모델을 만들고 재사용해야 하는 대규모 프로젝트에는 적당하지 않지만, 생각을 빠르게 정리하고 개발자간 의사소통을 위한 용도에는 딱 맞는 툴이라고 생각된다. 무료로 제공되는 기본 기능만으로도 충분히 만족감을 느낄 수 있었다. objectaid objectaid는 강력한 uml diagram 자동 생성 tool이다. code를 통해 uml diagram을 생성해주며, eclipse plugin 형태로만 사용되고, 지원되는 언어도 내가 알기로는 Java가 유일하다. 그리고 class diagram은 거의 무료로 사용할 수 있지만, sequence diagram부터느 유료이다. 이런 저런 단점에도 불구하고 매우 강력한 diagram 자동 생성 기능을 가지고 있다. 예전에 사용했던 rapsody의 그것보다 더 깔끔하면서도 강력한 기능인듯하다. 유료로 사용하기를 원하다면 반드시 evaluation version을 먼저 사용후에 만족할 경우 구매를 진행하도록 하자. 정리 UML 툴 중 설계를 위해 추천할 만한 것은 훌륭한 UI, 적당한 수준의 기능과 재사용성을 갖춘 visual studio ultimate가 제공하는 모델링 툴이다. 각종 uml 다이어그램을 지원하는 무료 tool을 찾고 있다면 umlet을 사용하자. sequence diagram에 촛점을 맞춘다면, websequencediagrams를 추천한다. (회사에서 보안상의 이유로 사이트 접근을 막지 않는다면 말이다.). 코드로부터 uml diagram을 자동 생성하는 것이 꼭 필요하다면 objectaid를 참고하기 바란다.",
    "url": "http://localhost:4000/docs/tool/2015-07-21-uml-tools.html",
    "relUrl": "/docs/tool/2015-07-21-uml-tools.html"
  },
  "1": {
    "id": "1",
    "title": "Algorithm - DFS와 BFS",
    "content": "BFS와 DFS의 구현 시 차이점은 BFS는 queue를 쓰고 DFS는 stack을 쓴다는 것이다. 물론 DFS는 recursion으로 구현하는 것이 쉽기도 하다. BFS와 DFS는 구현 flow는 동일하며 visited라는 공통 자료구조를 사용한다. 간단 flow function(g, s) //g는 graph, s는 시작 vertex 필요한 자료 구조 초기화 //BFS는 queue, DFS는 stack, 그리고 visited[]를 false(미방문상태)로 세팅 시작점 s를 방문한 것으로 표시 //visited[]에서 s를 true로 설정 자료구조(queue나 stack)에 s를 삽입//push while(자료 구조가 비어있지 않으면) v &lt;- 자료구조에서 vertex를 하나 뺌//pop for(u &lt;- v와 인접한 vertex들) //g에서 v의 인접 vertex를 찾아 그 수만큼 loop if(u가 방문되지 않았다면) //visited[]에서 u가 false인지 확인 방문으로 표시 //visited[]에서 u를 true로 설정 u를 자료구조에 넣기 //push",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html",
    "relUrl": "/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html"
  },
  "2": {
    "id": "2",
    "title": "Algorithm - Dijkstra's shortest path",
    "content": "그래프의 최단 경로 알고리즘 중 하나인 Dijkstra 알고리즘은 Vertex A와 그래프 내의 다른 모든 Vertex와의 최단 거리를 찾아내는 알고리즘이다. 최단 경로를 찾아내기 위해서는 알고리즘의 변형이 필요하다는 것을 알아두자. 개인적으로는 그래프의 최단 경로 알고리즘를 하나만 알고있어야 한다면, Vertex들간의 최단 거리를 모두 계산해주는 Floyd-Warshall 알고리즘을 추천한다. 알고리즘도 더 쉽고 결과도 더 강력하다. 알고리즘의 Pseudo 코드와 동작에 대해 설명을 한 글과 자세하고 친절한 알고리즘 해석을 한 글을 참고하자. 기본 자료 구조 Graph : n개의 vertex와 m개의 edge로 구성 Distance[n] : 시작점부터 각 vertex까지의 거리를 저장하는 자료. 시작 시엔 시작점(index i)은 0, 나머지는 무한대(987654321?)로 초기화 Selected[n] : 시작점(index i)만 true, 나머지는 false로 초기화 하여 시작. 모두 true가 되면 종료 참고로, vertex와 edge 정보가 따로 주어지는 Graph가 아니라 edge의 weight정보만 가진 2진 array로 Graph가 주어질 경우에는 Distance도 2진 배열, Selected도 2진 배열이 필요하다. flow dijkstra(G, s, n){ //G:Graph, s: 시작 정점의 index, n: 정점의 수 loop Distance[i] = 987654321 Selected[i] = false Distance[s] = 0 Selected[s] = true num_selected = 1 loop condition(num_selected != n) i = extract_min(Distance[]) // Distance에서 최소인 index를 리턴. Selected[i] = true num_selected++ loop j &lt;- i의 모든 인접 정점들 //인접 정점의 거리를 update. j가 이미 가지고 있던 값과 i의 시작정점으로부터의 거리+i와j간 거리를 비교하여 작은 것을 택함 Distance[j] = Distance[j] &gt; Distance[i] + G.e(i,j) ? Distance[i] + G.e(i,j): Distance[j]; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html",
    "relUrl": "/docs/codingInterview/2015-08-06-dijkstra-algorithm.html"
  },
  "3": {
    "id": "3",
    "title": "Data Structure - disjoints-set",
    "content": "집합을 자료구조 중 array를 이용해 만드는 disjoints-set을 이해해 보자. 자료 구조 int parent[MAX_LENGTH]; makeset(x) 유일한 멤버 x를 포함하는 집합 만드는 함수이다. 초기화 함수로 모든 멤버들을 각기 독립적인 set으로 만든다. makeset(x) parent[x] = x; findset(x) x를 포함하는 집합(정확히 말하면 집합의 root parent index)를 찾는 함수이다. findset(x) if x == parent[x] //root parent return x; else return findset(parent[x]); //recursion skewed tree가 되는 것을 막기위해 찾으면서 그 결과를 이용해 tree를 평탄화시키는 것은 아래와 같다. findset(x) if x == parent[x] //root parent return parent[x]; else return parent[x] = findset(parent[x]); //recursion 하며 결과로 자신의 parent를 갱신 unionset(x, y) x와 y를 포함하는 두 집합을 합치는 함수이다. union(x) parent[findset(y)] = findset(x); 두 개의 원소가 같은 집합에 속해 있는지 판단하기 findset(x)와 findset(y)가 같은 결과가 아니면 다른 집합이다. isUnion(x, y) if findset(x) != findset(y) return false; return true; 기타 성능을 최적화하는 방법으로 집합을 union할때 높이가 낮은 쪽으로 연결되도록 rank를 사용하는 경우도 있다.",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html",
    "relUrl": "/docs/codingInterview/2015-08-06-disjoints-set.html"
  },
  "4": {
    "id": "4",
    "title": "Data Structure - Priority Queue",
    "content": "전체적인 동작 원리는 네이버 글을 참조한다. 아래 내용은 Max Heap을 기준으로 설명한다. 자료 구조 Array를 이용해 binary tree를 구현한다. 이때 index는 1부터 시작한다. 다음은 Array를 이용한 tree 구현의 기초적인 알고리즘이다. struct Item { int val; }; Item PriorityQueue[1000001]; int num_items; int getParentIndex(int i){ return i / 2; } int getLChildIndex(int i){ return i * 2; } int getRChildIndex(int i){ return i * 2 + 1; } void init(){ num_items = 0; } int isEmpty(){ if(num_items == 0) return true; return false; } Array의 관리를 위해 원소의 수를 가리키는 변수(마지막 index이기도 함)를 하나 사용한다. 삽입 원소의 수를 1 증가한다. 새로운 원소는 마지막 위치에 저장한다. 부모 노드와 값을 비교해서 부모 노드의 값이 더 작으면 위치를 서로 바꾼다(swap). 부모 노드가 더 크면 삽입과정을 종료한다. root(1)에 도달할 때까지 2를 반복한다. void swap(int i, int j){ Item temp; temp.val = PriorityQueue[j].val; PriorityQueue[j].val = PriorityQueue[i].val; PriorityQueue[i].val = temp.val; } void insert(Item b){ num_items++; int index = num_items; PriorityQueue[index].val = b.val; int p; while ((p = getParentIndex(index)) &gt; 0){ //root parent에 도달할 때 까지 if (PriorityQueue[p].val &gt; PriorityQueue[index].val) //부모 노드가 더 큰 값이면 stop break; swap(p, index); index = p; } } 삭제 root(1) 노드를 삭제한다. 마지막 노드를 root 노드(1)로 이동시키고 원소의 수를 1 줄인다. root 노드부터 시작해서 left 또는 right child와 더 큰 것을 선택해 부모 노드가 더 값이 작으면 swap한다. 부모 노드의 값이 더 크면 삭제 과정을 종료한다. leaf에 도달할 때 까지 위의 과정을 반복한다. Item delete(){ Item temp; temp.val = PriorityQueue[1].val; swap(num_items, 1); num_items--; int index = 1; int cr = getRChildIndex(index); int cl = getLChildIndex(index); int target_index; while (cl &lt;= num_items ){ if (cl == num_items){ //left child가 마지막이면 target_index = cl; } else { //child 두개를 비교하여 더 큰 것을 고른다. if (PriorityQueue[cr].val &lt; PriorityQueue[cl].val) target_index = cl; else target_index = cr; } if (PriorityQueue[index].val &gt;= PriorityQueue[target_index].val) //부모 노드가 더 크면 stop break; swap(target_index, index); index = target_index; cr = getRChildIndex(target_index); cl = getLChildIndex(target_index); } return temp; } 문제 랜선 자르기는 대표적인 이분 탐색 문제이다. 마치 Coin Change 문제처럼 보이기도 하지만, 길이가 Array로 만들기 어려운 매우 큰 수가 주어진다는 점에서 다르다. 수 찾기. 이분 탐색 문제처럼 보이지 않지만, 입력을 정렬함으로써 이분 탐색 문제로 만들어 푸는 것이다.",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html",
    "relUrl": "/docs/codingInterview/2015-08-06-priority-queue.html"
  },
  "5": {
    "id": "5",
    "title": "Algorithm - Minimum Spanning Tree - Kruskal",
    "content": "Minimum Spanning Tree(한국어로 최소 신장 트리) 알고리즘은 쉽게 말해 가장 비용을 적게 사용해서 네트웍을 구성하기 위한 그래프 알고리즘이다. indirected(무방향) 그래프에만 해당된다. Kruskal알고리즘은 Prim 알고리즘과 더불어 유명한 MST 알고리즘이다. 그런데 성능 측면에서는 두 알고리즘이 유사하지만, 이해하기 쉽고 개발이 용이한 것은 Kruskal알고리즘이다. 알고리즘 이해 간단한 flow는 다음과 같다. kruskal(G) //G: graph - 가중치가 다른 edge로 구성 for vertex v in G //graph의 vertex들에 대해 makeset(v) //각각을 set으로 초기화 for edge e in G //graph의 모든 edge들에 대해 insert_minheap(e) //MINHeap에 넣어서 가중치가 작은 순서로 불러올 수 있게 초기화 int selected_edges = 0 while ( minheap is not empty &amp;&amp; selected_edges != n - 1 ) edge &lt;- delete_minheap //가중치가 가장 낮은 edge if(findset(edge.v) != findset(edge.u)) //edge를 이루는 vertex u와 v가 같은 set에 있지 않으면-- 즉, 서클을 형성하지 않으면! do something(edge) --&gt; edge가 MST에 포함되므로 edge의 거리를 더하거나, 아니면 MST자료 구조를 따로 정의해 저장 selected_edges++; union(u,v) 더 자세한 내용은 네이버 글을 참조하자. c언어를 이용한 구현 minheap구현에 대한 글과 disjoints-set 구현에 대한 글에 나온 코드를 사용하여 다음 kruskal 코드를 작성했다. int mst_kruskal(int num_items){ for (int i = 1; i &lt;= num_items; i++){ makeset(i); } init_priorityqueue(); for (int i = 1; i &lt;= num_items - 1; i++){ for (int j = i + 1; j &lt;= num_items; j++){ Item new_item; new_item.val = Edges[i][j]; new_item.v = i; new_item.u = j; insert_priorityqueue(new_item); } } int num_selected = 0; int total_distance = 0; while (!isEmpty_priorityqueue() &amp;&amp; num_selected != num_items-1){ Item it = delete_priority(); if(findset(it.v) != findset(it.u)){ num_selected++; total_distance += it.val; unionset(it.v, it.u); } } return total_distance; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html",
    "relUrl": "/docs/codingInterview/2015-08-07-mst-kruskal.html"
  },
  "6": {
    "id": "6",
    "title": "Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현",
    "content": "보이어-무어 알고리즘은 문자열(S[M])과 패턴 문자열(P[N])이 일치하는 지 검사하는 패턴 매칭 알고리즘으로, KMP 알고리즘과 함께 성능이 좋은 알고리즘으로 알려져 있다. 아이디어는 간단하다. 문자열과 패턴 문자열을 비교할때 패턴 문자열의 맨 뒤 문자 위치를 비교하고, 다르면 문자열을 일정 길이만큼 skip해서 비교를 계속하는 것이다. pseudo code SkipTable[256]; //256 ASCII charset 저장 generateSkipTable(P[], n) //P: pattern문자열, n: 패턴 문자열 길이 loop i &lt;- 0:n-1 SkipTable[i] = n //패턴에 없는 문자일 경우 무조건 패턴 문자열 길이만큼 skip하도록 loop i &lt;- P[] SkipTable[P[i]] = n - 1 - i //패턴에 있는 문자일 경우 패턴의 끝과 그 문자와의 거리만큼을 skip 길이로 지정 search(S[], m, P[], n) //S: 문자열, m: S의 길이, P:패턴 문자열, n: 패턴 문자열 길이 index = n - 1 // 패턴 문자열의 마지막부터 비교 loop (index &lt; m) if S[index] == P[n-1] if S[index]과 P[]을 뒤에서부터 비교해서 일치하는 경우 return index - n + 1 //찾았다! else //일치하지 않으면 틀린 문자가 있는 index로 index를 update index = index + SkipTable[S[index]]; //틀린 문자에 해당되는 거리만큼 jump return -1 //not found c로 구현 위의 pseudo 코드를 C로 구현해보자. #include &lt;stdio.h&gt; int SkipTable[256]; void generate_SkipTable(char pattern[], int pattern_length){ for (int i = 0; i &lt; 256; i++) SkipTable[i] = pattern_length; for (int i = 0; i &lt; pattern_length; i++) SkipTable[pattern[i]] = pattern_length - 1 - i; } // return: if matched -1, otherwise index in the pattern int my_strcmp(char str[], int str_index, char pattern[], int pattern_length){ int index = pattern_length - 1; while (str[str_index] == pattern[index] &amp;&amp; index &gt;= 0){ str_index--; index--; } return index; } int search(char str[], int str_length, int start_index, char pattern[], int pattern_length){ int index = start_index + pattern_length - 1; //starting point while (index &lt; str_length){ if (str[index] == pattern[pattern_length - 1]){ int p_index = my_strcmp(str, index, pattern, pattern_length); if (p_index == -1){ return index - pattern_length + 1; //found } index = index - pattern_length + 1 + p_index; //틀린 문자가 있는 위치 } index = index + SkipTable[str[index]]; //틀린 문자에 해당되는 거리만큼 jump } return -1; //not found } 위의 함수를 이제 테스트 해보자. 이때 문자열에 패턴의 여러개 반복되는 경우 이를 모두 찾아서 위치를 출력하는 형태로 테스트한다. int main(){ char str[37] = &quot;I love yoe ve move. Plovse, love me.&quot;; int str_length = 36; char pattern[5] = &quot;love&quot;; int pattern_length = 4; generate_SkipTable(pattern, pattern_length); int found = search(str, str_length, 0, pattern, pattern_length); while (found != -1 &amp;&amp; found &lt; str_length){ printf(&quot;Found at %d n&quot;, found); found = search(str, str_length, found + pattern_length, pattern, pattern_length); } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html",
    "relUrl": "/docs/codingInterview/2015-08-11-string-pattern-search.html"
  },
  "7": {
    "id": "7",
    "title": "Algorithm - 부분 문자열의 사전순 정렬",
    "content": "문제 문자열이 주어졌을때 모든 가능한 부분 문자열을 사전순으로 정렬할 때 k번째 문자열을 찾아보자. 이때 중복되는 부분 문자열은 없어야 한다. 예를 들어 문자열 ‘food’의 모든 가능한 부분 문자열을 사전순으로 정렬하면 다음과 같다. d, f, fo, foo, food, o, od, oo, ood 아이다어 입력 문자열의 모든 접미어에 대해 모든 접두어를 추출하면 모든 가능한 부분 문자열이 된다. 이때 중복이 발생하긴 한다. 그리고, 문자열의 길이는 그 문자열의 모든 접미어의 수와 일치하며, 또한 모든 접두어의 길이와도 일치한다. 예를 들어 ‘food’의 경우 길이가 4인 문자열인데 4개의 접미어와 4개의 접두어를 가진다. ‘food’의 접미어와 사전순으로 정렬한 순서는 다음과 같다. food, ood, od, d –&gt; d, food, od, ood ‘food’의 접두어는 다음과 같다. f, fo, foo, food 위의 사전순으로 정렬된 4개의 접미어별로 각각 접두어를 뽑으면 다음과 같다. d –&gt; d food –&gt; f, fo, foo, food od –&gt; o, od ood –&gt; o, oo, ood 위의 도출된 접두어를 모으면 아래와 같다. d, f, fo, foo, food, o, od, o, oo, ood 이것이 ‘food’의 모든 부분 문자열이다. 그런데, ood 접미어의 접두어에 ‘o’가 중복되어 있으므로 이것을 제거해야 한다. 문제 해결 flow 자료 구조를 준비한다. char S[]: 입력 문자열 int A[]: 접미어 배열 //접미어 배열은 따로 문자열을 저장하는 것이 아니라 S[]의 index를 저장하기 위한 것 int LCP[]: 최장 공통 접두어 길이 배열 //문자열간 공통 접두어의 길이 저장하기 위한 것으로 LCP[0]은 0으로 초기화 한다. 입력 문자열의 모든 접미어를 뽑아서 사전순으로 정렬하여 접미어 배열을 만든다. S[]의 접미어를 사전순으로 비교하여 index 0, 1, 2 … 를 A[]에 저장한다. 예를 들어, food의 경우 food와 d를 비교하면 이것은 S[0]과 S[3]의 비교이다. d가 사전순으로 더 우선이므로 A[]에서 3이 0보다 앞에 위치해야 한다. food의 경우 A[]는 {4, 0, 3, 2}이다. (d, food, od, ood) 접미어 배열에서 최장 공통 접두어 길이 배열을 만든다. LCP[i]는 S[A[i-1]]과 S[A[i]]간의 최장 공통 접두어 길이를 저장한다. 예를 들어 od와 ood의 최장 공통 접두어는 ‘o’이며 길이는 1이다. food의 경우 LCP[]는 {0,0,0,1}이다. 접미어 배열과 최장 공통 접두어 길이 배열을 이용해 k번째 문자열을 반환한다. 접미어의 가능한 접두어 수(접미어의 길이)에서 LCP[i]를 빼면 그 접미어에 대해 중복을 제외한 부분 문자열의 수를 구할 수 있다. 그러므로 접미어에 대해 누적을 해서 k번째까지 도달하도록 하면 k번째 문자열이 무엇인지 구할 수 있다. 한 접미어의 유효 부분 문자열 수는 접미어 길이 -LCP이다. food는 다음과 같다. 접미어 시작 index 접두어수 LCP 누적 유효 부분 문자열 수 d 3 1 0 1 food 0 4 0 5 od 2 2 0 7 ood 1 3 1 9 출력되어야 하는 부분 문자열은 해당 접미어의 index에서부터 LCP+(k-그이전까지의 누적 유효 부분 문자열 수)만큼의 거리만큼 출력하면 된다. 그런데 그 범위가 문자열의 유효 길이를 넘는다면 다음 접미어로 넘어간다. 그것을 일반화 하면 다음과 같다. 출력할 lastindex = 접미어의 시작 index + LCP + (k- 이전까지의 누적 유효 부분 문자열 수) - 1 ‘food’의 문자열 마지막 index는 3이고 k는 8이다. &#39;od&#39;에서 출력할 lastindex = 2(시작 index) + 0(LCP) + (8-5) - 1 = 4. ‘food’의 마지막 index인 3보다 크므로 다음 접미어로 처리가 넘어간다. &#39;ood&#39;에서 출력할 lastindex = 1(시작 index) + 1(LCP) + (8 - 7) - 1 = 2. ‘food’의 마지막 index인 3보다 작으므로 여기서 출력을 한다. 시작 index인 1부터 2까지 출력하므로 ‘oo’를 출력하면 된다. C 구현 위의 아이디어와 문제 해결 flow를 C로 구현한 것은 아래와 같다. #include &lt;stdio.h&gt; int length; int Suffix[10]; int LCP[10]; char str[5] = &quot;food&quot;; char result[10]; /* 기본적인 스트링 처리 함수들 */ int m_strlen(char *s){ int len = 0; while(s[len]!=&#39; 0&#39;){ len++; } return len; } int m_strcmp(char *a, char *b){ int i = 0; while (a[i]!=&#39; 0&#39;) { if(a[i]!=b[i]) break; i++; } return (a[i]-b[i]); //같으면 0, 문자열 a가 사전순으로 다 빠르면 음수, b가 더 빠르면 양수를 반환 } void swap(int *a, int *b){ int temp = *a; *a = *b; *b = temp; } /* 문자열을 사전순으로 비교하여 sorting*/ int partition(int low, int high){ int index = low; for(int i = low; i&lt;=high-1; i++){ if(m_strcmp(&amp;str[Suffix[i]], &amp;str[Suffix[high]])&lt;0){ //음수이면 사전순으로 정렬시 더 앞에 있다는 의미 swap(&amp;Suffix[index], &amp;Suffix[i]); index++; } } swap(&amp;Suffix[index], &amp;Suffix[high]); return index; } void quicksort(int low, int high){ if(low &gt;= high) return; int pivot = partition(low, high); quicksort(low, pivot-1); quicksort(pivot+1, high); } /* 접미어 배열 생성*/ void generate_Suffix_array(void){ length = m_strlen(str); str[length] = &#39; 0&#39;; for(int i = 0; i&lt;length; i++) //set as index Suffix[i] = i; quicksort(0, length-1); } /*최장 공통 접두어 길이 배열*/ int get_lcp(char *a, char *b){ int i = 0; while(a[i] == b[i]) i++; return i; } void generate_LCP_array(void){ LCP[0] = 0; for(int i = 1; i&lt;length; i++){ LCP[i] =get_lcp(&amp;str[Suffix[i-1]], &amp;str[Suffix[i]]); } } /* k번째 문자열 계산 및 출력 */ int get_kth_word(int k){ int accummulated_num_words = 0; int index = 0; while(accummulated_num_words&lt; k &amp;&amp; index&lt;length){ int startIndex = Suffix[index]; // 출력할 lastindex = 접미어의 시작 index + LCP + (k- 이전까지의 누적 유효 부분 문자열 수) - 1 int lastIndex = startIndex + LCP[index] + (k-accummulated_num_words)-1; if(lastIndex &lt; length) {//접미어내에 해당 문자열 존재하는 경우 int j = 0; for(int i = startIndex; i&lt;= lastIndex; i++){ result[j] = str[i]; j++; } result[j] = &#39; 0&#39;; return 1; } else { //다음 접미어로 이동 accummulated_num_words += m_strlen(&amp;str[Suffix[index]]) - LCP[index]; index++; } } return 0; } /* 테스트 코드: food문자열의 부분 문자열을 사전순으로 정렬했을때 8번째 문자열 출력하시오. 이때 중복 문자열은 제외해야 함*/ int main(){ generate_Suffix_array(); generate_LCP_array(); int res = get_kth_word(8); if(res) printf(&quot;%s n&quot;, result); else printf(&quot;none n&quot;); return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html",
    "relUrl": "/docs/codingInterview/2015-08-12-substring-sorting.html"
  },
  "8": {
    "id": "8",
    "title": "Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘",
    "content": "Longest Increasing Subsequence(LIS)알고리즘은 나열된 수열에서 배열 순서를 유히자면서 크기가 점진적으로 커지는 가장 긴 부분 수열을 구하는 알고리즘이다. 예를 들어, 3, 2, 7, 5, 6, 1 에서 2, 5, 6이 LIS이며 그 길이는 3이다. 아이디어 입력 수열이 a1, a2, …, an일때 LIS[i]는 a1~ai의 최장 부분 수열의 길이라고 정의하자. LIS[i]를 LIS[1]~LIS[i-1]과의 관계로 표현하면 다음과 같다. aj &lt; ai (이때, j&lt;i)인 aj를 모두 찾는다. 즉, ai보다 앞에 위치해 있으면서 ai보다 작은 값을 모두 찾는다. 3, 2, 7, 5, 6, 1이 있을 때 ai가 5(index는 4)라면 aj후보는 3, 2(index는 1과 2)이다. aj후보의 LIS 중 가장 큰 값을 찾아 1을 증가시킨 것이 LIS[i]이다. 예를 들어, LIS[4]는 LIS[1]과 LIS[2]의 최대값+1이다. LIS[1]과 LIS[2]가 모두 1이므로 LIS[4]는 2이다. Pseudo 코드 function(A[],n){ for i in 1 -&gt; n { LIS[i] = 1 //자기 자신만의 길이로 초기화 for j in 1 -&gt; i - 1 { //자신 앞을 검색 if (A[j] &lt; A[i] &amp;&amp; 1 + LIS[j] &gt; LIS[i]) //크기가 더 작고 LIS를 증가시킬 수 있으면 LIS[i] = 1 + LIS[j] } } return max LIS[i] //최대값을 찾아서 반환 }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html",
    "relUrl": "/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html"
  },
  "9": {
    "id": "9",
    "title": "Algorithm - Floyd-Warshall",
    "content": "Floyd-Warshall 알고리즘은 Dijkstra 알고리즘과 같은 최단 경로를 찾는 알고리즘이다. Dijkstra 알고리즘은 하나의 시작점을 기준으로 최단 경로를 찾는데 비해 Floyd-Warshall 알고리즘은 모든 쌍의 최단 경로를 찾을 수 있다. 무엇보다도 알고리즘이 훨씬 간단하다. 그 이유는 Dynamic Programming 기반의 알고리즘이기 때문이다. 아이디어 정점 i에서 j로 갈 때 i에서 j로 직접 가는 경로와 i에서 k를 거쳐 j로 가는 경로 중 짧은 경로를 선택한다. 그 뒤 i에서 l로 직접 가는 경로와 i로 부터 j를 거쳐 l까지 가능 경로 중 짧은 경로를 선택하는 것으로 확장한다. 입력 그래프의 정점을 각각 1, 2, 3, n이라고 한다. Dijk: 정점 1, 2, …, k만을 경유 가능한 정점으로 고려했을 때 가장 최단 경로의 거리이다. i와 j사이에 아무 정점도 거치지 않을 수도 있고, 특정 정점을 거칠 수도 있는데 그 중 최단 경로의 거리가 Dijk인 것이다. 정점 1부터 k까지를 모두 거치야 하는 것은 아니란 것을 명심하자. Dij0: 어느 정점도 거치지 않고 i에서 j까지의 직접가는 경로의 거리를 의미한다. 즉, i와 j간 선분의 가중치(거리)와 같다. Dij1: i에서 j까지 경로 중 정점 1을 고려할 떄의 최단 경로를 의미한다. i에서 j에 직접 가는 거리와 1을 거쳐서 j에 가는 거리 중 최단 거리이며, 모든 쌍 i와 j에 대해 Dij1를 계산하는 것이 가장 작은 부분 문제이다. (이때 i와 j는 정점 1이 아니다) 모든 쌍 i와 j에 대해 Dij1을 구한다. Dij1은 i에서 j로 직접 가는 거리와 정점 1을 반드시 경유해서 가는 거리 중 더 짧은 경로의 거리이다. 모든 쌍 i,j에 대해 Dij2를 구한다. Dij2는 정점 1까지를 고려햔 최소 경로 길이와 정점 2를 반드시 경유하는 거리 중 짧은 거리를 Dij2로 정한다. i에서 출발하여 정점 k를 경유하여 j로 가는 경로의 거리와 Dij(k-1)를 비교하여 더 짧은 거리를 Dijk로 정한다. 일반화 하면 다음과 같다. Pseudo 코드 D[i][j] 초기화 //선분 (i, j)의 가중치. 선분이 없으면 무한대, 자기자신(i=j)이면 0으로 초기화 function(D[i][j]){ for k in 1-&gt;n { //k는 1부터 범위를 확장해 나가는 것 for i in 1-&gt;n { //단, i!= k for j in 1-&gt;n { //단, j!= i, j!=k D[i][j]=min(D[i][k] + D[j][k], D[i][j]) } } } }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html",
    "relUrl": "/docs/codingInterview/2015-08-14-floyd-warshall.html"
  },
  "10": {
    "id": "10",
    "title": "Algorithm - 확률에 대한 간단 정리",
    "content": "확률의 덧셈 정리 두 사건 A와 B가 일어날 확률은 다음과 같다. P(AUB) = P(A) + P(B) - P(A와 B의 교집합: A와 B가 동시에 일어날 확률) 두 사건 A와 B가 동시에 일어나는 일이 아닌 경우엔 P(AUB) = P(A) + P(B) 조건부 확률 A안에서 A와 B가 동시에 일어날 확률은 A가 일어났을때의 B의 조건부 확률이라고 한다. 그것은 A와 B가 동시에 발생한 수를 A의 발생 수로 나눈 것과 같다. P(B|A) = n(A와 B의 교집합)/n(A) = P(A와 B의 교집합)/P(A) 독립 사건, 종속 사건 A와 B가 서로 상관없이 발생하는 경우 독립사건이라 하고, 수식화 하면 다음과 같다. P(B|A) = P(B) = P(B|A의 여집합) A와 B가 서로 상관있는 경우, 종속사건이라고 한다. B의 발생이 A의 발생에 의해 영향을 받는 경우를 수식화 하면 다음과 같다. P(B|A) != P(B) 독립 사건의 곱셈 정리 P(A와 B의 교집합) = P(A)*P(B) 독립 시행 동전이나 주사위를 여러번 던지는 것과 같이 어떤 시행을 되풀이 해도 각 사건이 서로 독립적인 경우 즉, 시행의 결과가 이전 시행에 의해 영향을 받지 않는 시행을 독립 시행이라고 한다. 독립 시행의 확률 구하기 어떤 시행에서 사건 A가 발생할 확률이 p이고 그 여사건이 발생할 확률이 q(q = 1-p)일때 n번의 독립 시행에서 사건 A가 r번 이러날 확률은 다음과 같다. Pr = nCr * p의 r제곱승 * q의 (n-r)제곱승",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html",
    "relUrl": "/docs/codingInterview/2015-08-14-probability_summary.html"
  },
  "11": {
    "id": "11",
    "title": "Algorithm - 0-1 Knapsack 알고리즘",
    "content": "문제 무게 W를 감당할 수 있는 배낭이 있을때 n개 종류의 물건을 선택해서 넣을 수 있다. 각 물건은 무게와 가격이 각각 다르다. 최대 가격이 되기 위해 어떤 물건을 선택해야 하는지 알아내는 것이 Knapsack 문제이다. Knapsack문제는 2가지가 있는데 하나는 0-1 Knapsack으로 물건을 자를 수가 없다는 것이고, 다른 하나는 Fraction Knapsack으로 물건을 자를 수 있다는 것이다. Fraction Knapsack Fraction Knapsack문제는 물건의 가격을 무게로 나누어 무게 대비 가격이 비싼 순서로 물건을 정렬해서 넣으면 쉽게 해결할 수 있다. 남은 배낭이 감당할 수 있는 무게보다 물건의 무게가 많이 나가면 잘라서 넣으면 된다. 0-1 Knapsack 0-1 Knapsack 문제는 물건을 자를 수 없기 때문에 물건, 물건의 무게, 물건의 가격, 배낭의 남은 용량을 모두 고려해야 한다. 아이디어 물건을 넣을지 말지를 결정하는 기준은 넣었을 때 배낭의 최대 가격과 넣지 않았을 때의 최대 가격 중 큰 것이 무엇이냐이다. 예를 들어 배낭이 10kg을 감당하고, 필통이 1kg, 1만원, 곰인형이 4kg, 10만원, 선물이 11kg, 100만원이라고 하자. 처음 배낭이 10kg이고, 곰인형은 배낭에 넣을 수 있다. 곰인형을 넣자라는 선택을 하면, 최대 가격은 10만원 + 6k에 남은 물건을 가지고 넣을 수 있는 최대 가격이 된다. 그렇게 되면 6kg에 남은 2가지 물건을 고려했을 때 넣을 수 있는 최대 가격 문제가 부분문제가 된다. 곰인형을 넣지 말자라는 선택을 하면, 최대 가격은 0만원 + 10kg에 남은 물건 물건을 가지고 넣을 수 있는 최대 가격이 된다. 그렇게 되면 10kg에 남은 2가지 물건을 고려했을 때 넣을 수 있는 최대 가격 문제가 부분문제가 된다. 이를 일반화 하면 다음과 같다. W: 배낭이 감당할 수 있는 무게 (용량) (vi, wi): 물건 i가 가지는 가격과 무게 K[i, w]: 남은 배낭 무게가 w일때 물건 1~i까지 고려한 경우의 최대 가격 K[i, w] = 0 if i = 0 or w = 0 //선택할 물건이 남아있지 않거나 배낭에 넣을 수 있는 무게가 0 = K[i-1, w] if wi&gt;w //물건 i가 너무 무거워서 배낭에 넣을 수 없음 = max(vi + K[i-1, w-wi], K[i-1, w])//물건을 넣었을때와 넣지 않았을때의 가격 중 최대를 택함 //vi + K[i-1, w-wi]: 넣었을 때, K[i-1, w]: 넣지 않았을 때 Iteration을 이용한 구현 Pseudo 코드 위 알고리즘을 Pseudo 코드로 표현하면 다음과 같다. function(){ for i in 0-&gt;n{ //초기화 k[i, 0] &lt;- 0 } for w in 0-&gt;n{ //초기화 k[i, w] &lt;- 0 } for i in 1 -&gt; n{ for w in 1 -&gt; W{ if(wi &gt;w) //물건 i가 너무 무거워서 배낭에 넣을 수 없음 K[i,w] &lt;- K[i-1,w] else //물건을 넣었을때와 넣지 않았을때의 가격 중 최대를 택함 K[1,w] &lt;- max(k[i-1, w-wi] + vi, K[i-1,w]) } } return K[n,W] //무게 W에 물건 n일때의 최대 값 반환 } C 코드 위의 배낭 10kg과 필통, 곰인형, 선물의 경우를 테스트 코드로 해보자. #include &lt;stdio.h&gt; int K[5][21]; //num of objects, weight int knapsack(int n, int W, int price[], int weight[]){ for(int i=0;i&lt;=n;i++){ K[i][0] = 0; } for(int w=0;w&lt;=W;w++){ K[0][w] = 0; } for(int i=1;i&lt;=n;i++){ for(int w=1;w&lt;=W;w++){ if(weight[i]&gt;w) K[i][w] = K[i-1][w]; else{ int selected_val = K[i-1][w-weight[i]] + price[i]; int unselected_val = K[i-1][w]; K[i][w] = selected_val &gt; unselected_val?selected_val:unselected_val; } } } return K[n][W]; } int main(){ int price[4] = {0, 10, 1, 100}; int weight[4] = {0, 4, 1, 11}; int Weight = 10; //베낭 10kg int max_val = knapsack(3, Weight, price, weight); printf(&quot;max price: %d&quot;, max_val); return 0; } Recursion을 이용한 구현 위의 아이디어를 반복이 아닌 recursion으로 구현해보자. K[i, w]가 반복적으로 계산되기보다는 계산의 과정으로만 쓰이기 때문에 memoization기법을 적용할 필요는 없다. C 코드 #include &lt;stdio.h&gt; int knapsack(int i, int w, int price[], int weight[]){ if(i == 0 || w == 0) return 0; int unselected_val = knapsack(i-1, w, price, weight); if(weight[i] &gt; w){ return unselected_val; } int selected_val = knapsack(i-1, w-weight[i], price, weight) + price[i]; int max_val = selected_val &gt; unselected_val?selected_val:unselected_val; return max_val; } int main(){ int price[4] = {0, 10, 1, 100}; int weight[4] = {0, 4, 1, 11}; int Weight = 10; //베낭 10kg int max_val = knapsack(3, Weight, price, weight); printf(&quot;max price: %d&quot;, max_val); return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html",
    "relUrl": "/docs/codingInterview/2015-08-15-01knapsack.html"
  },
  "12": {
    "id": "12",
    "title": "Algorithm - LCS(Longest Common Subsequence) 알고리즘",
    "content": "최장 공통 부분 수열(Longest Common Subsequence, LCS) 문제는 두 수열의 가장 긴 공통 부분 수열을 찾아내는 문제이다. 그 문제를 푸는 LCS 알고리즘에 대해 살펴보자. 문제 최장 공통 부분 수열(Longest Common Subsequence) 문제는 두 수열의 가장 긴 공통 부분 수열을 구하는 문제이다. 어떤 수열의 일부를 순서를 그대로 유지하여 나열한 것이 바로 부분 수열이 된다. 예를 들어 문자열 ‘abc’의 부분 수열은 빈 문자열, a, b, c, ab, bc, ca, abc이다. 둘 이상의 수열이 있을 때, 공통된 가장 긴 부분 수열을 찾는 것이 LCS 문제이다. 이렇게 설명하면 조금 복잡한데 쉽게 말해서 두 수열을 앞에서 뒤로 비교할 때 가장 많이 일치하는 게 뭔지, 그리고 그 길이는 얼마나 긴지를 찾는 것이다. 예를 들어, ‘abcdefg’와 ‘cdeabfg’가 있다고 하면, LCS는 ‘cdef’가 된다. 이 LCS를 이용해 diff를 구현할 수 있다. 두 파일의 문자열을 비교해서 LCS가 아닌 부분을 보여주는 것으로 구현하면 된다. 아래는 그 예를 보여준다. 아이디어 LCS의 아이디어는 단순하다. 수열 A ‘abcd’와 수열 B ‘bcf’를 살펴보자. 수열 A의 맨 뒤를 하나 삭제해 보자. ‘abc’가 되는데 삭제된 ‘d’는 LCS에 포함되지 않기 때문에 LCS의 길이는 변함이 없다. 다음 수열 A의 맨뒤를 하나 더 삭제해 보자. ‘ab’가 되는데 ‘c’가 수열 A에서 제거됨에 따라 LCS의 길이도 하나 줄어들게 된다. 이처럼 수열의 맨뒤를 제거하면 LCS의 길이는 하나 줄거나 그대로인 경우로 나뉘게 된다. 이것을 다음의 경우로 나누어 살펴보자. 경우 1. 수열 A와 B 모두의 마지막이 공통 부분 수열에 속하는 경우 A와 B의 문자가 같다(A[i] == B[j]) A와 B의 LCS의 길이는 마지막 문자를 하나 줄인 수열 A와 마지막을 하나 줄인 수열 B간의 LCS에 공통 문자의 길이 1을 추가한 것과 같다 . 일반화 하면, 마지막 index가 각각 i, j일 경우 A[i] == B[j]이면 LCS[i][j] = LCS[i-1][j-1] + 1이다. 예를 들면, ‘abcd’와 ‘ad’의 LCS 길이는 ‘abc’와 ‘a’의 LCS길이 + 1이다 경우 2. 수열 A의마지막이 공통 부분 수열에 속하지 않는 경우 A와 B의 문자가 다르다(A[i] != B[j]) A와 B의 LCS는 마지막 문자를 하나 줄인 수열 A와 수열 B간의 LCS와 동일하다. 일반화하면, LCS[i][j] = LCS[i-1][j]이다. 예를 들면, ‘abcd’와 ‘ac’의 LCS길이는 ‘abc’와 ‘ac’의 길이와 같다. 경우 3. 수열 B의마지막이 공통 부분 수열에 속하지 않는 경우 A와 B의 문자가 다르다(A[i] != B[j]) A와 B의 LCS는 수열 A와 마지막 문자를 하나 줄인 수열 B간의 LCS와 동일하다. 일반화하면, LCS[i][j] = LCS[i][j-1]이다. 예를 들면, ‘abxc’와 ‘acd’의 LCS길이는 ‘abxc’와 ‘ac’의 길이와 같다. A[i]!=B[j]이면 반드시 두번째 또는 세번째 경우에 포함되며, LCS 길이는 최대 수열의 길이이므로 두 경우 중 길이가 긴 것과 같다. 아이디어의 구현 위의 알고리즘을 배열을 이용해 용이하게 구현할 수 있다. String A는 “abcd”, B는 “bca”라고 가정하자. LCS 배열을 다음과 같이 초기화 된다. 아래와 같이 LCS[0][]과 LCS[][0]을 모두 0으로 초기화 한다. 각 문자에 대응되는 LCS가 0이라고 초기화한 것이다. LCS[1][1]부터 계산을 시작한다. A와 B의 첫번째 문자끼리 비교하는 것이다. ‘a’와 ‘b’이므로 첫번째 경우가 아닌 두번째 혹은 세번째 경우에 속하는 것이다. A[0]과 B[0]을 비교한 것이고, 서로 같지 않으므로 그 문자를 제거한 문자열간 LCS인 두번째와 세번째 경우에 해당되는 것이 된다. 물론 여기서는 맨 첫번째 문자끼리의 비교이므로 두번째와 세번째 경우 모두 0이 될 것이다. 일반화 하자면, 이미 살펴본 아이디어처럼 A[i]과 B[j]가 같지 않은 경우 LCS[i][j]는 LCS[i-1][j] 또는 LCS[i][j-1] 중 큰 것의 값을 택하는 것이다. 배열에서는 위 또는 좌 측의 값 중 큰 값을 택하는 것이 된다. 다음 A[1]과 B[0]를 비교한다. ‘b’와 ‘b’이므로 첫번째 경우에 속하게 되고, 그러면 A와 B에서 ‘b’를 제외했을때의 LCS 길이에 1을 더한 값이 LCS 길이가 된다. 물론, 이경우는 이전 값이 0이였으므로 이 연산의 결과가 1이 된다. 일반화 한다면, A[i]와 B[j]가 같은 경우에는 LCS[i][j]는 LCS[i-1][j-1]에 1을 증가시킨 것이다. 배열에서는 좌측 상단의 값 + 1과 같다. 이런 식으로 각 문자들을 모두 비교한다. A의 길이가 n이라고 하고 B의 길이를 m이라고 하면 n*m 번을 계산한다. String A의 끝(n)과 String B의 끝(m)까지 비교하면 종료된다. 이때 LCS[n][m]의 값이 A와 B의 LCS 길이가 된다. 코드 내용을 보면 알겠지만 위의 설명을 그대로 옮겨 놓은 것이다. 간단히 지극히 c스럽게 c++로 구현 했다. #include &lt;iostream&gt; #include &lt;string&gt; #define MAX_SIZE 501 int main(void){ //자료 구조 int LCS[MAX_SIZE][MAX_SIZE]; char first_string[MAX_SIZE]; char second_string[MAX_SIZE]; //두 문자열을 입력으로 받고 길이 확인 std::cin &gt;&gt; first_string &gt;&gt; second_string; size_t length_first_string = strlen(first_string); size_t length_second_string = strlen(second_string); //알고리즘 구현 for(int i = 1; i &lt;= length_first_string; i++){ for(int j = 1; j &lt;= length_second_string; j++){ if(first_string[i-1] == second_string[j-1]) //문자가 일치하는 경우 (1번 경우) LCS[i][j] = LCS[i-1][j-1]+1; else //일치하지 않는 경우 (2, 3번 경우) LCS[i][j] = LCS[i-1][j]&gt; LCS[i][j-1]? LCS[i-1][j]: LCS[i][j-1]; } } //결과 출력 std::cout &lt;&lt; &quot;LCS: &quot; &lt;&lt; LCS[length_first_string][length_second_string]; return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html",
    "relUrl": "/docs/codingInterview/2015-08-15-longest-common-subsequence.html"
  },
  "13": {
    "id": "13",
    "title": "Algorithm - 순열과 조합",
    "content": "순열, 중복 순열, 조합, 중복 조합에 대한 이해를 해보자. 1. 개요 순열, 중복 순열, 조합, 중복 조합를 비교해 보자. 1.1 순열 중복없이 n개 중에서 r개를 뽑아 순서를 정해 나열하는 경우를 말한다. 예를 들어, 다섯 개의 문자 a, b, c, d, e를 일렬로 배열해야 하는 것을 생각해보자. a, b, c, d, e a, b, c, e, d a, b, e, c, d ... 1.2 중복 순열: n개 중에서 r개를 뽑아 순서를 정해 나열하는 경우, 같은 것(종류)을 다시 뽑을 수 있는 것을 말한다. 예를 들어, 숫자 1,2,3을 이용해 만들수 있는 3자리 정수를 모두 구해야 한다고 생각해 보자. 111 112 113 121 122 ... 1.3 조합 중복없이 n개 중에서 r개를 순서에 상관없이 뽑는 것을 말한다. 예를 들어 시간이 서로 다른 4 과목 A, B, C, D중 2개 만을 선택해서 수강 신청 하는 경우를 생각해보자. AB AC AD BC BD CD 1.4 중복 조합 n개 중에서 r개를 같은 것(종류)를 뽑을 수 있으며 뽑히는 순서에 상관없이 선택하는 것을 말한다. 예를 들어 1인당 2개의 표를 가지고 4개의 연예인(A, B, C, D)에게 선호도 투표를 하는 경우를 생각해보자. 이때 2개의 표를 같은 인물에게 2표를 모두 행사할 수 있다면. AA AB AC AD BB BC BD .. 2. 순열 2.1 개요 세개의 문자 a,b,c 중 2개를 택해 일렬로 배열하는 방법의 수는 첫 번째 자리의 문자를 택하는 가짓수(3)와 남은 문자 중에서 두번째 자리에 놓을 가짓수(2)를 곱한 것과 같다. 이처럼 서로 다른 n가지에서 r가지를 택하는 순열의 모든 경우의 수는 nPr로 표시할 수 있다. nPr = n!/(n-r)!, nP0는 1, nPn은 1(모두 선택하거나, 아무것도 선택하지 않을 경우의 수는 1) 2.2 구현 nPr을 이루는 각 경우를 뽑아내기 위한 구현의 예제는 다음과 같다. 문제: 1, 2, 3, 4 숫자 4개가 주어졌을때 이 중 3개의 숫자를 뽑아 한번씩만 사용해서 만들 수 있는 모든 숫자를 출력하라. #include &lt;stdio.h&gt; int T[10]; //nPr을 이루는 각각의 경우를 저장 int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; void swap(int *i, int *j){ int temp = *i; *i = *j; *j = temp; } /*T[]에서 q개 출력*/ void process(int q){ for(int i = q-1; i&gt;= 0; i--){ printf(&quot;%d &quot;, T[i]); } printf(&quot; n&quot;); } /*data[]에서 앞에서부터 n개의 숫자 중 r개를 선택해서 순열을 출력하는 함수. q는 출력 시 출력 갯수 지정*/ void Perm(int n, int r, int q){ if(r == 0){ process(q); return; } for(int i = n-1; i&gt;=0; i--){ swap(&amp;data[i], &amp;data[n-1]); //n-1을 모든 index와 swap해서 다양한 순서를 만든다. T[r-1] = data[n-1]; //T의 뒤에서부터 결과값 저장 Perm(n-1, r-1, q); //다음 index로 진행 swap(&amp;data[i], &amp;data[n-1]); } } int main(void){ Perm(4, 3, 3); return 0; } 3. 중복 순열 3.1 개요 서로 다른 n개의 중복을 허용하여 r개를 택하여 나열하는 방법을 n개에서 r개를 택하는 중복 순열이라고 한다. 중복 순열의 모든 경우의 수는 아래와 같다. 중복 순열 nㅠr = n의 r제곱승 3.2 구현 중복 순열의 각 경우를 출력하는 코드를 순열 구현 코드와 비교하면서 확인해보자. 1, 2, 3, 4 숫자 4개가 주어지고 이 중 3개를 뽑는데 같은 숫자가 반복되어도 가능하다. #include &lt;stdio.h&gt; int T[10]; //nPr을 이루는 각각의 경우를 저장 int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; void swap(int *i, int *j){ int temp = *i; *i = *j; *j = temp; } void process(int q){ for(int i = q-1; i&gt;= 0; i--){ printf(&quot;%d &quot;, T[i]); } printf(&quot; n&quot;); } /*data[]에서 앞에서부터 n개의 숫자 중 r개를 (중복) 선택해서 순열을 출력하는 함수. q는 출력 시 출력 갯수 지정*/ void PI(int n, int r, int q){ if(r == 0){ process(q); return; } for(int i = n-1; i&gt;=0; i--){ swap(&amp;data[i], &amp;data[n-1]); T[r-1] = data[n-1]; PI(n, r-1, q); //유일하게 다른 부분. 1가지를 선택한 후 선택할 수 있는 종류를 줄이지 않음.(n) swap(&amp;data[i], &amp;data[n-1]); } } int main(void){ PI(4, 3, 3); return 0; } 4.조합 4.1 개요 서로 다른 n개에서 순서를 생각하지 않고 r개(0&lt;=r&lt;=n)를 택하는 것을 조합이라고 한다. n개 중 r개를 선택하는 모든 조합의 경우의 수는 다음과 같다. nCr = nPr을 r!로 나눈 것 = n!/(r!*(n-r)!), nC0과 nCn은 1이다. nCr은 다음과 같은 관계를 가진다. nCr = n-1Cr-1 + n-1Cr 참고로, 서로 다른 n개의 물건을 p개, q개, r개의 3개의 그룹으로 나누는 방법은 다음과 같다. nCp * n-pCq * rCr 예를 들어, 서로 다른 종류의 꽃 15송이를 다섯 송이씩 세묶음으로 나누는 방법의 수는 15C10 * 10C5 * 5C5이다. 4.2 구현 조합을 한 각 경우를 출력하는 것을 생각해보자. nCr = n-1Cr-1 + n-1Cr, nC0 = 1 관계를 이용한다. 1, 2, 3, 4 숫자 4개가 주어졌을때 순서 상관없이 3개씩 묶어 그룹을 만들 때 그 멤버를 출력한다. #include &lt;stdio.h&gt; int T[10]; //nPr을 이루는 각각의 경우를 저장 int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; void process(int q){ for(int i = q-1; i&gt;= 0; i--){ printf(&quot;%d &quot;, T[i]); } printf(&quot; n&quot;); } /*data[]에서 앞에서부터 n개의 숫자 중 r개를 선택해서 조합을 출력하는 함수. q는 출력 시 출력 갯수 지정*/ void Comb(int n, int r, int q){ if(r == 0){ process(q); return; }else if(n&lt;r){ return; } else { //loop이 아님 T[r-1] = data[n-1]; Comb(n-1, r-1, q); //n-1Cr-1: 현재 아이템을 선택한 경우 Comb(n-1, r, q); //n-1Cr: 현재 아이템을 선택하지 않은 경우 } } int main(void){ Comb(4, 3, 3); return 0; } 5. 중복 조합 5.1 개요 서로 다른 n개에서 순서를 생각하지 않고 중복을 허용하여 r개(0&lt;=r&lt;=n)를 택하는 것을 중복 조합이라고 한다. 예를 들어, 숫자 1, 2에서 중복을 허용하여 3개를 선택하는 조합은 (1,1,1)(1,1,2)(1,2,2)(2,2,2)이다. 중복 조합의 모든 경우의 수는 다음과 같이 표현된다. nHr = n+r-1Cr nHr은 다음과 같은 관계를 가진다. nHr = nHr-1 + n-1Hr 5.2 구현 여기서 중복 조합의 구현은 생략한다. 스스로 구현해 보자!",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html",
    "relUrl": "/docs/codingInterview/2015-08-15-permutation-composition-summary.html"
  },
  "14": {
    "id": "14",
    "title": "Algorithm - Travelling Salesman Problem(TSP)",
    "content": "문제 Travelling Salesman Problem(이하 TSP)은 외판원이 자신이 위차한 도시에서 출발해서 다른 도시들을 각각 한번씩 방문하고 다시 자기 도시로 돌아오는 가장 짧은 일주 경로를 알아내는 문제이다. 일반적으로 이 문제는 음이 아닌 가중치가 있는 방향성 그래프를 대상으로 한다. 그래프 상에서 일주 여행 경로는 한 정점을 출발해 다른 모든 정점을 한번씩 거쳐서 다시 그 정점으로 돌아오는 경로이다. 다양한 알고리즘 TSP를 해결하기 위한 다양한 알고리즘이 있는데 brute-force로 하면 시간이 너무나 많이 걸리고, Dynamic Programming을 이용해도 정점의 수가 20개 정도 되면 수십초의 시간이 걸리게 된다. 그래서 정점의 수가 매우 많은 경우 휴리스틱 알고리즘이나 근사값을 찾아내는 알고리즘을 사용한다. 그 중 하나는 Mimimum Spanning Tree(MST, Kruskal 또는 Prim 알고리즘)를 구성한 후 MST를 이루는 간선을 따라 이동하고 이미 갔던 간선을 다시 돌아와야 하는 경우엔 그 간선을 건너뛰는 방법으로 진행하는 방법도 있다. 이 글에서는 그 중 Dynamic Programming 기법을 이용하는 방법을 살펴보자 아이디어 정의 V는 모든 정점의 집합이고 A는 V의 부분 집합이라고 하자. 예를 들어 다음과 같다 . V: {v1, v2, …, vn}, A: {v3, v4} D[Vi][A]는 A에 속한 각 정점을 정확히 한번씩만 거쳐서 vi에서 v1으로 가는 최단 경로의 길이라 하자. 예를 들어 아래 그림에서 D[v2][A={v3, v4}]는 v2에서 v1으로 갈 때 v3와 v4를 거쳐서 가는 것이며, 아래의 두가지 길이 중 짧은 길이의 값을 가진다. D[v2][A={v3, v4}] = min(len(v2 -&gt; v3 -&gt; v4 -&gt; v1), len(v2 -&gt; v4 -&gt; v3 -&gt; v1)) Flow 풀고자 하는 TSP문제는 D[v1][{v2, v3, v4}]를 찾는 것이다. 즉, v1 -&gt; {v2, v3, v4} -&gt; v1인 최단 경로를 찾는 것이다. 그것을 위해 가장 짧은 단위부터 계산을 해서 전체 경로로 확장한다. v2, v3, v4에서 출발해 아무 정점도 거치지 않고 v1으로 가능 경우의 거리 D[v2][0] = 1 (v2에서 v1의 간선 거리) D[v3][0] = 무한대 (v3에서 v1까지 직접 가는 경로가 없음) D[v4][0] = 6 (v4에서 v1의 간선 거리) 하나의 정점을 거쳐 가는 경우 D[v4][{v2}] = 3 + 1 (v4-&gt;v2의 간선 거리 + v2에서 v1까지의 최소 거리) D[v2][{v3}] = 6 + 무한대 (v2-&gt;v3의 간선 거리 + v3에서 v1까지의 최소 거리) D[v4][{v3}] = 무한대 + 무한대 (v4-&gt;v3의 간선 거리 + v3에서 v1까지의 최소 거리) D[v2][{v4}] = 4 + 6 (v2-&gt;v4의 간선 거리 + v4에서 v1까지의 최소 거리) D[v3][{v4}] = 8 + 6 (v3-&gt;v4의 간선 거리 + v4에서 v1까지의 최소 거리) 두개의 정점을 거쳐서 가는 경우 D[v4][{v2, v3}] = min(v4-&gt;v2의 간선거리 + v2에서 v3거쳐 v1갈때까지의 최소거리,v4-&gt;v3의 간선거리 + v3에서 v2거쳐 v1갈때까지의 최소거리) D[v3][{v2, v4}] = min(v3-&gt;v2의 간선거리 + v2에서 v4거쳐 v1갈때까지의 최소거리,v3-&gt;v4의 간선거리 + v4에서 v2거쳐 v1갈때까지의 최소거리) D[v2][{v3, v4}] = min(v2-&gt;v3의 간선거리 + v3에서 v4거쳐 v1갈때까지의 최소거리,v2-&gt;v4의 간선거리 + v4에서 v3거쳐 v1갈때까지의 최소거리) 세개의 정점을 거쳐서 가는 경우 : 최적 일주 여행 경로 D[v1][{v2, v3, v4}] = min(v1-&gt;v2의 간선거리 + v2에서 v3,v4 거쳐 v1갈때까지의 최소거리,v1-&gt;v3의 간선거리 + v3에서 v2, v4거쳐 v1갈때까지의 최소거리, v1-&gt;v4의 간선 거리 + v4에서 v2, v3 거쳐 v1갈때까지의 최소거리) 알고리즘 일반화 시키면 다음과 같다. A는 공집합이 아니면, D[vi][A] = min(W[i][j]+D[vj][A-{vj}]. A가 공집합이면, D[vi][0] = W[i][1] vi에서 출발해서 정점의 부분 집합 A를 거쳐서 v1으로 가는 최단 거리는 A의 정점들을 하나씩 선택해 vj라고 하면 vi-vj간 간선 길이와 vj부터 A의 나머지 정점들을 지나 v1까지의 최단 거리의 합을 구하고 A의 정점 vj 중 그 거리가 가장 짧은 거리를 구해서 D[vi][A]의 값으로 한다. 그리고, vi부터 다른 정점을 지나지 않고 v1까지 가는 경우엔 vi와 v1의 간선 거리가 D가 된다. 구현은 복잡하기 때문에 Pseudo 코드를 간략히 설명하는 것으로 마친다. int W[][] //그래프의 간선 길이 int D[][] //n, V-{v1} tsp(n){ //n: 정점의 수 for(int i = 2; i&lt;= n-2; i++){ D[i][0] = W[i][1] //D[vi][0]를 W[i][1]로 초기화 } for(int k = 1; k&lt;= n-2; k++) for k개의 정점을 포함한 V-{v1}의 모든 subset에 대해 for A에 속하지 않고 v1이 아닌 vi에 대해 D[i][A] = min(W[i][j] + D[vj]][A-{vj}]) D[1][V-{v1}] = min(W[1][j] + D[vj][A - {v1}]) return D[1][v-{v1}] }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html",
    "relUrl": "/docs/codingInterview/2015-08-15-travelling-salesman-problem.html"
  },
  "15": {
    "id": "15",
    "title": "Algorithm - 독립 시행 확률",
    "content": "예제를 통해 독립 시행 확률을 계산하는 방법을 알아보자. 문제 가구를 만드는 공장이 있다. 숙련된 가구 장인은 혼자서 하나의 가구를 5분만에 만들어 낸다. 그러나 가구를 만들어도 결함이 있을 수 있다. 결함이 없는 가구를 완제품이라고 한다. 사장은 두 명의 가구 장인에게 90분동안 가구를 만드는 시함을 시켰다. 그런데 사장은 두 가구 장인이 만들어 내는 완제품의 수가 최소한 한 명이라도 소 수 일 확률이 궁금해 졌다. 가구 장인 A, B가 있을 때 평소 각 장인의 5분안에 완제품을 만들 확률이 주어진다. pA는 A장인이 5분안에 완제품을 만들 확률이며, pB는 B장인이 5분안에 완제품을 만들 확률이다. 각 가구 장인이 만든 완제품의 수가 최소 한 명이라도 소수일 확률을 구하는 프로그램을 작성하라. 예를 들어 pA가 100%, pB가 100%일 경우 최종적으로 A는 18개, B도 18개를 만들어 내고 18은 소수가 아니기 때문에 소수일 확률은 0.00이다. 제약 사항 0&lt;= pA, pB &lt;= 100 입력 맨 위줄에 테스트 케이스 수가 주어지고, 그 뒤 한 줄씩 테스트 케이스의 입력 pA와 pB가 주어진다. 2 0 0 80 90 출력 완제품이 최소 한명이라도 소수일 확률을 각 테스트 케이스 별로 출력한다. 이때 확률의 출력은 소수점 6자리를 넘어가면 소수점 7번 자리에서 반올림한다. #1 0.000000 #2 0.503683 아이디어 18번의 시도를 통해 2개, 3개, 5개… 17개 등 소수 개의 완성품을 확률을 각기 계산하여 합산하면 된다. 그렇게 하기 위해서는 n번의 서로 독립적인 사건 중 r번이 발생할 확률이 얼마인지 계산하는 독립 시행 확률을 계산할 수 있어야 한다. 그리고, A와 B 장인의 확률의 합쳐서 계산해야 하므로 확률의 덧셈정리에 대한 이해도 필요하다. 독립 시행 확률 독립 시행이란 동전이나 주사위를 여러 번 던질 때와 같이 어떤 시행을 계속해서 되풀이 할 때, 매번 일어나는 사건이 서로 독립적인 경우 즉, 각 시행의 결과가 다른 시행의 결과에 영향을 미치지 않는 시행을 말한다. 독립 시행의 확률은 어떤 사건 A가 일어날 확률이 p이고, 그 여사건이 일어날 확률이 q(q=1-p)일때, n번의 독립 시행에서 사건 A가 r번 일어날 확률은 다음과 같다. P(r) = nCr * p의 r제곱 승 * q의 n-r 제곱 승 (r=0, 1, 2, 3, …, n) 조합 서로 다른 n개에서 순서를 생각하지 않고 r개(0&lt;=r&lt;=n)를 택하는 것을 조합이라 하며 그 조합의 수는 다음과 같이 계산한다. nCr = n factorial / (r factorial * n-r factorial) 참고로 순서를 감안한 경우의 수인 순열은 다음과 같다. 서로 다른 n개 중 r개를 택해 순서대로 나열하는 방법의 수 nPr = n factorial / n-r factorial 확률의 덧셈 정리 두 사건 A, B에 대해 사건 A 또는 B가 일어날 확률은 다음과 같다. P(AUB) = P(A) + P(B) - P(A와 B의 교집합) 즉, A의 확률과 B의 확률을 더하고, A와 B가 동시에 일어날 확률을 빼면된다. A와 B가 서로 독립적인 것이라면 A와 B가 동시에 발생할 확률은 두 확률을 곱한 확률과 같다. P(A와 B의 교집합) = P(A)*P(B) C 구현 #include &lt;stdio.h&gt; #define SIZE 19 //총 19 케이스 저장(0:18번 중 0개 완성품, 1:18번중 1개 완성품, ... 18:18번중 18개 완성품) /* Composition을 구하기 위한 factorial 값 저장*/ long long Factorial[SIZE]; long long factorial(int n){ if(n==1){ Factorial[0] = 0; Factorial[1] = 1; return 1; } long long res = n*factorial(n-1); Factorial[n]=res; return res; } /* n개 중 r개를 선택하는 경우의 수 계산: nCr nCr = nfactorial/(rfactorial * (n-r)fractorial) */ int composition(int n, int r){ if(r == 0 || r==n) return 1; long long res = Factorial[n]/Factorial[r]; res /= Factorial[n-r]; return res; } /* 18번 시도하여 소수개의 완성품을 얻을 확률을 그 갯수별로 각각 계산. - 독립 시행 수행 확률 계산 */ double cal(int i_p){ if(i_p == 0){ return 0; } int prime_numbers[7] = {2, 3, 5, 7, 11, 13, 17}; //19의 소수들 double t_p = i_p; double p = t_p/100;//정수 확률을 소수 확률로 전환 //독립 시행 확률 계산을 위해 제곱승을 각기 계산 double P[19]; //독립 시행 확률 계산을 위한 확률 p의 r제곱승을 저장하기 위한 배열 double Q[19]; //독립 시행 확률 계산을 위한 확률 p의 여확률(1-p)의 r제곱승을 저장하기 위한 배열 P[1] = p; Q[1] = 1-p; for(int i = 2; i&lt;18; i++){ P[i] = P[i-1]*p; Q[i] = Q[i-1]*(1-p); } double res = 0; //소수 개를 완성품으로 만들 확률 for(int i = 0; i&lt;7; i++){ //독립 시행 확률 계산 //발생할 확률 p를 가진 독립적인 사건을 n번 수행했을 때 r번 그 사건이 발생할 확률 = nCr * p의 r제곱승 * p의 여확률의 n-r 제곱승 //독립적인 사건이란 한번의 수행 결과가 다음 수행에 영향을 주지 않느 사건: 예- 동전 던져서 앞면이 나올 확률 res += composition(18, prime_numbers[i])*P[prime_numbers[i]]*Q[18-prime_numbers[i]]; } return res; } int main(){ int testcase; int T; scanf(&quot;%d&quot;, &amp;T); factorial(18); for(testcase = 1; testcase&lt;=T; ++testcase){ int p_a, p_b; scanf(&quot;%d %d&quot;, &amp;p_a, &amp;p_b); double res_a = cal(p_a); double res_b = cal(p_b); double res = res_a + res_b - res_a*res_b; //동시에 소수가 나올 확률을 제외해야 함 printf(&quot;#%d &quot;, testcase); printf(&quot;%.6f &quot;, res); } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html",
    "relUrl": "/docs/codingInterview/2015-08-16-independent_probability_problem.html"
  },
  "16": {
    "id": "16",
    "title": "Javascript - scope에 대해 알고자 했던 모든 것",
    "content": "이 글은 javascript 전문가인 Todd Motto의 Everything you wanted to know about Javascript Scope라는 글을 Tood Motto의 동의를 받아 번역한 것이다. 사실 제대로 번역을 했다기 보다는 나의 관점에서 이해하기 용이한 수준으로 정리한 것이라 고백한다. 영문을 국문으로 번역하기 까다롭거나, 이해에 문제가 없는 부분은 건너 뛰거나 간략히 설명하였다. 그러므로, 내용에 대해 정확한 이해를 원한다면 Todd Motto의 원문을 참조하는 것을 권한다. 글의 목적 Javascript는 scope이라는 낯선 개념을 가지고 있는데, 이것은 초보 Javascript 개발자 만이 아니라 경험이 많은 개발자도 이해하기 쉽지 않다. 이 글은 scope, closure, this, namespace, function scope, global scope, lexical scope, public/private scope 등과 같은 Javascript의 어려운 부분에 대한 이해를 높이는 것을 목적으로 한다. 이 글을 통해 다음의 질문들에 대한 답을 얻기를 바란다. scope이란 무엇인가? global/local scope이란? namespace란 무엇이며, scope과 어떻게 다른가? this 키워드는 무엇이며, scope에 어떻게 영향을 미치는가? function/lexical scope이란 무엇인가? closure란? public/private scope이란 무엇인가? 어떻게 위의 모든 개념을 이해하고, 만들고, 사용할 수 있는가? Scope이란 무엇인가? Javascript에서 scope은 작성된 코드를 둘러싼 환경을 말한다. scope은 전역(global) 또는 지역적(local)으로 정의될 수 있다. 제대로된 코드를 작성하고, 더 나은 개발자가 되기 위해서는 Javacript scope에 대해 제대로 이해해야 한다. 이 글을 통해 변수나 function들을 사용할 수 있는 영역이 어디까지 인지를 이해하고, 코드를 둘러싼 scope을 변경할 수 있고, 더 빠르면서도 쉽게 유지 보수 할 수 있는 작성하게 될 것이다. scope의 개념은 쉽게 생각해 다음과 같은 것이다. scope A와 scope B 중 어디 안에 우리가 있는 것인지 파악하는 것이다. Global scope이란? 어떤 Javascript code를 작성하기 전에는 우리는 global scope이라 불리는 곳에 있다. 만약 우리가 하나의 변수를 선언한다면 이것은 global로(전역으로) 정의된다. //global scope var name = &#39;Todd&#39;; global scope은 가장 친한 친구이자 끔찍한 악몽과도 같다. 배우기 쉽고 문제도 거의 없다. 사람들은 global scope이 나쁘다고 하지만, 사실 그 이유를 설명하지는 못한다. global scope은 사실 나쁘지 않으며, 다양한 scope에서 접근하는 모듈이나 API를 만들기 위해서는 global scope을 사용해야 한다. jQuery(&#39;.myClass&#39;); global scope에서 jQuery에 접근하는 위의 코드는 namespace로써 이 접근을 설명할 수 있다. namespace는 때때로 scope과 혼동되어 사용 되지만, 일반적으로는 가장 높은 수준의 scope을 설명하는 것이다. 위의 경우에 jQuery는 global scope안에 있으며, 또한 namespace안에 있는 것이다. jQuery namespace는 global scope안에서 정의되며, 그 안의 모든 jQuery library를 위한 namespace로서 동작한다. Local scope이란 무엇인가? local scope은 global scope외의 scope을 의미한다. 일반적으로 하나의 global scope이 있고, 정의된 각각의 function은 그 자신의 local scope을 가지고 있다. 다른 function 내에 정의된 function은 바깥의 function에 연결된 local scope을 가지고 있다. 만약 하나의 function과 그 안의 여러 변수들을 정의한다면 각각의 변수들의 scope은 그 함수로 제한된다. 다음의 예를 살펴보자. //scope A: 여기가 global scope var myFunction = function(){ //scope B: local scope은 여기 }; local scope으로 제한된 모든 item들은 global scope에 노출되지 않는다면, global scope에서 접근할 수 없다(not visible). 간단한 예는 다음과 같다. var myFunction = function(){ var name = &#39;Todd&#39;; console.log(name); //Todd }; console.log(name); //Uncaught ReferenceError: name is not defined 변수 name의 scope은 local로 제한되고, 부모 scope(여기서는 global scope)에 노출되지 않기 때문에 undefined가 된다. Function scope Javascript내의 모든 scope들은 Function scope과 함께 만들어진다. (global scope은 만들어지는 것이 아니라 기본적으로 존재하는 것이다.) for 또는 while과 같은 loop이나 if 또는 switch와 같은 구문을 통해 만들어지지 않는다. 새로운 function = 새로운 scope - 이것이 규칙이다. 이 scope 생성의 예는 다음과 같다. //scope A var myFunction = function(){ //scope B var myOtherFunction = function(){ //scope C }; }; 새로운 scope과 새로운 변수, function, object를 생성하는 것은 쉽다. Lexical scope 하나의 function내에 다른 function이 있다면, 내부의 function은 외부의 function의 scope에 접근할 수 있다. 이것을 우리는 Lexical Scope 또는 Closure라 부르며, 또는 Static Scope아라 하기도 한다. 간단한 예는 아래와 같다. //scope A var myFunction = function(){ //scope B var name = &#39;Todd&#39;; // scope B에서 정의 var myOtherFunction = function(){ //scope C: &#39;name&#39; 변수에 접근할 수 있다. }; }; myOtherfunction이 myFunction내에서 정의된 것일 뿐 항상 myFunction내에서만 호출되지 않을 수 있다는 것을 기억하자. var myFunction = function () { var name = &#39;Todd&#39;; var myOtherFunction = function () { console.log(&#39;My name is &#39; + name); }; console.log(name); myOtherFunction(); // myOtherFunction 호출 }; myFunction(); // myFunction 호출 위의 코드를 실행하면 아래와 같은 결과를 얻을 수 있다. Todd My name is Todd Lexical scope은 부모 scope안에 정의된 어떠한 변수, object, function과도 쉽게 연동된다. 그것들은 scope chain안에서 접근 가능하다. 예를 들어 다음과 같다. var name = &#39;Todd&#39;; var scope1 = function () { // name 은 여기서 접근 가능하다. var scope2 = function () { // name 은 여기서도 접근 가능하다. var scope3 = function () { // name 은 여기서도 역시 접근 가능하다. }; }; }; Lexical scope은 반대방향으로는 동작하지 않는다는 것은 기억해야 한다. 다음의 경우가 그렇다. // name = undefined var scope1 = function () { // name = undefined var scope2 = function () { // name = undefined var scope3 = function () { var name = &#39;Todd&#39;; // local scope }; }; }; 우리는 변수 name의 참조를 return할 수는 있지만, 결코 그 변수 자체를 return할 수는 없다. Scope Chain 알고있는 바와 같이, 정의된 function 각각은 자신만의 중첩된 scope을 가지고 있다. 다른 function 안에 정의된 local scope을 가진 내부 function은 바깥 function과 연결되어 있다. 그 연결을 우리는 scope chain이라고 부른다. 코드 안에 어디에 위치하느냐가 scope chain에서의 scope을 결정한다. function내의 변수를 ‘resolve’(번역을 어떻게 해야할 지 모르겠다)할 때, Javascript는 변수를 찾을 때까지 그 scope - scope chain의 가장 내부 scope - 에서 시작해서 scope chain을 따라 바깥쪽 scope 방향으로 검색을 한다. Closure Closure는 Lexical scope과 강하게 연결되어 있다. 어떻게 closure가 동작하는지 이해하기 위한 좋은 예는 function reference를 반환하는 경우이다. 한 function의 scope 내에서 parent scope의 변수를 사용하는 것을 생각해보자. 그리고 그 function reference를 반환하면 parent scope의 변수는 어떻게 될까? var sayHello = function (name) { var text = &#39;Hello, &#39; + name; return function () { console.log(text); }; }; sayHello 안에 closure 개념의 function을 정의해 외부에서 접근할 수 없는 scope을 만들었다. sayHello function을 호출하는 것만으로는 어떠한 일도 생기지 않는다. 어떤 출력도 없으며 단지 하나의 function이 반환될 뿐이다. sayHello(&#39;Todd&#39;); // 어떠한 일도 발생하지 않는다. function을 반환하는 function을 사용하기 위해서는 할당 후 호출해야 한다는 의미이다. var helloTodd = sayHello(&#39;Todd&#39;); helloTodd(); //이것은 closure를 호출하여 &#39;Hello, Todd&#39;를 출력한다. 사실, closure를 사용하기 위해 ‘할당 후 호출’이 필요하다는 것은 거짓말이다. 다음과 같이 사용할 수도 있다. sayHello2(&#39;Bob&#39;)(); // 반환된 함수를 할당없이 바로 호출 AngularJS에서의 Closure 사용예 AngularJS는 위와 같은 테크닉을 $compile 메소드를 위해 사용하고 있다. 이것은 현재 scope reference를 closure의 인수로 사용한다. $compile(template)(scope); 우리는 위의 코드가 실제 다음과 같이 구현되어 있을 것이라 추측할 수 있다. var $compile = function (template) { ... return function (scope) { //&#39;template&#39;과 &#39;scope&#39; 에 접근해서 무언가 한다. }; }; function을 반환하는 function을 closure라고 부르지 않는다. 그보다는 간단히 말해, closure는 바깥의 scope의 변수를 사용하는 immediate lexical scope이라 할 수 있다. Scope과 ‘this’ 키워드 각 scope은 어떻게 그 function이 호출되느냐에 따라 달라지는 this의 값을 바인드 하고 있다. this 키워드를 다들 사용하고 있지만, 많은 사람들은 호출될 때에 따라 어떻게 그 것이 달라지는지 정확히 이해하지 못하고 있다. default로 this는 가장 바깥의 global object인 window를 가리킨다. function을 호출하는 방식을 달리하는 것으로 this의 값을 다르게 바인드 할 수 있다. 그 예는 다음과 같다. var myFunction = function () { console.log(this); // this = global, [object Window] }; myFunction(); var myObject = {}; myObject.myMethod = function () { console.log(this); // this = Object { myObject } }; var nav = document.querySelector(&#39;.nav&#39;); // &lt;nav class=&quot;nav&quot;&gt; var toggleNav = function () { console.log(this); // this = &lt;nav&gt; element }; nav.addEventListener(&#39;click&#39;, toggleNav, false); this 값의 변화 this와 관련된 문제도 있다. 예를 들어 같은 function내에서도 scope이 변화 될 수 있고, 이때 또한 this의 값도 변화될 수 있다. var nav = document.querySelector(&#39;.nav&#39;); // &lt;nav class=&quot;nav&quot;&gt; var toggleNav = function () { console.log(this); // &lt;nav&gt; element setTimeout(function () { console.log(this); // [object Window] }, 1000); }; nav.addEventListener(&#39;click&#39;, toggleNav, false); 무슨 일이 생긴 걸까? 이벤트 핸들러로부터 호출되지 않은 새로운 scope이 생성되었고, 그래서 default인 window object가 this의 값이 된 것이다. 새로운 scope에 영향받지 않는 this 값을 얻기 위해서는 어떻게 해야 할까? 그렇게 하기 위해서 this의 값을 저장할 새로운 변수 - 여기서는 that - 를 사용한 lexical 바인딩을 한다. var nav = document.querySelector(&#39;.nav&#39;); // &lt;nav class=&quot;nav&quot;&gt; var toggleNav = function () { var that = this; //this의 값을 저장 console.log(that); // &lt;nav&gt; element setTimeout(function () { console.log(that); // &lt;nav&gt; element }, 1000); }; nav.addEventListener(&#39;click&#39;, toggleNav, false); 이것이 새롭게 생성된 scope에서도 원하는 this 값을 참조할 수 있는 방법이다. .call(), .apply(), .bind()를 이용하여 scope 변경하기 때때로 Javascript의 scope을 조작할 필요가 있다. 반복문 내에서 scope이 어떻게 변경되는지에 대 설명하기 위한 간단한 샘플 코드는 아래와 같다. var links = document.querySelectorAll(&#39;nav li&#39;); for (var i = 0; i &lt; links.length; i++) { console.log(this); // [object Window] } 위의 코드에서 this의 값은 어떤 element도 가리키지 않으며, 우리는 어떤 것도 호출하거나 scope을 변경하기 위한 무엇도 하지 않았다. 이제, 우리가 어떻게 scope을 바꿀 수 있는지 살펴보자. (사실, scope을 변경하는 것처럼 보이지만, 실제 우리가 하는 것은 function이 호출되는 환경을 변경하는 것이다.) .call()과 .apply() .call()과 apply() 메소드는 정말 엄청나다! 그 메소드들을 통해 올바른 this 값을 바인드하고 있는 function의 scope안으로 들어갈 수 있다. 위의 샘플 코드를 변경하여 배열 내의 각 element을 this 값으로 하는 경우를 살펴 보자. var links = document.querySelectorAll(&#39;nav li&#39;); for (var i = 0; i &lt; links.length; i++) { (function () { console.log(this); }).call(links[i]); } 위의 this의 값이 반복되는 element를 가리키도록 function의 scope을 links[i]로 변경했다. .call()과 .apply()의 차이 .call()이나 .apply()를 이용해 scope을 변화시킬 수 있는데 그 둘 사이에는 약간의 차이가 있다. .call()(scope, arg1, arg2, arg3)은 쉼표를 이용해 각 각의 인수를 구분하는 반면, .apply(scope, [arg1, agr2])는 하나의 배열을 이용해 인수를 넘겨준다. .call() 또는 .apply()를 하더라도 실제 function을 호출한다는 점에서는 동일하다. myFunction(); //myFunction 호출 .call()을 사용해서 function을 호출 해보자. myFunction.call(scope); //.call()을 이용해 myFunction 호출 .bind() .bind()는 function을 호출하지 않는다. 대신 function을 호출하기 전에 그 값들과 단지 바인드 할 뿐이다. .bind()는 ECMASCript5에서 소개되었는데, 소개된 초기만큼 좋은 평가를 받지는 못하고 있다. function reference를 자신의 인수와 함께 다른 function의 인수로 사용할 수 있는지 살펴보자. 물론, 우리는 function reference에 인수를 넣어 다른 function의 인수로 사용할 수 없다는 것을 알고 있다. 예를 들어 다음을 보자. // toggleNav가 addEventListener의 인수로 동작한다. nav.addEventListener(&#39;click&#39;, toggleNav, false); // toggleNav(arg1, arg2)가 addEventListener의 인수로 동작하지 않고, 바로 실행된다. nav.addEventListener(&#39;click&#39;, toggleNav(arg1, arg2), false); 위의 경우를 다음과 같이 바꿀 수 있다. function을 새로 정의해 그 function을 다른 function의 인수로 사용하는 것이다. nav.addEventListener(&#39;click&#39;, function () { toggleNav(arg1, arg2); }, false); 하지만, toggleNav는 한 function의 내부 function으로 바뀌었기 때문에 scope이 바꾸어진 것이고 이것은 우리가 원하는 바가 아니다. .bind()는 이런 문제를 해결해 준다. function이 호출되지 않은 채 다른 function의 인수로 사용될 수 있게 한다. nav.addEventListener(&#39;click&#39;, toggleNav.bind(scope, arg1, arg2), false); toggleNav는 호출되지 않고, 또한 scope이 변화되지 않은채로(필요하다면 변화시킬 수 있다.) 그 인수들과 함께 다른 function의 인수로 사용되어 졌다. Private 및 Public Scope 많은 프로그래밍 언어에는 public과 private scope이 있다. - Java와 C++에는 public/private 키워드가 존재한다. 하지만, Javascript에는 그런 것들이 없다. 대신 Closure를 통해 비슷한 개념을 만들어 낼 수 있다. Javascript 디자인 패턴을 이용하면, 예를 들어 module 패턴을 이용하면, 우리는 public/private scope을 만들수 있다. private scope을 만드는 간단한 방법 private scope을 만드는 간단한 방법은 function들을 하나의 function으로 감싸는 것이다. 우리가 배운 바와 같이 function은 scope을 만들기 때문에 global scope이 아닌 다른 scope으로 function들을 이동시키는 것이다. (function () { // 여기는 private scope })(); 그리고, function 내에서 사용하기 위해 몇 개의 function을 추가할 수 있다. (function () { var myFunction = function () { // 여기서 필요한 작업을 한다. }; })(); 우리가 정의한 내부의 function을 외부에서 호출하면 에러가 발생한다. 즉, 우리는 private scope을 만드는 것을 성공한 것이다! (function () { var myFunction = function () { // ... }; })(); myFunction(); // Uncaught ReferenceError: myFunction is not defined module 패턴 만약 그 내부 function을 public으로 만들기 원한다면? module 패턴 (그리고 revealing module 패턴)이라 불리는 훌륭한 패턴을 이용하면 우리의 function의 scope을 올바르게 정할 수 있다. function 반환을 통한 module 패턴 구현 관련된 모든 코드를 포함하고 있는 ‘Module’이라 불리는 global namespace를 살펴보자. // module 정의 var Module = (function () { return { myMethod: function () { console.log(&#39;myMethod has been called.&#39;); } }; })(); // module + 메소드의 호출 Module.myMethod(); 위에서 return 구문은 public 메소드를 반환한다. 그 메소드는 global scope(namespace)에서 접근 가능하다. 위의 Module은 다음과 같이 확장 가능하다. // module 정의 var Module = (function () { return { myMethod: function () { }, someOtherMethod: function () { } }; })(); // module + 메소드의 호출 Module.myMethod(); Module.someOtherMethod(); private 메소드는 어떨까? 많은 개발자들이 global scope안에 모든 function들을 마구 정의하기 때문에 global namespace가 더럽혀진다. 굳이 외부에 공개될 필요가 없는 function들은 global scope에 있을 필요가 없고, 단지 API만이 global scope에 있으면 된다. 다음 코드는 return되지 않는 function들을 이용해 private scope을 만들어 낼수 있다는 것을 보여준다. var Module = (function () { var privateMethod = function () { }; return { publicMethod: function () { } }; })(); publicMethod는 외부에서 호출되어질 수 있는 반면 privateMethod는 그렇지 않다. 즉, privateMethod는 private scope에 있는 것이다. 이런 private scope안에 헬퍼, addClass, removeClass, Ajax/XHR 호출, 배열, 객체 등이 위치할 수 있다. 다음의 예는 public 메소드가 반환된 이후에도 global scope에서는 접근할 수 없는 private 메소드에 접근할 수 있다는 것을 보여준다. var Module = (function () { var privateMethod = function () { }; return { publicMethod: function () { // prvateMethod()를 호출할 수 있다. } }; })(); 이것은 코드 보안성과 더불어 아주 강력한 수준의 상호 연동성을 제공한다. Javascript의 가장 중요한 부분 중 하나는 보안을 유지하는 것이다. 그것이 바로 우리가 모든 function들을 global scope에 정의해서 아무 곳에서나 접근하도록 하지 않는 이유이다. Object 반환을 통한 module 패턴 구현 public/private 메소드를 사용하기 위해 Object를 반환하는 예이다. var Module = (function () { var myModule = {}; var privateMethod = function () { }; myModule.publicMethod = function () { }; myModule.anotherPublicMethod = function () { }; return myModule; // public 메소드들과 함께 Object 반환 })(); // 사용 Module.publicMethod(); 네임 컨벤션 중 하나는 밑줄과 함께 private 메소드를 시작하는 것이다. 이것은 시각적으로 public과 private을 구분할 수 있게 도와준다. var Module = (function () { var _privateMethod = function () { }; var publicMethod = function () { }; })(); Object 스타일로 정의된 Object 반환을 통한 module 패턴 구현 익명의 Object를 반환할 때 간단히 function reference를 지정하는 Object 스타일로도 module 패턴을 만들수 있다. var Module = (function () { var _privateMethod = function () { }; var publicMethod = function () { }; return { publicMethod: publicMethod, anotherPublicMethod: anotherPublicMethod } })();",
    "url": "http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html",
    "relUrl": "/docs/javascript/2015-08-24-everything-about-javascript-scope.html"
  },
  "17": {
    "id": "17",
    "title": "Algorithm - combination",
    "content": "알고스팟의 문제 중 CLOCKSYNC 라는 것이 있다. 이 문제의 해결 방법은 조합도 있지만, Greedy로 문제를 푸는 방식도 있는데 조합의 경우를 살펴보자. 간단한 조합 문제 그림과 같이 4 x 4 개의 격자 형태로 배치된 16개의 시계가 있다. 이 시계들은 모두 12시, 3시, 6시, 혹은 9시를 가리키고 있다. 이 시계들이 모두 12시를 가리키도록 바꾸고 싶다. 시계의 시간을 조작하는 유일한 방법은 모두 10개 있는 스위치들을 조작하는 것으로, 각 스위치들은 모두 적게는 3개에서 많게는 5개의 시계에 연결되어 있다. 한 스위치를 누를 때마다, 해당 스위치와 연결된 시계들의 시간은 3시간씩 앞으로 움직인다. 스위치들과 그들이 연결된 시계들의 목록은 다음과 같다. 0 0, 1, 2 1 3, 7, 9, 11 2 4, 10, 14, 15 3 0, 4, 5, 6, 7 4 6, 7, 8, 10, 12 5 0, 2, 14, 15 6 3, 14, 15 7 4, 5, 7, 14, 15 8 1, 2, 3, 4, 5 9 3, 4, 5, 9, 13 시계들은 맨 윗줄부터, 왼쪽에서 오른쪽으로 순서대로 번호가 매겨졌다고 가정하자. 시계들이 현재 가리키는 시간들이 주어졌을 때, 모든 시계를 12시로 돌리기 위해 최소한 눌러야 할 스위치의 수를 계산하는 프로그램을 작성하시오. 아이디어 문제를 푸는 방법을 생각해보자. 각 버튼마다 4가지의 가능성이 있다. 누르지 않거나, 한번, 두번, 세번 누르는 경우이다. 버튼을 누르는 순서는 문제의 풀이와 상관이 없다라는 것도 중요하다. 이렇게 보면 조합을 이용해 문제를 풀 수 있음을 알 수 있다. 모든 조합에 대해 테스트해보는 것이다. Pseudo code n개의 아이템과 각 아이템별 x개의 경우의 수가 있다면 총 nx개의 조합을 만들 수 있다. 위의 문제의 경우는 410의 경우의 수가 있다. 그리고, 버튼을 누를 수 있는 최대의 수는 30회가 된다. 순서가 상관없으므로 아이템 1개를 가지고 x개의 경우의 수를 테스트하고, 각 경우의 수 마다 다음으로 이동해서 테스트 하는 방식으로 수행한다. 이런 방식으로 간단히 조합 문제를 풀 수 있다. answer = 31; push_count = 0; cal(button_index){ if(Button_index &lt; 10){ for 버튼을 누른 횟수(1-&gt;4){ 해당된 Clock들을 조작 push_count++; Clock이 모두 12시를 가리키는지 검사해서 맞으면 answer = push_count &lt; answer? push_count: answer; cal(button_index + 1); } push_count -= 4; //한바퀴 돌아서 제자리가 된 것이므로 push_count를 1 줄인다. } }",
    "url": "http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html",
    "relUrl": "/docs/codingInterview/2015-08-27-combination-in-c.html"
  },
  "18": {
    "id": "18",
    "title": "Algorithm - quick sort",
    "content": "The performance of quicksort There are a lot of implementations of quick sort algorithm. Even though the time complexity of the algorithm is nlog(n), the real performance is highly depending on the partition algorithm. The pseudo code of quicksort algorithm is as follows. quickSort(A[], l, r) if l&lt;r s &lt;- partition (a, l, r) quickSort(A[], l, s-1) quickSort(A[], s+1, r) Two partition algorithms There are two famous partition algorithms. As my experience, Lumuto-Partition is better for performance and readibility. Hoare-Partition algorithm Hoare-Partition algorithm is not so good to understand due to several duplicated loops. The pseudo code of Hoare-partition algorithm: partition(A[], l, r) p &lt;- A[l] i &lt;-l, j&lt;- r while i &lt;= j while A[i] &lt;= p: i++ while A[j] &gt;= p: j-- if i&lt;j : swap(A[i], A[j]) swap(A[l], A[j]) return j Lumuto-Partition algorithm The pseudo code of Lumuto-partition algorithm: partition(A[], l, r) x &lt;- A[r] i &lt;- l - 1 for j in l-&gt;r-1 if A[j] &lt;= x i++, swap(A[i], A[j]) swap(A[i+1], A[r]) return i + 1 The following source code presents the Lumuto-Partition implementation. This is very fast. Morover, the code is intuitive and easy to understand. #include &lt;stdio.h&gt; void swap(int array[], int a, int b){ int tmp = array[a]; array[a] = array[b]; array[b] = tmp; } int partition(int array[], int low, int high){ int last = array[high]; int index = low; for (int i = low; i &lt; high; i++){ if (array[i] &lt;= last){ swap(array, i, index); index++; } } swap(array, index, high); return index; } /* quick sort function*/ void qsort(int array[], int low, int high){ if (high &lt;= low) return; int pivot = partition(array, low, high); qsort(array, low, pivot - 1); qsort(array, pivot + 1, high); } /* Test function*/ int main(){ int sample[10] = { 3, 7, 8, 5, 2, 1, 9, 0, 4, 6 }; qsort(sample, 0, 9); for (int i = 0; i &lt;= 9; i++){ printf(&quot;%d &quot;, sample[i]); } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html",
    "relUrl": "/docs/codingInterview/2016-02-05-algorithm-quicksort.html"
  },
  "19": {
    "id": "19",
    "title": "Algorithm - 이분 탐색",
    "content": "O(logN) 시간내에 정렬된 값을 탐색하는 방법으로 조건을 만족하는 다양한 값들 중 최적 값을 찾아내는데 사용된다. Pseudo code 중복된 값들이 포함되어 있을 수 있으므로 while문 내에서 바로 return하지 않고 탐색을 계속해서 중복 값 중 가장 크거나 작은 인덱스를 반환한다. int findIndex(int array[], int low, int high, int target_value){ int answer = -1; // 값을 못 찾는 경우 -1 반환 while(low &lt;= high){ int middle = (low + high)/2; if(array[middle]와 target_value를 비교해서 조건일 일치하면 ){ anwser = middle; //값을 갱신 high = middle - 1 또는 low = middle + 1로 갱신 } else { //조건에 일치하지 못할 경우 low = middle + 1 또는 high = middle - 1로 갱신 } } return answer; } code #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int findSame(int arr[], int low, int high, int target){ int ans = -1; //못찾으면 -1 while(low &lt;= high){ int m = (low + high)/2; if(arr[m] == target){ //같은 경우 그보다 더 작은 index에도 같은 값이 있는지 확인해야 하므로 현재 앞 index를 high로 설정 ans = m; high = m-1; } else if(arr[m] &lt; target){ //찾는 값보다 더 작은 경우, 더 뒷 index에 값이 있을 가능성이 있으므로 현재 index 뒷 index를 low로 설정 low = m+1; } else { //찾는 값보다 더 큰 경우, 더 앞의 index에 값이 있을 가능성이 있으므로 현재 앞 index를 high로 설정 high = m-1; } } return ans; //마지막에 찾아진 위치를 출력 } int findBig(int arr[], int low, int high, int target){ int ans = -1; //못찾으면 -1 while(low &lt;= high){ int m = (low + high)/2; if(arr[m] &gt; target){ //찾는 값보다 더 큰 경우, 더 앞의 index에서도 목표값보다 큰 값이 있을 수 있으므로 현재 앞 index를 high로 설정 ans = m; high = m - 1; } else { //찾는 값과 같거나 더 작은 경우 더 뒤 index에 값이 있을 가능성이 있으므로 뒷 index를 low로 설정 low = m+1; } } return ans; //마지막에 찾아진 위치를 출력 } int findSmall(int arr[], int low, int high, int target){ int ans = -1; //못찾으면 -1 while(low &lt;= high){ int m = (low + high)/2; if(arr[m] &lt; target){ //찾는 값보다 더 작은 경우, 더 뒤 index에서도 목표값보다 작은 값이 있을 수 있으므로 뒤 index를 low로 설정 ans = m; low = m + 1; } else { //찾는 값과 같거나 큰 경우 더 앞 index에 값이 있을 가능성이 있으므로 앞 index를 high로 설정 high = m-1; } } return ans; //마지막에 찾아진 위치를 출력 } int findSameorBig(int arr[], int low, int high, int target){ int ans = -1; //못찾으면 -1 while(low &lt;= high){ int m = (low + high)/2; if(arr[m] &gt;= target){ //찾는 값과 같거나 더 큰 경우, 더 앞의 index에서도 목표값보다 큰 값이 있을 수 있으므로 현재 앞 index를 high로 설정 ans = m; high = m - 1; } else { //찾는 값보다 더 작은 경우 더 뒤 index에 값이 있을 가능성이 있으므로 뒷 index를 low로 설정 low = m+1; } } return ans; //마지막에 찾아진 위치를 출력 } int findSameorSmall(int arr[], int low, int high, int target){ int ans = -1; //못찾으면 -1 while(low &lt;= high){ int m = (low + high)/2; if(arr[m] &lt;= target){ //찾는 값과 같거나 더 작은 경우, 더 뒤 index에서도 목표값보다 같거나 작은 값이 있을 수 있으므로 뒤 index를 low로 설정 ans = m; low = m + 1; } else { //찾는 값보다 더 큰 경우 더 앞 index에 값이 있을 가능성이 있으므로 앞 index를 high로 설정 high = m-1; } } return ans; //마지막에 찾아진 위치를 출력 } int main(){ int T[7] = {1, 2, 3, 3, 4, 5, 6}; //목표값과 같은 것 중 가장 빠른 index cout &lt;&lt; findSame(T, 0, 6, 3)&lt;&lt; endl; //must be 2 cout &lt;&lt; findSame(T, 0, 6, 1)&lt;&lt; endl; //must be 0 cout &lt;&lt; findSame(T, 0, 6, 6)&lt;&lt; endl; //must be 6 cout &lt;&lt; findSame(T, 0, 6, 7)&lt;&lt; endl; //must be -1 //목표값보다 큰 값 중 가장 빠른 index(가장 작은) cout &lt;&lt; findBig(T, 0, 6, 2)&lt;&lt;endl; //must be 2 cout &lt;&lt; findBig(T, 0, 6, 0)&lt;&lt;endl; //must be 0 cout &lt;&lt; findBig(T, 0, 6, 1)&lt;&lt; endl; //must be 1 cout &lt;&lt; findBig(T, 0, 6, 6)&lt;&lt;endl; //must be -1 //목표값보다 작은 값 중 가장 큰 index(가장 큰) cout &lt;&lt; findSmall(T, 0, 6, 4)&lt;&lt;endl; //must be 3 cout &lt;&lt; findSmall(T, 0, 6, 7)&lt;&lt;endl; //must be 6 cout &lt;&lt; findSmall(T, 0, 6, 0)&lt;&lt;endl; //must be -1 cout &lt;&lt; findSmall(T, 0, 6, 1)&lt;&lt;endl; //must be -1 //목표값과 같거나 큰 값 중 가장 빠른 index cout &lt;&lt; findSameorBig(T, 0, 6, 2)&lt;&lt;endl; //must be 1 cout &lt;&lt; findSameorBig(T, 0, 6, 3)&lt;&lt;endl; //must be 2 cout &lt;&lt; findSameorBig(T, 0, 6, 6)&lt;&lt;endl; //must be 6 cout &lt;&lt; findSameorBig(T, 0, 6, -1)&lt;&lt;endl; //must be 0 cout &lt;&lt; findSameorBig(T, 0, 6, 7)&lt;&lt;endl; //must be -1 //목표값과 같거나 작은 값 중 가장 큰 index cout &lt;&lt; findSameorSmall(T, 0, 6, 4)&lt;&lt;endl; //must be 4 cout &lt;&lt; findSameorSmall(T, 0, 6, 3)&lt;&lt;endl; //must be 3 cout &lt;&lt; findSameorSmall(T, 0, 6, -1)&lt;&lt;endl; //must be -1 cout &lt;&lt; findSameorSmall(T, 0, 6, 7)&lt;&lt;endl; //must be 6 return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html",
    "relUrl": "/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html"
  },
  "20": {
    "id": "20",
    "title": "Algorithm - Longest Increasing Subsequence",
    "content": "Longest Increasing Sequence는 “순서” 또는 “아이템들을 연속해서 조합할 때의 최대” 등을 구할 때 매우 많이 사용되는 방법이다. 그런데 이때 보통 i번째 아이템에 대해 0부터 i-1까지의 아이템을 비교해서 최대값을 갱신하는 O(n*n) 알고리즘이 흔히 사용된다. for(int i = 1; i&lt;n; i++){ for(int j = i - 1; j&lt; i; j++){ T[i] = max(T[i], T[j] + In[i]); } } 그런데 이런 식으로 하면 n이 100000이 넘어가면 계산이 너무 오래 걸린다. 그러므로 O(NlogN)알고리즘을 사용할 수 있어야 한다. 입력이 10000이하이면 구현이 용이한 O(n*n) 알고리즘을, 그 이상이면 O(NlogN) 알고리즘을 사용하는 것을 추천한다. logN LIS 필요한 자료구조 입력 저장: int In[] 계산 중의 LIS 저장: int T[], 초기값 T[0] = 0 각 입력값 별 LIS시 이전 아이템 저장: int R[], 초기값 -1 현재의 LIS 길이 저장: int lastIdx, 초기값 0 vector&lt;int&gt; T(In.size(), 0); vector&lt;int&gt; R(In.size(), -1); int lastIdx = 0; T[0] = 0; 계산 항상 가장 작은 값으로 구성된 T를 유지함으로써 LIS를 찾아낼 수 있도록 In[1]부터 마지막 아이템까지 진행하면서 다음을 수행한다. In[T[lastIdx]] &lt; In[i]이면, (마지막 아이템과 비교해서 더 크면): R[i] = T[lastIdx], lastIdx++, T[lastIdx] = i In[T[lastIdx]] &lt; In[i]가 아니고, In[T[0]] &gt; In[T[i]]이면 (가장 작은 아이템과 비교해서 더 작으면): T[0] = i 위의 조건에 만족하지 않으면 T[1]부터 T[lastIdx]중의 하나에 i값을 넣는다. 그 기준은 “In[i]의 같거나 큰 값 중 가장 작은 값”에 넣는 것이다. 이를 통해 마지막 위치(lastIdx)도 갱신될 수 있다. 항상 T[0]부터 T[lastIdx]이 가리키는 In[]값은 정렬되어 있으므로 logN탐색을 위해 이분 탐색을 이용한다. 그렇게 T[j]가 찾아지면: R[i] = T[j-1], T[j] = i 위의 내용을 코드로 표현하면 다음과 같다. for(int i = 1; i&lt; In.size(); i++){ if(In[T[lastIdx]] &lt; In[i]){ R[i] = T[lastIdx]; T[++lastIdx] = i; } else if(In[T[0]] &gt; In[i]){ T[0] = i; } else { int idx = findBigorSame(In, T, 0, lastIdx, In[i]); R[i] = T[idx - 1]; T[idx] = i; } } 그런데, R[]은 계산이 끝나고 최대 값을 구성하는 아이템이 무엇인지 추적하기 위한 자료구조이고, T[]에 값이 아닌 index를 넣는 이유는 R[]을 쉽게 갱신하기 위한 것이다. 그러므로, 만약 풀고자 하는 문제가 단순한 최대 값이라면 R[]을 사용하지 않아도 되며, 또한 T[]도 인덱스가 아닌 값을 저장하면 된다. 그 코드의 예는 다음과 같다. for(int i = 1; i&lt; In.size(); i++){ if(T[lastIdx] &lt; In[i]){ T[++lastIdx] = In[i]; } else if(T[0] &gt; In[i]){ T[0] = In[i]; } else { int idx = findBigorSame(T, 0, lastIdx, In[i]); //T를 이분탐색 T[idx] = In[i]; } } 결과 처리 마지막 아이템까지 진행이 끝났을 때 lastIdx + 1가 LIS의 길이가 되며, R[]은 각 index보다 앞의 것을 가리키게 된다. 그래서 순서를 구할 때는 R을 이용해서 역순으로 찾는다. vector&lt;int&gt; Out(lastIdx + 1); //In의 index를 저장한다. int oIdx = lastIdx; Out[oIdx--] = T[lastIdx]; int prvIdx = R[T[lastIdx]]; while(prvIdx != -1){ Out[oIdx--] = prvIdx; prvIdx = R[prvIdx]; } ... for(int i = 0; i&lt;Out.size(); i++){ cout &lt;&lt; In[Out[i]] &lt;&lt; &quot; &quot;; } Code #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int findBigorSame(vector&lt;int&gt; &amp; In, vector&lt;int&gt; &amp; T, int low, int high, int tar_val){ int answer = -1; while(low &lt;= high){ int middle = (low + high)/2; if(In[T[middle]] &gt;= tar_val){ answer = middle; high = middle - 1; } else { low = middle + 1; } } return answer; } vector&lt;int&gt; logNLIS(vector&lt;int&gt; &amp; In){ //초기화 vector&lt;int&gt; T(In.size(), 0); vector&lt;int&gt; R(In.size(), -1); int lastIdx = 0; T[0] = 0; //계산 for(int i = 1; i&lt; In.size(); i++){ if(In[T[lastIdx]] &lt; In[i]){ R[i] = T[lastIdx]; T[++lastIdx] = i; } else if(In[T[0]] &gt; In[i]){ T[0] = i; } else { int idx = findBigorSame(In, T, 0, lastIdx, In[i]); R[i] = T[idx - 1]; T[idx] = i; } } //LIS를 첫순서부터 저장 vector&lt;int&gt; Out(lastIdx + 1); int oIdx = lastIdx; Out[oIdx--] = T[lastIdx]; int prvIdx = R[T[lastIdx]]; while(prvIdx != -1){ Out[oIdx--] = prvIdx; prvIdx = R[prvIdx]; } return Out; } int main(){ vector&lt;int&gt; In = {3, 4, -1, 5, 8, 2, 3, 12, 7, 9, 10 }; vector&lt;int&gt; Out = logNLIS(In); cout &lt;&lt; &quot;SIZE : &quot; &lt;&lt; Out.size() &lt;&lt; endl; //must be 6 cout &lt;&lt; &quot;SEQUENCE : &quot;; for(int i = 0; i&lt;Out.size(); i++){ cout &lt;&lt; In[Out[i]] &lt;&lt; &quot; &quot;; //must be -1 2 3 7 9 10 } cout &lt;&lt; endl; return 0; } Reference Javacode와 동영상 강의를 참고하자. 실전 문제 쉬운 문제들 꼬인 전깃줄 문제 최대 100000개의 입력이 들어오므로 O(n*n)으로 하면 timeout이 나므로 nlogn알고리즘을 이용해야 한다. LIS의 구성을 묻지 않고 단순히 잘라야할 전기줄의 수를 묻는 문제이므로 R[]을 저장하지 않고 T[]만 이용해서 계산한다. int lis(vector&lt;int&gt; &amp;In){ vector&lt;int&gt; T(In.size()); int lastIdx = 0; T[0] = 0; int size = (int)In.size(); for(int i = 1; i&lt;size; i++){ if(In[T[lastIdx]] &lt; In[i]){ //In[T의 마지막]보다 더 크면 하나 증가 lastIdx++; T[lastIdx] = i; } else if(In[T[0]] &gt; In[i]){ //In[T[0]]보다 작으면 T[0] 갱신 T[0] = i; } else { // In[T[0]]~In[T[lastIdx]] 중 In[i]보다 같거나 큰 최초의 수를 갱신 int idx = findSameorBig(In, T, 0, lastIdx, In[i]); T[idx] = i; } } return lastIdx + 1; } 반도체 설계 문제 꼬인 전깃줄과 동일한 방식으로 풀면 되는 문제이다. 최대 40000개의 입력이며, LIS의 구성을 묻지 않고 단순히 갯수를 묻는 문제이다. *입력을 저장하지 않고 바로 처리하도록 풀었으며 이로 인해 T[]는 *index를 저장하는 것이 아니라 값을 직접 저장하도록 수정했다. int findSameorBig(vector&lt;int&gt; &amp;T, int low, int high, int target){ int ans = -1; while(low &lt;= high){ int m = (low + high)/2; if(T[m] &gt; target){ ans = m; high = m - 1; } else { low = m + 1; } } return ans; } int main(){ int N; cin &gt;&gt; N; int t; vector&lt;int&gt; T(N); int lastIdx = 0; cin &gt;&gt; t; T[lastIdx] = t; for(int i = 1; i&lt;N; i++){ cin &gt;&gt; t; if(T[lastIdx] &lt; t){ lastIdx++; T[lastIdx] = t; } else if (T[0] &gt; t){ T[0] = t; } else { int idx = findSameorBig(T, 0, lastIdx, t); T[idx] = t; } } cout &lt;&lt; lastIdx + 1; return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html",
    "relUrl": "/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html"
  },
  "21": {
    "id": "21",
    "title": "Algorithm - maximum sum subarray",
    "content": "Maximum Sum Subarray를 알아내는 Kadane알고리즘은 array의 연속 부분합 중 가장 큰 값을 O(N)시간 복잡도로 알아내는 알고리즘이다. 2D Matrix에서 최대 합을 가진 영역을 알아내는 용도등을 위해 사용된다. 필요한 자료 구조 지금까지의 최대 합을 저장하는 max_sum: -987654321로 초기화 현재 계산하는 아이템을 고려했을때의 최대 합을 저장하는 cur_max_sum: -987654321로 초기화 int max_sum = -987654321; int cur_max_sum = -987654321; 영역이 필요하다면 s_idx와 e_idx와 max_s_idx와 max_d_idx를 사용한다. 영역을 구해야할 필요가 없다면 안써도 된다. int s_idx = 0; int e_idx = 0; int max_s_idx = 0; int max_e_idx = 0; 계산 입력을 받으면서 즉시 계산한다. for(int i = 0; i&lt;size; i++){ int t; scanf(&quot;%d&quot;, &amp;t); if(t &lt; cur_max_sum + t){ cur_max_sum = cur_max_sum + t; } else { cur_max_sum = t; } if(cur_max_sum &gt; max_sum){ max_sum = cur_max_sum; } } 영역을 구해야 할 경우엔 다음과 같이 영역 변수의 값을 갱신한다. for(int i = 0; i&lt;size; i++){ int t; scanf(&quot;%d&quot;, &amp;t); if(t &lt; cur_max_sum + t){ //이전 item부터의 합이 연속됨 cur_max_sum = cur_max_sum + t; e_idx = i; } else { //현재 item이 시작 cur_max_sum = t; s_idx = i; e_idx = i; } if(cur_max_sum &gt; max_sum){ //최대값 갱신 max_sum = cur_max_sum; max_s_idx = s_idx; max_e_idx = e_idx; } } code #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int kadane(vector&lt;int&gt; &amp;In){ int max_sum = -987654321; int cur_max_sum = -987654321; int s_idx = 0; int e_idx = 0; int max_s_idx = 0; int max_e_idx = 0; int size = (int)In.size(); for(int i = 0; i&lt;size; i++){ if(In[i] &lt; cur_max_sum + In[i]){ //이전 item부터의 합이 연속됨 cur_max_sum = cur_max_sum + In[i]; e_idx = i; } else { //현재 item이 시작 cur_max_sum = In[i]; s_idx = i; e_idx = i; } if(cur_max_sum &gt; max_sum){ //최대값 갱신 max_sum = cur_max_sum; max_s_idx = s_idx; max_e_idx = e_idx; } } return max_sum; } int main(){ int N; scanf(&quot;%d&quot;, &amp;N); vector&lt;int&gt; In(N); for(int i = 0; i&lt;N; i++){ scanf(&quot;%d&quot;, &amp;In[i]); } int max_sum = -987654321; int cur_max_sum = -987654321; int s_idx = 0; int e_idx = 0; int max_s_idx = 0; int max_e_idx = 0; int size = (int)In.size(); for(int i = 0; i&lt;size; i++){ if(In[i] &lt; cur_max_sum + In[i]){ //이전 item부터의 합이 연속됨 cur_max_sum = cur_max_sum + In[i]; e_idx = i; } else { //현재 item이 시작 cur_max_sum = In[i]; s_idx = i; e_idx = i; } if(cur_max_sum &gt; max_sum){ //최대값 갱신 max_sum = cur_max_sum; max_s_idx = s_idx; max_e_idx = e_idx; } } printf(&quot;%d from %d to %d&quot;, max_sum, max_s_idx, max_e_idx); return 0; } 참고 위키피디아의 알고리즘 설명을 참고하자 실전 문제들 연속합 Kadane 알고리즘을 알고 있는지 묻는 문제 최대 100000개의 입력이 들어오므로 O(n)알고리즘을 이용해야 한다. 영역을 필요없으므로 영역 변수는 제외한다.",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html",
    "relUrl": "/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html"
  },
  "22": {
    "id": "22",
    "title": "Data Structure - hash table",
    "content": "아주 간단히 구현한 C++ Hash table. 물론 unordered_multimap을 쓰는 것이 편하지만 hash table의 구조에 대해 이해하기 위해 구현해 보았다. 구조 Hash table의 entry는 key와 value로 구성되고, key는 주로 string이 많이 쓰이고, value는 다양하다. 코딩이 용이하도록 class가 아닌 struct로 하되 constructor는 추가해 놓았다. struct Item{ string key; int val; Item(string p_key, int p_val){ key = p_key; val = p_val; }; }; hash function은 key값을 받아서 각 char의 ascii값을 더해서 전체 entry 숫자로 나눈 나머지를 index로써 반환하도록 구현했다. int hash(string key){ int sum = 0; for(auto &amp;it : key){ sum += it; } return sum % entryNum; }; Hash table의 구조는 Separate Chaining이다. 각 Entry마다 linkedlist가 있어서 collision없이 아이템을 쉽게 제거, 추가할 수 있지만, worsecase O(n)인 구조이다. vector&lt;list&lt;Item&gt; &gt; HT; 초기화시에 entry의 숫자를 정하는데 2, 4, 6, 8의 배수로 할 경우 중복의 가능성이 커서 소수로 정하는 것이 좋다. 그리고 이때 반드시 vector는 초기화 해야 한다. HashTable(int num){ if(num &lt;= 0) num = 17; entryNum = num; HT.resize(num); } code #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;string&gt; using namespace std; struct Item{ string key; int val; Item(string p_key, int p_val){ key = p_key; val = p_val; }; }; class HashTable { private: int entryNum; vector&lt;list&lt;Item&gt; &gt; HT; int hash(string key){ int sum = 0; for(auto &amp;it : key){ sum += it; } return sum % entryNum; }; public: HashTable(int num){ if(num &lt;= 0) num = 17; entryNum = num; HT.resize(num); } void addItem(string key, int value){ int index = hash(key); HT[index].push_back(Item(key, value)); } void removeItem(string key){ int index = hash(key); for(auto it = HT[index].begin(); it!= HT[index].end(); it++){ if((*it).key == key){ HT[index].erase(it); return; } } } bool lookup(string key, int &amp;value){ int index = hash(key); for(auto it = HT[index].begin(); it!= HT[index].end(); it++){ if((*it).key == key){ value = (*it).val; return true; } } return false; } void print(){ int index = 0; for(auto it = HT.begin(); it!= HT.end(); it++){ cout &lt;&lt; &quot;INDEX: &quot; &lt;&lt; index++ &lt;&lt; &quot; || &quot;; for(auto lt = (*it).begin(); lt != (*it).end(); lt++){ cout &lt;&lt; &quot;(&quot; &lt;&lt; (*lt).key &lt;&lt; &quot;,&quot; &lt;&lt; (*lt).val &lt;&lt; &quot;) &quot;; } cout &lt;&lt; endl; } } }; int main() { HashTable table(11); table.addItem(&quot;AAA&quot;, 10); table.addItem(&quot;BBB&quot;, 20); table.addItem(&quot;CCC&quot;, 30); table.addItem(&quot;DDD&quot;, 40); table.addItem(&quot;EEE&quot;, 50); table.addItem(&quot;FFF&quot;, 60); table.addItem(&quot;AAB&quot;, 10); table.addItem(&quot;BBC&quot;, 20); table.addItem(&quot;CCD&quot;, 30); table.addItem(&quot;DDE&quot;, 40); table.addItem(&quot;EEF&quot;, 50); table.addItem(&quot;FFA&quot;, 60); table.addItem(&quot;BAB&quot;, 10); table.addItem(&quot;CBC&quot;, 20); table.addItem(&quot;DCD&quot;, 30); table.addItem(&quot;EDE&quot;, 40); table.addItem(&quot;FEF&quot;, 50); table.addItem(&quot;AFA&quot;, 60); int val; if(table.lookup(&quot;EEE&quot;, val)){ cout &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;NOT FOUND&quot; &lt;&lt; endl; } table.removeItem(&quot;EEE&quot;); if(table.lookup(&quot;EEE&quot;, val)){ cout &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;NOT FOUND&quot; &lt;&lt; endl; } table.print(); return 0; } 참고 vector와 list를 사용하지 않은 좀 더 순수(?)한 구현은 보고 싶다면 여기를 참조하자.",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html",
    "relUrl": "/docs/codingInterview/2016-02-13-data-structure-hash-table.html"
  },
  "23": {
    "id": "23",
    "title": "Data Structure - binary search tree",
    "content": "직접 구현해 본 binary search tree. iterative binary tree travasal에 익숙해져야 한다. 구조 tree를 design할때 가장 먼저 고민할 것은 tree를 구성하는 Node의 정의이다. 입력 데이터는 key와 value 조합으로 했으며, 삽입, 검색, 삭제의 기준은 key로 했다. array가 아닌 pointer로 tree를 구성하고자 다음과 같이 Node를 정의했다. 구현을 용이하게 하기 위해 constructor를 담은 struct로 정의했다. struct Node { int key; int value; Node *l_child; Node *r_child; Node(int k, int val){ key = k; value = val; l_child = NULL; r_child = NULL; }; }; public interface인 함수 프로토타입은 다음과 같이 선언했다. class BST{ public: BST(); //자료구조(root) 초기화 ~BST(); //할당된 resource 모두 해제 void insertItem(int key, int value); //item 삽입 void removeItem(int key); //item 삭제 bool findItem(int key, int &amp;value); //item을 key로 검색해서 value를 획득. 없으면 false를 리턴 void print(); //tree의 모든 아이템을 inorder로 출력 }; 위의 프로토타입을 뒷바침하기 위한 private 멤버는 다음과 같이 도출했다. class BST{ private: Node *root; void removeTree(Node *r); //root r인 tree에 할당된 resource를 모두 해제 pair&lt;int, int&gt; getBiggest(Node **r); //root r인 tree 중 가장 큰 key를 가진 Node를 삭제하고 그 key와 value를 반환 pair&lt;int, int&gt; getSmallest(Node **r); //root r인 tree 중 가장 작은 key를 가진 Node를 삭제하고 그 key와 value를 반환 void printInorder(Node *r); ///root r인 tree를 inorder로 순회하며 출력 }; getBiggest와 getSmallest의 경우 root가 삭제되면 NULL로 root가 변경되어야 하므로 더블포인터를 파라미터로 사용한다. binary tree의 iterative search는 기본적으로 아래와 같은 방식으로 한다. bool find(int k, int &amp;val){ Node *tmp = root; while(tmp != NULL){ if(tmp-&gt;key == k){ val = tmp-&gt;value; return true; } if(tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } return false; } 삽입이나 삭제를 위해서는 Parent Node를 기억하고 있어야 하므로 조금 변형이 필요하다. root node는 parent가 없는 node이므로 먼저 확인을 한다. tmp를 이동시키기 전에 parent를 가리키는 pointer로 tmp를 가리키게 하면 간단히 parent를 저장할 수 있다. void insert(int k, int val){ if(root == NULL){ root = new Node(k, val); return; } Node *tmp = root; Node *p = tmp; while(tmp!= NULL){ p = tmp; if(tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } if(p-&gt;key &gt; k) { p-&gt;l_child = new Node(k, val); } else { p-&gt;r_child = new Node(k, val); } } tree의 resource해제나 print는 간단히 recursion을 이용해서 한다. void removeTree(Node *tmp){ if(tmp == NULL) return; if(tmp-&gt;l_child) removeTree(tmp-&gt;l_child); if(tmp-&gt;r_child) removeTree(tmp-&gt;r_child); delete tmp; } void printInorder(Node *r){ if(r == NULL) return; if(r-&gt;l_child) printInorder(r-&gt;l_child); cout &lt;&lt; r-&gt;key &lt;&lt; &quot;, &quot; &lt;&lt; r-&gt;value ; if(r-&gt;r_child) printInorder(r-&gt;r_child); } code #include &lt;iostream&gt; using namespace std; struct Node { int key; int value; Node *l_child; Node *r_child; Node(int k, int val){ key = k; value = val; l_child = NULL; r_child = NULL; }; }; class BST { private: Node *root; void removeTree(Node *tmp){ if(tmp == NULL) return; if(tmp-&gt;l_child) removeTree(tmp-&gt;l_child); if(tmp-&gt;r_child) removeTree(tmp-&gt;r_child); delete tmp; } pair&lt;int, int&gt; getBiggest(Node **r){ //root의 pointer를 NULL로 변경할 수 있도록 이중 pointer로 입력받음 Node *tmp = *r; Node *p = *r; while(tmp-&gt;r_child != NULL){ //r_child가 없을때까지 이동 p = tmp; tmp = tmp-&gt;r_child; } pair&lt;int, int&gt; ret(tmp-&gt;key, tmp-&gt;value); if(tmp-&gt;l_child){ //만약 l_child가 있을 경우 l_child tree의 가장 큰 아이템으로 대체 pair&lt;int, int&gt; t = getBiggest(&amp;(tmp-&gt;l_child)); tmp-&gt;key = t.first; tmp-&gt;value = t.second; } else { //l_child와 r_child가 모두 없는 node는 그 node를 가리키는 포인터를 NULL로! if(tmp != p){ //tree의 root가 아닌 경우 p-&gt;r_child = NULL; } else { //root인 경우 *r = NULL; //!!!! } delete(tmp); } return ret; } pair&lt;int, int&gt; getSmallest(Node **r){ //root의 pointer를 NULL로 변경할 수 있도록 이중 pointer로 입력 받음 Node *tmp = *r; Node *p = *r; while(tmp-&gt;l_child != NULL){ //l_child가 없을때까지 이동 p = tmp; tmp = tmp-&gt;l_child; } pair&lt;int, int&gt; ret(tmp-&gt;key, tmp-&gt;value); if(tmp-&gt;r_child){ pair&lt;int, int&gt; t = getSmallest(&amp;(tmp-&gt;r_child)); tmp-&gt;key = t.first; tmp-&gt;value = t.second; } else { if(tmp != p){ p-&gt;l_child = NULL; } else { *r = NULL; //root인 경우 NULL로 변경 } delete(tmp); } return ret; } void printInorder(Node *r){ if(r == NULL) return; if(r-&gt;l_child) printInorder(r-&gt;l_child); cout &lt;&lt; &quot;(&quot; &lt;&lt; r-&gt;key &lt;&lt; &quot;, &quot; &lt;&lt; r-&gt;value &lt;&lt; &quot;) &quot;; if(r-&gt;r_child) printInorder(r-&gt;r_child); } public: BST(){ root = NULL; } virtual ~BST(){ removeTree(root); } void insertItem(int k, int val){ if(root == NULL){ root = new Node(k, val); return; } Node *tmp = root; Node *p = tmp; while(tmp!= NULL){ p = tmp; if(tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } if(p-&gt;key &gt; k) { p-&gt;l_child = new Node(k, val); } else { p-&gt;r_child = new Node(k, val); } } bool findItem(int k, int &amp;val){ Node *tmp = root; while(tmp != NULL){ if(tmp-&gt;key == k){ val = tmp-&gt;value; return true; } if(tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } return false; } void removeItem(int k){ if(root == NULL) return; //빈 tree Node *tmp = root; Node *p = tmp; while(tmp != NULL){ if(tmp-&gt;key == k){ if(tmp-&gt;r_child){ //r_child가 있는 경우 r_child tree의 가장 작은 item으로 Node를 대체 pair&lt;int, int&gt; t= getSmallest(&amp;(tmp-&gt;r_child)); tmp-&gt;key = t.first; tmp-&gt;value = t.second; } else if (tmp-&gt;l_child){ //r_child가 없고 l_child만 있는 경우 l_child의 가장 큰 item으로 Node를 대체 pair&lt;int, int&gt; t= getBiggest(&amp;(tmp-&gt;l_child)); tmp-&gt;key = t.first; tmp-&gt;value = t.second; } else { //leaf node인 경우 그냥 지운다. 이때 그 node를 가리키던 pointer를 NULL로 만든다. if(tmp == root){ //root일 경우 root = NULL; } else { if(p-&gt;key &gt; k){ p-&gt;l_child = NULL; } else { p-&gt;r_child = NULL; } } delete tmp; } return; } p = tmp; if(tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } } void print(){ cout &lt;&lt; endl; printInorder(root); cout &lt;&lt; endl; } }; int main(){ BST b; b.insertItem(10, 100); b.insertItem(1, 200); b.insertItem(5, 300); b.insertItem(7, 100); b.insertItem(20, 400); b.insertItem(15, 500); b.insertItem(17, 600); b.insertItem(0, 700); b.print(); int val; //remove middle node if(b.findItem(5, val)) cout &lt;&lt; &quot;Key 5 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 5 : Not found&quot; &lt;&lt;endl; b.removeItem(5); if(b.findItem(5, val)) cout &lt;&lt; &quot;Key 5 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 5 : Not found&quot; &lt;&lt;endl; b.print(); //remove leaf node if(b.findItem(0, val)) cout &lt;&lt; &quot;Key 0 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 0 : Not found&quot; &lt;&lt;endl; b.removeItem(0); if(b.findItem(0, val)) cout &lt;&lt; &quot;Key 0 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 0 : Not found&quot; &lt;&lt;endl; b.print(); //remove root node if(b.findItem(10, val)) cout &lt;&lt; &quot;Key 10 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 10 : Not found&quot; &lt;&lt;endl; b.removeItem(10); if(b.findItem(10, val)) cout &lt;&lt; &quot;Key 10 : &quot;&lt;&lt; val &lt;&lt; endl; else cout &lt;&lt; &quot;Key 10 : Not found&quot; &lt;&lt;endl; b.print(); return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html",
    "relUrl": "/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html"
  },
  "24": {
    "id": "24",
    "title": "Algorithm - binary tree 및 binary search tree 문제들",
    "content": "Binary Tree와 Binary Search Tree에 관한 문제들은 recursion에 대한 이해가 있어야만 풀 수 있다. 그 문제들, 접근법, 해법을 간단히 살펴본다. Binary Tree 문제와 해법들 Binary Tree의 크기 구하기 Binary tree의 크기는 구성하는 노드의 숫자를 말한다. 간단히 Node의 왼쪽 자식이 구성하는 트리의 노드 숫자와 오른쪽 자식이 구성하는 노드 숫자, 그리고 자기 자신을 더해서 반환하면 된다. 물론 NULL check를 잊으면 안된다. int size(Node *r){ if (r == NULL) return 0; return size(r-&gt;l_child) + size(r-&gt;r_child) + 1; } Binary Tree 최대 깊이 구하기 Binary tree의 최대 depth는 자신이 NULL이면 0, 아니면 왼쪽 자식 트리의 최대 depth와 오른쪽 자식 트리의 최대 depth중 큰 것을 택하고 거기에 자신의 깊이 1을 더한 것이다. int maxDepth(Node *r){ if (r == NULL) return 0; int l_depth = maxDepth(r-&gt;l_child); int r_depth = maxDepth(r-&gt;r_child); return max(l_depth, r_depth) + 1; } Binary Tree의 최대 직경 구하기 Binary tree의 최대 직경은 가장 멀리 떨어져 있는 노드의 거리(edge 수)를 말한다. 주의할 것은 root 노드가 포함되지 않는 최대 직경도 가능하다는 것이다. 하지만 높이는 관련이 깊다. 한 노드에서 자신의 왼쪽 자식 트리의 최대 깊이와 오른쪽 자식 트리의 최대 깊이를 더한 것이 그 노드가 구성하는 트리의 직경이 된다. 각 노드 마다 직경을 구해서 그것 중 가장 큰 것을 택하면 트리의 최대 직경이 된다. int m_dia; int maxDiameter(Node *r){ if(r == NULL) return 0; int l_depth = maxDiameter(r-&gt;l_child); //max depth of l_child tree int r_depth = maxDiameter(r-&gt;r_child); //max depth of r_child tree if(m_dia &lt; l_depth + r_depth) //l_depth + r_depth : diameter of this node m_dia = l_depth + r_depth; //update the max diameter return max(l_depth, r_depth) + 1; //max depth at this node } int main(){ m_dia = 0; int maxDiameter(root); cout &lt;&lt; m_dia; //최대 직경 return 0; } Binary Tree의 root부터 모든 leaf 노드까지의 경로 출력하기 함수의 파라미터로 vector와 depth를 넘겨주고 leaf 노드에 도달하면 0부터 depth까지 출력하게 한다. leaf 노드는 왼쪽 오른쪽 자식이 없고 NULL이 아닌 노드이다. void printPath(Node *r, vector&lt;int&gt; &amp;T, int len){ T[len] = r-&gt;key; if (!r-&gt;l_child &amp;&amp; !r-&gt;r_child){ for (int i = 0; i &lt;= len; i++) cout &lt;&lt; T[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return; } if (r-&gt;l_child) printPath(r-&gt;l_child, T, len+1); if (r-&gt;r_child) printPath(r-&gt;r_child, T, len+1); }; Binary Tree의 모든 노드 제거 마치 post order 순회처럼 하면 된다. void removeTree(Node *tmp){ if (tmp == NULL) return; if (tmp-&gt;l_child) removeTree(tmp-&gt;l_child); if (tmp-&gt;r_child) removeTree(tmp-&gt;r_child); delete tmp; } Binary Search Tree의 문제와 해법 isBST 문제 Binary Tree가 BST인지 확인하는 문제이다. 5가지 경우를 처리하면 된다. 노드가 NULL : BST 속성을 해치지 않는다. 노드의 자식 노드가 모두 없음 : BST 속성을 해치지 않는다. 노드의 오른쪽 자식이 있고 왼쪽 자식이 없음: 왼쪽 자식에 대한 속성(왼쪽 자식보다 노드의 값이 더 커야 한다. 그리고 자식 트리도 그 속성을 만족해야 한다.)을 유지하는 지 확인해야 한다. 노드의 왼쪽 자식이 있고 오른쪽 자식이 없음: 오른쪽 자식에 대한 속성(오른쪽 자식보다 노드의 값이 더 작아야 하고 자식 트리도 만족해야 한다.)을 유지하는 지 확인해야 한다. 노드의 양 자식이 모두 존재: 두 자식에 대한 속성을 모두 확인해야 한다. 그리고 양 자식 트리도 그 속성을 만족해야 한다. bool isbst(Node *r){ if (r == NULL) return true; if (r-&gt;l_child &amp;&amp; r-&gt;r_child){ if (r-&gt;l_child-&gt;key &gt;= r-&gt;key || r-&gt;r_child-&gt;key &lt;= r-&gt;key) return false; return isbst(r-&gt;l_child) &amp;&amp; isbst(r-&gt;r_child); } else if (r-&gt;l_child){ if (r-&gt;l_child-&gt;key &gt;= r-&gt;key) return false; return isbst(r-&gt;l_child); } else if (r-&gt;r_child){ if (r-&gt;r_child-&gt;key &lt;= r-&gt;key) return false; return isbst(r-&gt;r_child); } return true; } Binary Search Tree의 최대, 최소 노드 찾기 BST 속성상 가장 작은 노드는 왼쪽 끝에 위치하고 가장 큰 노드는 오른쪽 끝에 위치한다. int minVal(){ if (!root) return -1; //empty Node *temp = root; Node *p = root; while (temp != NULL){ p = temp; temp = temp-&gt;l_child; } return p-&gt;key; } int maxVal(){ if (!root) return -1; //empty Node *temp = root; Node *p = root; while (temp != NULL){ p = temp; temp = temp-&gt;r_child; } return p-&gt;key; } 코드 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; struct Node { int key; int value; Node *l_child; Node *r_child; Node(int k, int val){ key = k; value = val; l_child = NULL; r_child = NULL; }; }; class BST { private: Node *root; void removeTree(Node *tmp){ if (tmp == NULL) return; if (tmp-&gt;l_child) removeTree(tmp-&gt;l_child); if (tmp-&gt;r_child) removeTree(tmp-&gt;r_child); delete tmp; } bool isbst(Node *r){ if (r == NULL) return true; if (r-&gt;l_child &amp;&amp; r-&gt;r_child){ if (r-&gt;l_child-&gt;key &gt;= r-&gt;key || r-&gt;r_child-&gt;key &lt;= r-&gt;key) return false; return isbst(r-&gt;l_child) &amp;&amp; isbst(r-&gt;r_child); } else if (r-&gt;l_child){ if (r-&gt;l_child-&gt;key &gt;= r-&gt;key) return false; return isbst(r-&gt;l_child); } else if (r-&gt;r_child){ if (r-&gt;r_child-&gt;key &lt;= r-&gt;key) return false; return isbst(r-&gt;r_child); } return true; } int size(Node *r){ if (r == NULL) return 0; return size(r-&gt;l_child) + size(r-&gt;r_child) + 1; } int maxDepth(Node *r){ if (r == NULL) return 0; int l_depth = maxDepth(r-&gt;l_child); int r_depth = maxDepth(r-&gt;r_child); return max(l_depth, r_depth) + 1; } void printPath(Node *r, vector&lt;int&gt; &amp;T, int len){ T[len] = r-&gt;key; if (!r-&gt;l_child &amp;&amp; !r-&gt;r_child){ for (int i = 0; i &lt;= len; i++) cout &lt;&lt; T[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return; } if (r-&gt;l_child) printPath(r-&gt;l_child, T, len+1); if (r-&gt;r_child) printPath(r-&gt;r_child, T, len+1); }; int m_dia; int maxDiameter(Node *r){ if(r == NULL) return 0; int l_depth = maxDiameter(r-&gt;l_child); //max depth of l_child tree int r_depth = maxDiameter(r-&gt;r_child); //max depth of r_child tree if(m_dia &lt; l_depth + r_depth) //l_depth + r_depth : diameter of this node m_dia = l_depth + r_depth; //update the max diameter return max(l_depth, r_depth) + 1; //max depth at this node } void inorder_traversal(Node *r, vector&lt;int&gt; &amp;T){ if(r == NULL) return; inorder_traversal(r-&gt;l_child, T); T.push_back(r-&gt;key); inorder_traversal(r-&gt;r_child, T); } void postorder_traversal(Node *r, vector&lt;int&gt; &amp;T){ if(r == NULL) return; postorder_traversal(r-&gt;l_child, T); postorder_traversal(r-&gt;r_child, T); T.push_back(r-&gt;key); } public: BST(){ root = NULL; } virtual ~BST(){ removeTree(root); } void insertItem(int k, int val){ if (root == NULL){ root = new Node(k, val); return; } Node *tmp = root; Node *p = tmp; while (tmp != NULL){ p = tmp; if (tmp-&gt;key &gt; k){ tmp = tmp-&gt;l_child; } else { tmp = tmp-&gt;r_child; } } if (p-&gt;key &gt; k) { p-&gt;l_child = new Node(k, val); } else { p-&gt;r_child = new Node(k, val); } } bool isBST(){ return isbst(root); } int size(){ return size(root); } int maxDepth(){ return maxDepth(root); } int minVal(){ if (!root) return -1; //empty Node *temp = root; Node *p = root; while (temp != NULL){ p = temp; temp = temp-&gt;l_child; } return p-&gt;key; } int maxVal(){ if (!root) return -1; //empty Node *temp = root; Node *p = root; while (temp != NULL){ p = temp; temp = temp-&gt;r_child; } return p-&gt;key; } void printAllPath(){ vector&lt;int&gt; T(100, 0); int len = 0; printPath(root, T, len); } int maxDiameter(){ m_dia = 0; maxDiameter(root); return m_dia; } int findTheLowestCommonAncenstor(int keyA, int keyB){ //in-order traversal의 속성으로 keyA부터 key B까지의 영역이 하나의 subtree의 일부분 vector&lt;int&gt; I; inorder_traversal(root, I); //post-order traversal의 속성으로 한 subtree의 root는 맨 뒤에 위치 vector&lt;int&gt; P; postorder_traversal(root, P); //keyA와 keyB 영역을 in-order 결과에서 찾는다. index를 찾고 작은 것을 앞으로 위치 시킴 int first_index = -1; int last_index = -1; for(int i = 0; i&lt;I.size(); i++){ if(I[i] == keyA) first_index = i; if(I[i] == keyB) last_index = i; } if(first_index &gt; last_index){ int tmp = first_index; first_index = last_index; last_index = tmp; } //in-order의 keyA와 keyB의 아이템 중 post-order로 순회된 아이템 중 가장 뒤의 것을 찾는다. int last_mark = -1; for(int i = first_index; i&lt;= last_index; i++){ for(int j = 0; j&lt;P.size(); j++){ if(P[j] == I[i]){ if(last_mark &lt; j){ last_mark = j; } } } } return P[last_mark]; //post-order로 찾은 것중 마지막 것이 root } }; int main(){ BST b; b.insertItem(10, 100); b.insertItem(1, 200); b.insertItem(5, 300); b.insertItem(7, 100); b.insertItem(20, 400); b.insertItem(15, 500); b.insertItem(17, 600); b.insertItem(0, 700); /* 10 1 20 0 5 15 7 17 */ /* check if the tree is a BST */ if (b.isBST()) cout &lt;&lt; &quot;BST&quot; &lt;&lt; endl; //must be &quot;BST&quot; else cout &lt;&lt; &quot;NOT BST&quot; &lt;&lt; endl; /* get the size of binary tree */ cout &lt;&lt; b.size() &lt;&lt; endl; // must be 8 /* get the maximum depth of binary tree*/ cout &lt;&lt; b.maxDepth() &lt;&lt; endl; //msut be 4 /* get the min &amp; max value of binary search tree */ cout &lt;&lt; b.minVal() &lt;&lt; endl; //must be 0 cout &lt;&lt; b.maxVal() &lt;&lt; endl; //must be 20 /* print all the possible paths in a binary tree*/ b.printAllPath(); //must be 10 1 0, 10 1 5 7, 10 20 15 17 /* find the max diameter of the binary tree */ cout &lt;&lt; b.maxDiameter() &lt;&lt; endl; //must be 6 (num of edges) /* Find the lowest common ancestor from two nodes in binary tree */ cout &lt;&lt; b.findTheLowestCommonAncenstor(7, 0) &lt;&lt; endl; //must be 1 cout &lt;&lt; b.findTheLowestCommonAncenstor(17, 1) &lt;&lt; endl; //must be 10 cout &lt;&lt; b.findTheLowestCommonAncenstor(10, 17) &lt;&lt; endl; //must be 10 return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html",
    "relUrl": "/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html"
  },
  "25": {
    "id": "25",
    "title": "Algorithm - k번째 큰(작은) 아이템 찾기",
    "content": "정렬이 되어 있지 않은 배열에서 k번째로 작은 알고리즘을 찾는 방법을 생각해보자. 예를 들어 다음의 vector에서 3번째로 작은 값은 3이다. vector&lt;int&gt; T = { 3, 1, 6, 4, 2, 7, 8, 10, 5, 8, 9 }; 몇가지 접근법 Selection Sort Selection Sort는 다음의 알고리즘으로 수행되는 아주 간단한 정렬이다. 주어진 배열 중에 최솟값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)). 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다. 위를 k번 반복하면 된다. 그런데 이 알고리즘은 O(N*k)성능으로 k가 큰 경우 성능이 나쁘다. Quick Sort 전체 배열을 O(NlogN)알고리즘인 Quick Sort로 정렬한 뒤 k번째를 찾는 것이다. k에 따라서 Selection Sort를 이용하는 것보다 성능이 좋을 수 있으나 불필요하게 모든 배열을 정렬하게 된다. Quick Sort의 변형 Quick Sort의 partition 함수는 pivot을 반환하게 된다. pivot index를 기준으로 더 작은 것과 큰 것으로 나뉘게 되는데 이 성질을 이용하여 k번째를 구할 수 있다. pivot이 k와 같으면, 즉, pivot이 k번째 index이면 pivot에 해당하는 값을 반환 pivot이 k보다 작으면 k는 pivot 이후에 있는 것 pivot이 k보다 크면 k는 pivot이전에 있는 것 코드 Quick Sort를 변형하여 k번째 값을 찾는 코드는 다음과 같다. Partition함수는 기존의 Quick Sort와 동일하고, Partition함수를 통해 얻은 pivot을 처리하는 것은 위에서 설명한 바와 같다. #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void swap(vector&lt;int&gt; &amp;T, int a, int b){ int temp = T[a]; T[a] = T[b]; T[b] = temp; } int partition(vector&lt;int&gt; &amp;T, int low, int high){ int index = low; for (int i = low; i&lt;high; i++){ if (T[i] &lt;= T[high]){ swap(T, i, index); index++; } } swap(T, index, high); return index; } /* Quick Sort를 변형 */ int findKth(vector&lt;int&gt; &amp;T, int k, int low, int high){ int pivot = partition(T, low, high); int ret; if (pivot == k){ ret = T[pivot]; } else if (pivot &lt; k) { ret = findKth(T, k, pivot + 1, high); } else { ret = findKth(T, k, low, pivot - 1); } return ret; } int main(){ vector&lt;int&gt; T = { 3, 1, 6, 4, 2, 7, 8, 10, 5, 8, 9 }; int k = 3; /* 배열 index는 0부터 시작하므로 k를 1을 줄여서 findKth를 호출한다.*/ cout &lt;&lt; findKth(T, k - 1, 0, 9) &lt;&lt; endl; //must be 3 return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html",
    "relUrl": "/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html"
  },
  "26": {
    "id": "26",
    "title": "Algorithm - merge sort",
    "content": "merge sort는 O(nlogn) 성능을 가진 대표적인 Divide &amp; Conquer 패러다임 알고리즘이다. 그 구현에 대해 살펴보자. 알고리즘 merge sort 알고리즘은 다음과 같다. divide &amp; conquer 패러다임을 따르기 때문에 quick sort와 매우 유사하다. pivot을 얻어오는 partition 함수가 없고 대신 middle을 구하고, 맨 마지막에 merge하는 함수가 있다는 점이 다르다. 알고리즘은 다음과 같다. 입력 배열을 왼쪽/오른쪽으로 반 나눈다. recursive하게 왼쪽과 오른쪽을 호출한다. 왼쪽과 오른쪽을 합친다. 잘 합치기 위해서 low, middle, high 인덱스가 필요하다. merge_sort(Array, low, high) { if(low &gt;= high) return; middle = (low + high)/2; merge_sort(Array, low, middle); merge_sort(Array, middle+1, high); merge(Array, low, middle, high); } 주어진 배열의 정렬을 위해서는 다음과 같이 호출한다. merge_sort(Array, 0, Array.size()-1); quick sort의 핵심이 partition함수라면 merge sort의 핵심은 merge알고리즘이다. 그 내용은 매우 단순하다. merge함수로 들어오는 배열은 middle을 중심으로 왼쪽 오른쪽이 각각 정렬되어 있는 것이다. 두개의 임시 배열을 만들어 왼쪽과 오른쪽 값을 복사해두고, 값을 비교하며 원래 배열에 하나씩 집어 넣는다. 이때 임시 배열 마지막에는 무한대 값을 두어 비교 시 길이 비교를 하지 않도록 하는 트릭을 쓴다. merge(Array, low, middle, high) { l_len = middle - low + 1; r_len = high - middle; create array L[l_len + 1] and array R[r_len + 1] //마지막에 무한대를 넣기 위해 추가 for(i = 0; i&lt; l_len; i++) L[i] = A[low+i] for(i = 0; i&lt; r_len; i++) R[i] = A[middle + 1 + i] L[l_len] = 무한대 //L 배열의 길이를 넘어가는 것을 비교하지 않기 위해 R[r_len] = 무한대 //R 배열의 길이를 넘어가는 것을 비교하지 않기 위해 i = 0, j = 0 for(k = low; k &lt;= high; k++){ if(L[i] &lt;= R[j]) { A[k] = L[i] i++ } else { A[k] = R[j] j++; } } } 코드 #include &lt;vector&gt; #include &lt;limits&gt; #include &lt;iostream&gt; using namespace std; void merge(vector&lt;int&gt; &amp;T, int low, int middle, int high){ int l_len = middle - low + 1; int r_len = high - middle; vector&lt;int&gt; L(l_len + 1); vector&lt;int&gt; R(r_len + 1); for (int i = 0; i&lt;l_len; i++){ L[i] = T[low + i]; } for (int i = 0; i&lt;r_len; i++){ R[i] = T[middle + 1 + i]; } L[l_len] = R[r_len] = numeric_limits&lt;int&gt;::max(); int i = 0; int j = 0; for (int k = low; k &lt;= high; k++){ if (L[i] &gt; R[j]) { T[k] = R[j++]; } else { T[k] = L[i++]; } } } void merge_sort(vector&lt;int&gt; &amp;T, int low, int high){ if (low &gt;= high) return; int middle = (low + high) / 2; merge_sort(T, low, middle); merge_sort(T, middle + 1, high); merge(T, low, middle, high); } int main(){ vector&lt;int&gt; T = { 4, 1, 2, 7, 8, 5, 9, 3, 6, 10 }; merge_sort(T, 0, 9); for (int i = 0; i&lt;T.size(); i++){ cout &lt;&lt; T[i] &lt;&lt; &quot; &quot;; //must be &quot;1 2 3 4 5 6 7 8 9 10&quot; } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html",
    "relUrl": "/docs/codingInterview/2016-02-22-algorithm-merge-sort.html"
  },
  "27": {
    "id": "27",
    "title": "Algorithm - Topological Sort",
    "content": "Topological Sort는 dependency를 가진 것들을 처리할 때 어떤 순서로 처리해야 하는지를 알아내기 위한 그래프 알고리즘이다. 예를 들어, a -&gt; b, b -&gt; c, a -&gt; c라는 의존 관계가 있다면 a -&gt; b -&gt; c라는 순서로 처리되어야만 한다. 보통 의존성이 있는 작업들이 있을 때 순서를 구하거나, 소프트웨어의 각 모듈간 의존성을 고려한 설치 순서등을 정할 때 사용된다. 알고리즘 Topological sort는 의존성을 가진 것들의 처리 순서를 다루는 것이므로 방향성 그래프에 적용된다. 다음과 같은 어프로치를 활용한다. 다른 vertex들이 의존하지 않는 vertex부터 하나 씩 지워나간다. 예를 들어 a -&gt; b, b -&gt; c, a -&gt; c라는 의존 관계에서 c를 지우고, b를 지우고, a를 지우는 식으로 진행하는 것이다. 이 어프로치를 구현하기 위한 알고리즘은 다음과 같다. 그래프내의 모든 vertex들을 방문할 때까지 DFS로 vertex를 순회한다. 한 vertex를 기준으로 볼 때 자신의 adjacent vertex들을 모두 방문하거나, 혹은 adjacent vertex가 없어서 더 이상 자신에게 의존하는 vertex가 남아 있지 않으면 이때 자신을 스택에 넣는다. 모든 vertex를 방문했다면 스택에서 하나씩 pop을 한다. pop된 아이템들의 순서가 바로 topological_sort된 순서이다. 간단히 pseudo 코드로 표현하면 다음과 같다. dfs(graph, vertex id, visited[], stack){ 해당 vertex를 방문한 것으로 check 모든 인접 vertex를 순회하며 { if(인접 vertext가 방문한 적이 없다면){ dfs(graph, 인접 vertex의 id, visited, stack); } } stack에 vertex를 푸쉬한다. } topological_sort(graph){ 자료 구조 초기화: graph, visited[], stack graph내의 모든 vertex에 대해 { dfs(graph, vertex id, visited, stack) 방문한 vertex 숫자가 graph의 vertex 숫자와 일치하면 loop을 멈춤 } stack에서 하나씩 push하면서 출력한다. } 코드 위의 pseudo code를 실제 코드로 작성한 것은 다음과 같다. set 자료 구조를 사용해 visited 여부를 체크하고, vector를 stack로 사용했다. #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std; void dfs(vector&lt;vector&lt;bool&gt; &gt; &amp;G, int index, set&lt;int&gt; &amp;Visited, vector&lt;int&gt; &amp;Stack){ Visited.insert(index); //방문한 것으로 Check for (int i = 0; i&lt;G.size(); i++){ if (i == index) continue; //자기 자신은 Skip if (G[index][i]){ //연결된 Vertex가 있다면 (edge가 true) auto it = Visited.find(i); if (it == Visited.end()){ //방문했던 Vertex인지 확인해서 하지 않았다면 dfs(G, i, Visited, Stack); //방문한다. } } } Stack.push_back(index); //더 이상 방문할 것이 없다면 V에 넣는다.(즉, 자신에게 의존적인 Vertex들을 모두 처리한 후에 자신을 처리) } vector&lt;int&gt; topological_sort(vector&lt;vector&lt;bool&gt; &gt; &amp;G){ set&lt;int&gt; Visited; vector&lt;int&gt; Stack; for (int i = 0; i&lt;G.size(); i++){ //각 Vertex에서 시작해서 Graph를 dfs로 travesal한다. dfs(G, i, Visited, Stack); if (Visited.size() == G.size()){ return Stack; } } return Stack; } int main(){ /* create graph */ vector&lt;vector&lt;bool&gt; &gt; G(5, vector&lt;bool&gt;(5, false)); G[0][4] = true; G[0][2] = true; G[2][3] = true; G[1][4] = true; G[2][1] = true; vector&lt;int&gt; stack = topological_sort(G); while (stack.size()){ cout &lt;&lt; stack.back() &lt;&lt; &quot; &quot;; stack.pop_back(); } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html",
    "relUrl": "/docs/codingInterview/2016-02-25-algorithm-topological-sort.html"
  },
  "28": {
    "id": "28",
    "title": "Data Structure - LRU(Least Recently Used)",
    "content": "직접 구현해 본 LRU Cache. O(1) 시간 복잡도로 lookup과 put을 만족시키기 위해서는 Entry에 access하는 것도 O(1)이고 LRU인지 판별하는 것도 O(1)으로 해야 한다. 이를 위해 ks(C++은 unordered_map)과 doubly linked list를 사용했다. Cache Replacement가 실행되는 것은 Cache가 full인 것은 unordered_map의 size()가 미리 정한 entry의 갯수에 도달했을 경우이다. 구조 입력 데이터는 key와 value 조합으로 했으며, 삽입, 검색, 삭제의 기준은 key로 했다. 삽입, 삭제를 O(1)만에 하기 위해 singly linked list가 아닌 doubly linked list로 했다. 이를 Item의 member variable로 가지고 있으며, hashtable에 그대로 저장되도록 했다. 구현을 용이하게 하기 위해 constructor를 담은 struct로 정의했다. struct Item { string key; int value; Item *prev; Item *next; Item(string k, int v): key(k), value(v){ prev = NULL; next = NULL; }; }; public interface인 함수 프로토타입은 Cache라는 base class를 사용하여 다음과 같이 선언했다. Cache는 interface로만 동작하므로 pure virtual class이다. class Cache { public: virtual bool lookup(string key, int &amp;val) = 0; virtual void put(string key, int val) = 0; }; LRUCache class는 실제 구현을 포함하고 있으며 그 private 멤버는 다음과 같이 도출했으며 그 구현은 통상적은 doubly linked list의 operation과 같다. class LRUCache: public Cache{ private: /* Linked list 관련 */ Item *head; //가장 최근에 참조된 아이템을 가리킴 (head-&gt;next) Item *tail; //가장 오래전에 참조된 아이템을 가리킴 (tail-&gt;prev) void detach(Item *item); //linked list에서 item을 제거 void push_front(Item *item); //linked list의 head에 item 추가(newest) void pop_back(); //linked list의 tail이 가리키는 아이템(oldest) 제거 bool back(string &amp;key); //가장 오래전에 참조된 아이템의 key 획득, 없으면 false /* Hashtable 관련 */ int MaxNumEntries; unordered_map&lt;string,Item*&gt; CacheEntries; }; LRUCache의 publc member의 구현을 살펴보자. 먼저 Constructor와 destructor는 linked list를 초기화하거나 제거한다. LRUCache(int num):MaxNumEntries(num){ //head &lt;-&gt; tail head = new Item(&quot;0&quot;, 0); tail = new Item(&quot;0&quot;, 0); head-&gt;next = tail; tail-&gt;prev = head; }; ~LRUCache(){ while(head-&gt;next != tail){ pop_back(); } delete head; delete tail; } Lookup method는 Hashtable에서 해당하는 key가 존재하는지 확인하고 존재하면 그것의 value를 반환한다. 이때, Linked List에서 해당 아이템을 찾아서 그것을 맨 앞으로 이동시킨다. bool lookup(string k, int &amp;val){ /* find a matching item */ auto it = CacheEntries.find(k); if(it == CacheEntries.end()){ //not found return false; } val = (*it).second-&gt;value; //found /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return true; } Put method는 Hashtable에서 해당하는 key가 존재하는지 먼저 찾는다. 존재한다면 value를 update하고 Lookup method처럼 Linked List에서 해당 아이템을 찾아서 맨 앞으로 이동시킨다. 존재하지 않는다면 다음의 두가지 경우를 고려해야 한다. Hashtable의 아이템 숫자가 미리 정한 숫자에 도달하지 않은 경우: 아이템을 Hashtable에 추가하고, LinkedList의 맨 앞에도 추가한다. Hashtable의 아이템 숫자가 미리 정한 숫자에 도달한 경우(Full): Linked List의 맨 뒤에서 가장 오래전에 참조된 아이템의 key를 획득하고, 그 아이템을 Linked List와 Hashtable에서 제거한다. 그 뒤 새로운 아이템을 Hashtable에 추가하고 Linked List의 맨 앞에 추가한다. void put(string k, int val){ /* find a matching item: O(1) operation */ auto it = CacheEntries.find(k); if(it != CacheEntries.end()){ //found /* update data */ (*it).second-&gt;value = val; /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return; } /* Add new one: O(1) operation */ if(CacheEntries.size() != MaxNumEntries){ //Cache is NOT full Item *t = new Item(k, val); pair&lt;string, Item *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } else { //Cache is full /* Select Victim &amp; delete */ string key; back(key); //get the key of the oldest one pop_back(); //remove the oldest one auto rt = CacheEntries.find(key); if(rt != CacheEntries.end()){ //found CacheEntries.erase(rt); //delete } Item *t = new Item(k, val); pair&lt;string, Item *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } } code #include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;string&gt; using namespace std; struct Item { string key; int value; Item *prev; Item *next; Item(string k, int v): key(k), value(v){ prev = NULL; next = NULL; } }; class Cache { public: virtual bool lookup(string key, int &amp;val) = 0; virtual void put(string key, int val) = 0; }; class LRUCache : public Cache { private: /* Doubly Linked List: Head - The most recent, Tail - The least recent */ Item *head; Item *tail; void detach(Item *item){ //Detach item from linked list : O(1) item-&gt;next-&gt;prev = item-&gt;prev; item-&gt;prev-&gt;next = item-&gt;next; }; void push_front(Item *item){ //Add the new item at the front : O(1) item-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = item; head-&gt;next = item; item-&gt;prev = head; }; void pop_back(){ //delete item from the tail : O(1) Item *item = tail-&gt;prev; if(item != head){ tail-&gt;prev = item-&gt;prev; delete item; } else { tail-&gt;prev = head; } tail-&gt;prev-&gt;next = tail; }; bool back(string &amp; key){ //Get the item from the tail: O(1) if(tail-&gt;prev == head){ return false; } key = tail-&gt;prev-&gt;key; return true; }; /* Hash Table */ int MaxNumEntries; unordered_map&lt;string,Item*&gt; CacheEntries; public: LRUCache(int num):MaxNumEntries(num){ //head &lt;-&gt; tail head = new Item(&quot;0&quot;, 0); tail = new Item(&quot;0&quot;, 0); head-&gt;next = tail; tail-&gt;prev = head; }; ~LRUCache(){ while(head-&gt;next != tail){ pop_back(); } delete head; delete tail; } bool lookup(string k, int &amp;val){ /* find a matching item */ auto it = CacheEntries.find(k); if(it == CacheEntries.end()){ //not found return false; } val = (*it).second-&gt;value; //found /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return true; } void put(string k, int val){ /* find a matching item: O(1) operation */ auto it = CacheEntries.find(k); if(it != CacheEntries.end()){ //found /* update data */ (*it).second-&gt;value = val; /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return; } /* Add new one: O(1) operation */ if(CacheEntries.size() != MaxNumEntries){ //Cache is NOT full Item *t = new Item(k, val); pair&lt;string, Item *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } else { //Cache is full /* Select Victim &amp; delete */ string key; back(key); //get the key of the oldest one pop_back(); //remove the oldest one auto rt = CacheEntries.find(key); if(rt != CacheEntries.end()){ //found CacheEntries.erase(rt); //delete } Item *t = new Item(k, val); pair&lt;string, Item *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } } }; int main(){ LRUCache cache(5); cache.put(&quot;A&quot;, 1); cache.put(&quot;B&quot;, 2); cache.put(&quot;C&quot;, 3); cache.put(&quot;D&quot;, 4); cache.put(&quot;E&quot;, 5); int val; if(cache.lookup(&quot;A&quot;, val)){ //&#39;A&#39; is updated. So &#39;B&#39; becomes the oldest. cout &lt;&lt; &quot;A&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; //expected result } else { cout &lt;&lt; &quot;A: Not found&quot; &lt;&lt; endl; } cache.put(&quot;F&quot;, 6); //Cache replacement. &#39;B&#39; is removed and &#39;C&#39; becomes the oldest if(cache.lookup(&quot;B&quot;, val)){ cout &lt;&lt; &quot;B&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;B: Not found&quot; &lt;&lt; endl; //expected } cache.put(&quot;C&quot;, 7); //&#39;C&#39; is updated. Now &#39;D&#39; becomes the oldest if(cache.lookup(&quot;C&quot;, val)){ cout &lt;&lt; &quot;C&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; //expected } else { cout &lt;&lt; &quot;C: Not found&quot; &lt;&lt; endl; } cache.put(&quot;G&quot;, 8); //Cache replacement. &#39;D&#39; is removed and &#39;E&#39; becomes the oldest if(cache.lookup(&quot;D&quot;, val)){ cout &lt;&lt; &quot;D&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;D: Not found&quot; &lt;&lt; endl; //expected result } return 0; } template template을 이용해 입력 type을 컴파일 타임에 결정하게 한 코드는 다음과 같다. #include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;string&gt; using namespace std; template&lt;class K, class V&gt; struct Item { K key; V value; Item *prev; Item *next; Item(string k, int v) : key(k), value(v){ prev = NULL; next = NULL; } }; template&lt;class K, class V&gt; class Cache { public: virtual bool lookup(K key, V &amp;val) = 0; virtual void put(K key, V val) = 0; }; template&lt;class K, class V&gt; class LRUCache : public Cache&lt;K, V&gt; { private: /* Doubly Linked List: Head - The most recent, Tail - The least recent */ Item&lt;K, V&gt; *head; Item&lt;K, V&gt; *tail; void detach(Item&lt;K, V&gt; *item){ //Detach item from linked list : O(1) item-&gt;next-&gt;prev = item-&gt;prev; item-&gt;prev-&gt;next = item-&gt;next; }; void push_front(Item&lt;K, V&gt; *item){ //Add the new item at the front : O(1) item-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = item; head-&gt;next = item; item-&gt;prev = head; }; void pop_back(){ //delete item from the tail : O(1) Item&lt;K, V&gt; *item = tail-&gt;prev; if (item != head){ tail-&gt;prev = item-&gt;prev; delete item; } else { tail-&gt;prev = head; } tail-&gt;prev-&gt;next = tail; }; bool back(K &amp; key){ //Get the item from the tail: O(1) if (tail-&gt;prev == head){ return false; } key = tail-&gt;prev-&gt;key; return true; }; /* Hash Table */ int MaxNumEntries; unordered_map&lt;K, Item&lt;K,V&gt;*&gt; CacheEntries; public: LRUCache(int num) :MaxNumEntries(num){ //head &lt;-&gt; tail head = new Item&lt;K, V&gt;(&quot;0&quot;, 0); tail = new Item&lt;K, V&gt;(&quot;0&quot;, 0); head-&gt;next = tail; tail-&gt;prev = head; }; ~LRUCache(){ while (head-&gt;next != tail){ pop_back(); } delete head; delete tail; } bool lookup(K k, V &amp;val){ /* find a matching item */ auto it = CacheEntries.find(k); if (it == CacheEntries.end()){ //not found return false; } val = (*it).second-&gt;value; //found /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return true; } void put(K k, V val){ /* find a matching item: O(1) operation */ auto it = CacheEntries.find(k); if (it != CacheEntries.end()){ //found /* update data */ (*it).second-&gt;value = val; /* update linked list */ detach((*it).second); //detach push_front((*it).second); //add to the head because this is the latest return; } /* Add new one: O(1) operation */ if (CacheEntries.size() != MaxNumEntries){ //Cache is NOT full Item&lt;K, V&gt; *t = new Item&lt;K, V&gt;(k, val); pair&lt;K, Item&lt;K, V&gt; *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } else { //Cache is full /* Select Victim &amp; delete */ K key; back(key); //get the key of the oldest one pop_back(); //remove the oldest one auto rt = CacheEntries.find(key); if (rt != CacheEntries.end()){ //found CacheEntries.erase(rt); //delete } Item&lt;K, V&gt; *t = new Item&lt;K, V&gt;(k, val); pair&lt;K, Item&lt;K, V&gt; *&gt; entry(k, t); CacheEntries.insert(entry); push_front(t); //Latest one } } }; int main(){ LRUCache&lt;string, int&gt; cache(5); cache.put(&quot;A&quot;, 1); cache.put(&quot;B&quot;, 2); cache.put(&quot;C&quot;, 3); cache.put(&quot;D&quot;, 4); cache.put(&quot;E&quot;, 5); int val; if (cache.lookup(&quot;A&quot;, val)){ //&#39;A&#39; is updated. So &#39;B&#39; becomes the oldest. cout &lt;&lt; &quot;A&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; //expected result } else { cout &lt;&lt; &quot;A: Not found&quot; &lt;&lt; endl; } cache.put(&quot;F&quot;, 6); //Cache replacement. &#39;B&#39; is removed and &#39;C&#39; becomes the oldest if (cache.lookup(&quot;B&quot;, val)){ cout &lt;&lt; &quot;B&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;B: Not found&quot; &lt;&lt; endl; //expected } cache.put(&quot;C&quot;, 7); //&#39;C&#39; is updated. Now &#39;D&#39; becomes the oldest if (cache.lookup(&quot;C&quot;, val)){ cout &lt;&lt; &quot;C&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; //expected } else { cout &lt;&lt; &quot;C: Not found&quot; &lt;&lt; endl; } cache.put(&quot;G&quot;, 8); //Cache replacement. &#39;D&#39; is removed and &#39;E&#39; becomes the oldest if (cache.lookup(&quot;D&quot;, val)){ cout &lt;&lt; &quot;D&#39;s value is &quot; &lt;&lt; val &lt;&lt; endl; } else { cout &lt;&lt; &quot;D: Not found&quot; &lt;&lt; endl; //expected result } return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html",
    "relUrl": "/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html"
  },
  "29": {
    "id": "29",
    "title": "Algorithm - 2D Matrix 회전",
    "content": "Problem NxN 크기의 2D Matrix의 시계 방향, 그리고 반 시계 방향 회전을 하는 방법을 알아보자. Matix를 얼마나 쉽게 다룰 수 있는가를 알 수 있는 간단한 알고리즘이다. 안타깝게도 전혀 제대로 하지 못해서 큰 인터뷰에서 문제가 된 적이 있기에 간단한 접근 방법과 코드를 남긴다. 예를 들어 다음과 같은 3x3 2d Matrix가 있다면, 1 2 3 4 5 6 7 8 9 시계 방향 90 회전은 다음과 같다. 7 4 1 8 5 2 9 6 3 반시계 방향 90 회전은 다음과 같다. 3 6 9 2 5 8 1 4 7 접근법 시계 방향 회전 NxN의 2D matrix를 4등분을 한다고 생각해보자. 시계 방향으로 회전한다는 것은 1사분면부터 시작한다면 1사분면의 것은 잠시 저장하고, 4사분면을 1사분면으로, 3사분면을 4사분면으로, 2사분면의 것을 3사분면으로, 1사분면의 것을 2사분면으로 옮긴다는 것이다. 1사분면의 좌표를 (y, x)이고 높이와 넓이가 N이라고 할 때 각 사분면에서의 위치를 고민해보자. 각 예를 보면 다음과 같다. 1사분면 : (0, 0), (0, 1), (0, 2) 2사분면 : (0, N-1), (1, N-1), (2, N-1) 3사분면 : (N-1, N-1),(N-1, N-2),(N-1, N-3) 4사분면 : (N-1, 0), (N-2, 0), (n-3, 0) 위의 것을 일반화 시키면 다음과 같다. 1사분면: (y, x) 2사분면: (x, N-1-y) 3사분면: (N-1-y, N-1-x) 4사분면: (N-1-x, y) 각 사분면간 이동은 다음과 같다. 1사분면의 각 좌표에 대해 temp에 저장 4사분면의 것을 1사분면으로 복사 3사분면의 것을 4사분면으로 복사 2사분면의 것을 3사분면으로 복사 temp에 저장된 1사분의 것을 2사분면으로 복사 시계 반대 방향 회전 기본적으로 시계 방향 회전과 동일한데 순서만 다르다. 1사분면의 각 좌표에 대해 temp에 저장 2사분면의 것을 1사분면으로 복사 3사분면의 것을 2사분면으로 복사 4사분면의 것을 2사분면으로 복사 temp에 저장된 1사분의 것을 4사분면으로 복사 주의 할 점 N이 짝수인 경우 1사분면의 범위는 다음과 같다. 세로: 0~N/2 (N/2는 미포함) 가로: 0~N/2 (N/2는 미포함) N이 홀수인 경우는 가로, 세로 중 하나는 가운데 줄을 포함해야 한다. 즉, 약간 비대칭적으로 해야한다는 것이다. 당연한 것이 그렇지 않고 가로/세로 모두 가운데 줄을 미포함하면 1사분면이 아니라 약간 작은 사각형이 된다. 세로: 0~N/2 (N/2는 포함) 가로: 0~N/2 (N/2는 미포함) 또는 세로: 0~N/2 (N/2는 미포함) 가로: 0~N/2 (N/2는 포함) 코드 #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; void print(vector&lt;vector&lt;int&gt; &gt; &amp;T){ cout &lt;&lt; endl; for (int i = 0; i&lt;T.size(); i++){ for (int j = 0; j&lt;T.size(); j++){ cout &lt;&lt; T[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;T, bool isClockwiseDirection, int times){ int N = T.size(); int H = T.size() / 2; if (N % 2) {// 홀수 인경우 Height를 1 증가 시켜서 1사분면을 잡는다. H++; } for (int t = 1; t &lt;= times; t++){ //90 회전 횟수 for (int i = 0; i&lt;H; i++) { for (int j = 0; j&lt;N / 2; j++){ if (isClockwiseDirection) { //시계 방향 int temp = T[i][j]; T[i][j] = T[N - 1 - j][i]; T[N - 1 - j][i] = T[N - 1 - i][N - 1 - j]; T[N - 1 - i][N - 1 - j] = T[j][N - 1 - i]; T[j][N - 1 - i] = temp; } else { //반시계 방향 int temp = T[i][j]; T[i][j] = T[j][N - 1 - i]; T[j][N - 1 - i] = T[N - 1 - i][N - 1 - j]; T[N - 1 - i][N - 1 - j] = T[N - 1 - j][i]; T[N - 1 - j][i] = temp; } } } } } int main(){ vector&lt;vector&lt;int&gt; &gt; T_even = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } }; vector&lt;vector&lt;int&gt; &gt; T_odd = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; /*짝수크기의 2D matrix를 시계 방향으로 회전 */ print(T_even); rotate(T_even, true, 1); print(T_even); rotate(T_even, true, 2); print(T_even); /*홀수크기의 2D matrix를 시계 반대방향으로 회전 */ print(T_odd); rotate(T_odd, false, 1); print(T_odd); rotate(T_odd, false, 1); print(T_odd); rotate(T_odd, false, 1); print(T_odd); rotate(T_odd, false, 1); return 0; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html",
    "relUrl": "/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html"
  },
  "30": {
    "id": "30",
    "title": "Data Structure - B-tree",
    "content": "B 트리는 자식을 두개만 가질 수 잇는 이진 트리를 확장하여 더 많은 자식을 가질 수 있게 고안한 것이다. 오라클과 같은 상용 DB에서 많이 사용하는 자료구조로 외부 검색(주 저장장치인 메모리 외의 저장장치에서의 검색)에 유용하다. Balanced Tree란? 이진 트리는 O(NlogN)의 시간 복잡도를 가지지만, 좌우 균형이 맞지 않으면 비효율적인 성능을 낸다. 예를 들어 정렬이 되어 있는 자료를 순차적으로 삽입하면 한쪽으로만 치우치게 되고 O(N*N)의 시간 복잡도를 갖게된다. 이와 같은 이진트리의 문제를 해결하고 항상 삽입/삭제/검색이 O(NlogN)의 성능을 내도록 삽입과 삭제시에 스스로 좌우 균형을 유지하는 트리를 Balanced Tree라고 한다. Balanced Tree의 종류 Balanced 트리의 종류는 다음과 같다. AVL 트리 2-3 트리 2-3-4 트리 Red-Black 트리 B 트리 위 중 AVL트리와 Red-Black트리는 유사하고 2-3/2-3-4트리와 B트리는 유사하다. B 트리란? 이진 트리와 달리 하나의 노드가 여러 데이터를 가진다. 한 노드에 최대 M개의 자료가 배치될 수 있으면 M차 B트리라고 한다. 이 M이 짝수냐 홀수냐에 따라 알고리즘이 상당히 다르다. 2, 4, 6차 B트리와 3,5,7차 B트리는 상당히 다른 알고리즘을 사용한다. 홀수 B 트리가 짝수 B 트리에 비해 알고리즘이 많이 쉽다. 2-3 트리는 2차 B 트리와 같은 것이고, 2-3-4 트리는 3차 B 트리와 같다. B 트리의 정의와 규칙 간단한 규칙 B 트리는 다음과 같은 규칙을 갖는다. 노드의 데이터 수가 N이면 자식의 수는 항상 N+1이여야 한다. 즉, 노드 2개의 데이터를 가진다면 그 노드의 자식은 반드시 3개여야 한다는 것이다. 노드내의 데이터는 반드시 정렬된 상태여야 한다. 노드의 데이터 D1의 왼쪽 서브 트리는 D1보다 작은 값들로 이루어져 있어야 하고, D1의 오른쪽 서브트리는 D1보다 큰 값들로 이루어져 있어야 한다. 이진 검색 트리의 성질과 유사하다. 복잡한 규칙 Root 노드는 자식이 있다면 적어도 2개 이상의 자식을 가져야 한다. Root 노드를 제외한 모든 노드는 적어도 M/2개의 데이터를 가지고 있어야 한다. 예를 들어 5차 B트리라면 적어도 2개의 데이터를 가지고 있어야 한다. Leaf 노드로 가는 경로의 길이는 모두 같다. 즉, leaf 노드는 모두 같은 레벨에 존재한다. 입력 자료는 중복될 수 없다. B 트리 구현 B 트리 노드 노드의 구조 B 트리 노드는 N개의 데이터를 저장하는 배열, Child를 가리키는 포인터를 N+1개 저장하는 배열이 필요하다. 데이터 배열의 데이터 index i에 대해 Children 배열의 인덱스는 다음과 같은 관계를 가진다. index i: i 데이터의 left child node를 가리키는 포인터가 저장된 index index i+1: i 데이터의 right child node를 가리키는 포인터가 저장된 index struct Datum { int key; int value; Datum (){ key = 0; value = 0;}; }; struct Node { vector&lt;Datum&gt; Data; vector&lt;Node *&gt; Children; int Dim; int count; Node(int d){ Dim = d; Keys.resize(Dim, 0); Children.resize(Dim + 1, NULL); count = 0; }; }; 데이터의 값 반환 데이터 배열의 인덱스를 넣으면 그 키 값을 반환하거나 value를 반환한다. int keyAt(int index){ return Data[index].key; }; int valueAt(int index){ return Data[index].value; }; 데이터의 child 반환 노드의 배열 구조를 이용한다. 데이터의 index를 받으면 left 혹은 right child의 포인터를 반환한다. Node* leftChildOf(int index){ return Children[index]; }; Node* rightChildOf(int index){ return Children[index + 1]; }; 노드에서 데이터 삽입 노드의 데이터는 B 트리의 규칙에 따라 정렬되어 있어야 한다. 그러므로 정렬된 데이터들에게 데이터를 삽입하는 상황이므로 삽입 정렬과 같은 방식으로 삽입을 한다. 맨 뒤에서부터 하나씩 shift하면서 비교해서 적당한 위치에 놓으면 된다. 그리고 이때 Children 배열도 함께 Shift해야 한다. 쉽게 하기 위해 left child와 right child의 포인터를 이미 알고 있다고 하자. 그러면, 데이터 배열에서의 데이터의 index를 정하면 Children 배열의 index에는 left child를 넣고, index + 1에는 right child를 넣는다. void insertKey(int k, int v, Node* leftChild, Node* rightChild){ if(count &gt;= Dim) return; int i = count-1; //last index prior to insertion while(i&gt;=0 &amp;&amp; Data[i].key &gt; k){ Data[i + 1].key = Data[i].key; Data[i + 1].value = Data[i].value; Children[i + 1] = Children[i]; i--; } i++; Data[i].key = k; Data[i].value = v; Children[i] = leftChild; Children[i+1] = rightChild; count++; }; 노드에서 데이터 검색 노드는 정렬된 값을 가지고 있다. 차수가 작은 경우엔 순차적으로 검색하고, 차수가 큰 경우엔 이분 검색등을 이용한다. 찾으면 그 index를 반환하고, 못찾으면 -1을 반환한다. int findKey(const int k){ for(int i = 0; i&lt;count; i++){ if(Data[i].key == k) return i; } return -1; } 노드에서 데이터 삭제 데이터 삽입과 달리 데이터의 index를 이미 알고 있는 상황이라고 생각하자. 그러면 그 index만 지우면 되는데 이때 Children 배열에서는 Left child의 값을 지우는 것으로 하자. void deleteKey(int index){ if(index &gt;= count) return; int i = index + 1; for(; i&lt;count; i++){ Data[i - 1].key = Data[i].key; Data[i - 1].value = Data[i].value; Children[i - 1] = Children[i]; } Children[i - 1] = Children[i]; count--; }; 노드 구현 key가 int인 경우로 구현한 노드는 다음과 같다. #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; struct Datum { int key; int value; Datum (){ key = 0; value = 0;}; }; struct Node { vector&lt;Datum&gt; Data; vector&lt;Node *&gt; Children; int Dim; int count; Node(int d){ Dim = d; Data.resize(Dim); Children.resize(Dim + 1, NULL); count = 0; }; ~Node(){}; int keyAt(int index){ return Data[index].key; }; int valueAt(int index){ return Data[index].value; }; Node* leftChildOf(int index){ return Children[index]; }; Node* rightChildOf(int index){ return Children[index + 1]; }; void insertKey(int k, int v, Node* leftChild, Node* rightChild){ if(count &gt;= Dim) return; int i = count-1; //last index prior to insertion while(i&gt;=0 &amp;&amp; Data[i].key &gt; k){ Data[i + 1].key = Data[i].key; Data[i + 1].value = Data[i].value; Children[i + 1] = Children[i]; i--; } i++; Data[i].key = k; Data[i].value = v; Children[i] = leftChild; Children[i+1] = rightChild; count++; }; void deleteKey(int index){ if(index &gt;= count) return; int i = index + 1; for(; i&lt;count; i++){ Data[i - 1].key = Data[i].key; Data[i - 1].value = Data[i].value; Children[i - 1] = Children[i]; } Children[i - 1] = Children[i]; count--; }; int findKey(const int k){ for(int i = 0; i&lt;count; i++){ if(Data[i].key == k) return i; } return -1; } }; B 트리의 구조 Root Node를 가리키는 HeadNode를 만들어 둔다. key가 하나도 없어도 HeadNode는 존재하는 것이다. 그리고 HeadNode의 Children[0]이 Root Node를 가리킨다. key가 없을 때는 HeadNode-&gt;Children[0]이 NULL이다. class BTree { private: Node* head; public: BTree(){ head = new Node(5); //5차 Btree }; ~BTree(){ delete head; }; }; B 트리의 검색 다음과 같은 순서에 따라 iteration하며 검색한다. 1. Root Node에서부터 시작하며 입력된 key값을 찾는다. 2. Node가 NULL이 아니고 자신의 노드에서 key를 찾지 못하면 3. Keys[]를 index 0부터 마지막 index까지 돌면서 입력 key보다 큰 key를 가진 index의 왼쪽 Child 노드를 현재 Node로 갱신해서 4. 2-3을 반복한다. 5. 만약 Node가 NULL이기 때문에 2-3 반복이 종료된 것이면 찾지 못한 것이다. 6. 만약 Node가 NULL이 아니면서 종료된 것이면 해당 index를 이용해 그 값을 반환한다. 검색의 구현 위의 검색 알고리즘을 코드로 구현하면 다음과 같다. bool find(const int &amp;key, int &amp;value){ Node *temp = head-&gt;Children[0]; while( temp != NULL){ /* Node의 key값 확인 */ int index = temp-&gt;findKey(key); if(index &gt;= 0) { //Found! value = temp-&gt;valueAt(index); return true; } /* Children 확인*/ int c_index = 0; for(; c_index&lt; temp-&gt;count; c_index++){ if(key &lt; temp-&gt;keyAt(c_index)) break; } temp = temp-&gt;leftChildOf(c_index); } return false; }",
    "url": "http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html",
    "relUrl": "/docs/codingInterview/2016-03-03-data-structure-b-tree.html"
  },
  "31": {
    "id": "31",
    "title": "Java - Big Number(BigInteger와 BigDecimal)",
    "content": "매우 매우 매우 큰 크기의 숫자를 저장할 수 있는 Java BigInteger와 BigDecimal class에 대해 간단히 알아보자. 1. BigInteger BigInteger는 거의 무한한 크기의 정수형 숫자를 다루기 위한 것이다. 자세한 내용은 Java API - BigInteger을 참고하자. 1.1 사칙 연산 BigInteger constructor의 argument는 string입력이다. 사칙연산을 위해서는 기본 사칙 연산 기호(+-*/%)를 사용할 수 없고 다음의 method를 사용해야 한다. (a, b는 BigInteger instance) a.add(b) a.subtract(b) a.multiply(b) a.divide(b) a.mod(b) 참고로, 일반 integer를 입력하려면 BigInteger.valueOf(숫자) 형태로 입력한다. 예제는 다음과 같다. BigInteger big = new BigInteger(&quot;10&quot;); System.out.println(big); BigInteger anotherBig = big.add(BigInteger.valueOf(100)); System.out.println(anotherBig); BigInteger theOtherBig = anotherBig.add(big); System.out.println(theOtherBig); 출력은 다음과 같다. 10 110 120 1.2 주요 함수들 위의 사칙연산 함수외의 함수는 다음과 같다. 비교: a.compareTo(b) - -1(a&lt;b), 0(a==b), 1(a&gt;b)를 반환 같은지 비교: a.equals(b) - true/false 반환 min: a.min(b) max: a.max(b) 숫자로 변환: b.doubleValue(), b.floatValue(), b.intValue(), b.longValue() 10진법 문자로 변환: b.toString() n진법 문자로 변환: b.toString(n) 절대값: b.abs() n승: b.pow(n) 2. BigDecimal BigDecimal은 무한한 크기의 부동소수점 숫자를 다루기 위한 것이다. Java API - BigDecimal을 참고하자 2.1 사칙 연산 BigDecimal도 BigInteger와 거의 유사한 방식으로 숫자를 다룬다. BigDecimal constructor의 argument는 string입력이다. 사칙연산을 위해서는 기본 사칙 연산 기호(+-*/)를 사용할 수 없고 다음의 method를 사용해야 한다. (a, b는 BigDecimal) a.add(b) a.subtract(b) a.multiply(b) a.divide(b,BigDecimal.ROUND_UP) - 소수 첫째 자리에서 올림 (ROUND_DOWN, ROUND_CEILING, ROUND_FLOOR, ROUND_HALF_DOWN/UP/EVEN 등이 있음) d.divide(b, n, BigDecimal.ROUND_UP) - 소수점 n자리에서 올림 참고로, 일반 integer를 입력하려면 BigDecimal.valueOf(숫자) 형태로 입력한다. 예제는 다음과 같다. BigDecimal b1 = new BigDecimal(&quot;0.3); BigDecimal b2 = new BigDecimal(&quot;0.4&quot;); System.out.println(b1.add(BigDecimal.valueOf(0.5))); System.out.println(b1.multiply(b2)); System.out.println(b1.divide(b2, BigDecimal.ROUND_UP)); System.out.println(b1.divide(b2, 5, BigDecimal.ROUND_UP)); 출력은 다음과 같다. 0.9 0.12 1.4 1.33334 2.2 Arrays.sort()에서의 사용 예 N개의 BigDecimal 입력을 받아서 sorting하는 예를 통해 BigDecimal의 사용을 살펴보자. N개의 BigDecimal로 변환 가능한 스트링 입력을 받아서 이를 큰 것에서 작은 순으로 정렬하는 예를 살펴보자. 그리고, 이때 입력의 수보다 Array에 미리 할당한 크기가 더 크게 하여 Arrays.sort()에서 어떻게 이를 처리했는지 보자. 다음이 입력 예이다. 9 //9개 입력 -100 50 0 56.6 90 0.12 .12 02.34 000.000 import java.math.BigDecimal; import java.util.*; public class Solution { public static void main(String[] args) { Scanner sc= new Scanner(System.in); int n=sc.nextInt(); String []s=new String[n+2]; for(int i=0;i&lt;n;i++){ s[i]=sc.next(); } sc.close(); //Arrays.sort()를 이용해서 descending order로 sorting하기. 이때 범위는 0~n-1까지 Arrays.sort(s, 0, n, (s1, s2)-&gt;(new BigDecimal(s2).compareTo(new BigDecimal(s1)))); for(int i=0;i&lt;n;i++) { System.out.println(s[i]); } } } 출력은 다음과 같다. 90 56.6 50 02.34 0.12 .12 0 000.000 -100",
    "url": "http://localhost:4000/docs/java/2016-08-22-java-big-number.html",
    "relUrl": "/docs/java/2016-08-22-java-big-number.html"
  },
  "32": {
    "id": "32",
    "title": "Java - Collections API",
    "content": "Java의 Collections class는 static method로만 구성된 utility 클래스이다. Collections를 통해 Java Collection Framework의 알고리즘을 제공한다. 자세한 내용은 여기를 참고하자. 주요 함수들 Collections.sort(List myList) List를 Ascending order로 sorting한다. Collecions.sort(List myList, Collections.reverseOrder()) List를 Descending order로 sorting한다. Collections.sort(List myList, comparator cmp) comparator를 이용해 sorting한다. Java의 comparator는 다음에 자세히 알아보자. Collections.shuffle(List myList) List 아이템을 무작위로 순서를 바꾼다. Collections.reverse(List myList) List 아이템의 순서를 완전히 뒤집는다. Collections.binarySearch(List myList, T key) myList의 아이템을 binary search로 검색한다. Collections.frequency(List myList, Object o) myList의 아이템 중 o가 몇 개 존재하는지를 반환한다. 예제 List&lt;Integer&gt; myList = new ArrayList(); myList.add(3); myList.add(4); myList.add(10); myList.add(-1); myList.add(2); myList.add(10); myList.add(101); myList.add(0); System.out.println(&quot;Original: &quot; + myList); Collections.sort(myList); System.out.println(&quot;Sorted:&quot; + myList); Collections.sort(myList, Collections.reverseOrder()); System.out.println(&quot;Sorted in descending order:&quot; + myList); Collections.reverse(myList); System.out.println(&quot;Re-Reversed: &quot; + myList); Collections.shuffle(myList); System.out.println(&quot;Shuffled: &quot; + myList); System.out.println(&quot;Occurance of 10: &quot; + Collections.frequency(myList, 10)); 결과 Original: [3, 4, 10, -1, 2, 10, 101, 0] Sorted:[-1, 0, 2, 3, 4, 10, 10, 101] Sorted in descending order:[101, 10, 10, 4, 3, 2, 0, -1] Re-Reversed: [-1, 0, 2, 3, 4, 10, 10, 101] Shuffled: [2, 4, 101, 3, 10, 10, 0, -1] Occurance of 10: 2",
    "url": "http://localhost:4000/docs/java/2016-08-23-java-collections-api.html",
    "relUrl": "/docs/java/2016-08-23-java-collections-api.html"
  },
  "33": {
    "id": "33",
    "title": "Java - Comparable과 Comparator",
    "content": "Java에서 비교를 위한 Comparable interface와 Comparator에 대해 살펴보자. 1. 개요 Java에서 정렬들을 위한 목적으로 Object를 비교하기 위해 Comparable interface에서 정의한 CompareTo()함수를 구현하거나, Comparator를 구현해야 한다. 이 두가지를 살펴보자. CompareTo() Comparator 2. 문제점 다음과 같은 Book class가 있고, 이를 가격 순으로 정렬하기 위한 코드를 짠다고 생각해보자. 2.1 Book class public class Book { private int price; public Book(int price){ this.price = price; } public int getPrice(){ return this.price; } } 2.2 Solution class 이제 Book class를 생성해 List에 넣고 정렬을 하는 코드를 짜보자. import java.util.Collections; import java.util.ArrayList; import java.util.List; public class Solution { public static void main(String[] args) { List&lt;Book&gt; myBookList = new ArrayList(); myBookList.add(new Book(300)); myBookList.add(new Book(310)); myBookList.add(new Book(100)); myBookList.add(new Book(200)); System.out.println(&quot;Original: &quot; + myBookList); Collections.sort(myBookList); for(Book book : myBookList){ System.out.println(book.getPrice()); } } } 이렇게 하면 Collections.sort함수에서 sort를 적용할 수 있는 instance가 아니라는 에러가 뜬다. 왜냐하면 Book class가 sort에 쓰이는 비교 함수를 구현하지 않았기 때문이다. 3. Comparable Interface Book instance를 비교하기 위해서는 Comparable interface에서 정의하는 public int compareTo(Object o)을 구현해야 한다. Book class를 다음과 같이 수정해 보자. 여기서는 ascending order를 가정한다. public class Book implements Comparable&lt;Book&gt;{ private int price; public Book(int price){ this.price = price; } public int getPrice(){ return this.price; } @Override public int compareTo(Book b) { return this.price - b.price; //자신이 앞에 있는게 ascending order } } 2.2 Solution class를 그대로 두고 실행하면 결과는 다음과 같다. 100 200 300 310 **implements Comparable**형태에 주의하자. 4. Comparator Comparator는 static Comparator instance로 비교 대상인 object를 수정하지 않고 비교를 위한 함수를 만들 수 있다. 4.1 Syntax Comparator의 syntax는 다음과 같다. public static Comparator&lt;Type&gt; myComparator = new Comparator&lt;Type&gt;() { public int compare(Type o1, Type o2) { //ascending order return o1 - o2; } }; 위의 myComparator를 다음과 같이 사용하면 된다. Collections.sort(myList, myComparator); 4.2 예제 2.1의 Book class를 그대로 두고 (Comparable Interface 구현 없이) sorting을 해보자. public class Book{ private int price; public Book(int price){ this.price = price; } public int getPrice(){ return this.price; } } 2.2의 Solution class를 다음과 같이 변경해보자. 4.2.1 Comparator import java.util.Collections; import java.util.ArrayList; import java.util.Comparator; import java.util.List; public class Solution { public static Comparator&lt;Book&gt; myComparator = new Comparator&lt;Book&gt;() { @Override public int compare(Book b1, Book b2) { return b1.getPrice() - b2.getPrice(); } }; public static void main(String[] args) { List&lt;Book&gt; myBookList = new ArrayList(); myBookList.add(new Book(300)); myBookList.add(new Book(310)); myBookList.add(new Book(100)); myBookList.add(new Book(200)); System.out.println(&quot;Original: &quot; + myBookList); Collections.sort(myBookList, myComparator); for(Book book : myBookList){ System.out.println(book.getPrice()); } } } 4.2.2 Anonymous Comparator 다음과 같이 anonymous Comparator를 사용해 작성할 수도 있다. import java.util.Collections; import java.util.ArrayList; import java.util.Comparator; import java.util.List; public class Solution { public static void main(String[] args) { List&lt;Book&gt; myBookList = new ArrayList(); myBookList.add(new Book(300)); myBookList.add(new Book(310)); myBookList.add(new Book(100)); myBookList.add(new Book(200)); System.out.println(&quot;Original: &quot; + myBookList); Collections.sort(myBookList, new Comparator&lt;Book&gt;() { @Override public int compare(Book b1, Book b2) { return b1.getPrice() - b2.getPrice(); } }); for(Book book : myBookList){ System.out.println(book.getPrice()); } } } 4.2.3 Lambda Anonymous function은 Java의 Lambda로 변환 가능하다. 이제 마지막 코드를 보자. import java.util.Collections; import java.util.ArrayList; import java.util.List; public class Solution { public static void main(String[] args) { List&lt;Book&gt; myBookList = new ArrayList(); myBookList.add(new Book(300)); myBookList.add(new Book(310)); myBookList.add(new Book(100)); myBookList.add(new Book(200)); System.out.println(&quot;Original: &quot; + myBookList); Collections.sort(myBookList, (Book b1, Book b2)-&gt; b1.getPrice() - b2.getPrice()); for(Book book : myBookList){ System.out.println(book.getPrice()); } } } 참고로 Java의 Lambda에서는 (a1, a2) -&gt; { return a1 &gt; a2; } 와 (a1, a2) -&gt; a1 &gt; a2; 를 compiler가 동일하게 본다.",
    "url": "http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html",
    "relUrl": "/docs/java/2016-08-23-java-comparable-comparator.html"
  },
  "34": {
    "id": "34",
    "title": "Java - Lambda",
    "content": "1. 개요 2. Lambda의 사용 2.1 Lambda없이 Publisher class에 Event listener 등록하기 2.1.1 Event Listener interface와 Publisher Class 2.1.2 나의 Event Listener 구현하고 등록하기 2.2 Lambda 코드 2.2.1 코드 2.2.2 매칭 3. Lambda에 대해 좀 더 자세한 이야기 3.1 Lambda Parameter 3.1.1 Zero Parameter 3.1.2 One Parameter 3.1.3 Multiple Parameter 3.1.4 Stream forEach와 method reference 3.2 Lambda Parameter Type 3.3 Lambda 함수의 body 3.3.1 body 부분 3.3.2 여러 줄인 경우 3.3 Lambda 함수의 return 3.3.1 명시적인 return 3.3.2 비명시적 return 4. Object로서의 Lambda 4.1 문제 4.2 구현 Java 8에서 지원하는 Lambda를 살펴보자. 이 글은 Jakob Jenkov의 Java Lambda tutorial의 많은 부분을 참고하여 작성하였다. 1. 개요 Labmda는 Java가 functional programming을 지원하기 시작한다는 신호이다. Lambda를 통해 어떤 class에도 속하지 않은 함수를 만들 수 있게 된 것이다. 함수를 마치 object처럼 argument로 사용하거나, 필요할 때에만 실행되도록 할 수 있게 되었다. 2. Lambda의 사용 Anonymous function은 event listener에 많이 사용되어지고, 이는 lambda로 변환하기 매우 적절한 부분이다. 2.1 Lambda없이 Publisher class에 Event listener 등록하기 Lambda없이 작성한 Java 7의 event listener를 등록하는 코드를 살펴보자. 2.1.1 Event Listener interface와 Publisher Class Event Listener interface는 다음과 같다. public interface StateChangeListener { public void onStateChange(State oldState, State newState); } 위의 event Listener를 argument로 가지는 Publisher Class는 다음과 같다. public class Publisher { public void addEventListener(StateChangeListener listener) { ... } } 2.1.2 나의 Event Listener 구현하고 등록하기 이제 Publisher instance에 내가 작성한 event listener를 등록하려면 다음과 같이 해야 할 것이다. Publisher publisher = new Publisher(); publisher.addStateListener(new StateChangeListener() { public void onStateChange(State oldState, State newState) { System.out.println(&quot;State changed&quot;); } }); 2.2 Lambda 코드 2.2.1 코드 위에서 작성한 event listener 코드 대신 Lambda를 이용하면 다음과 같이 간결하게 작성할 수 있다. StateOwner stateOwner = new StateOwner(); stateOwner.addStateListener( (oldState, newState) -&gt; System.out.println(&quot;State changed&quot;) //여기가 lambda 코드 ); 2.2.2 매칭 StateChangeListener 객체를 새로 생성할 필요 없고, onStateChange와 같이 이름을 명시할 필요도 없다. 자동적으로 컴파일러가 StateChangeListener 타입을 매칭할 것이다. StateChangeListener interface가 하나의 method만 가지고 있으므로 바로 매칭된다. 다음의 단계를 거쳐 매칭이 성공/실패가 결정된다. interface가 단지 하나의 method만 가지고 있나? 하나의 method의 parameter가 일치하는가? return type이 일치하는 가? 3. Lambda에 대해 좀 더 자세한 이야기 3.1 Lambda Parameter 3.1.1 Zero Parameter publisher.addStateListener(new StateChangeListener() { public void onStateChange() { System.out.println(&quot;State changed&quot;); } }); 위와 같은 &lt;1&gt;파라미터 없는 method는 ()만으로 표현 가능하다. () -&gt; System.out.println(&quot;State changed&quot;); 3.1.2 One Parameter publisher.addStateListener(new StateChangeListener() { public void onStateChange(State newState) { System.out.println(&quot;State changed :&quot; + newState); } }); 위와 같은 파라미터 없는 method는 다음과 같이 표현가능하다. &lt;2&gt;type이 유추가능한 경우 type을 생략할 수 있다. (newState) -&gt; System.out.println(&quot;State changed :&quot; + newState); **&lt;3&gt; Parameter가 하나만 있는 경우 ()를 생략할 수 있다. ** newState -&gt; System.out.println(&quot;State changed :&quot; + newState); 3.1.3 Multiple Parameter (oldState, newState) -&gt; System.out.println(“State changed” + oldState + “,” + newState); 3.1.4 Stream forEach와 method reference &lt;4&gt;Stream forEach과 결합하여 parameter를 비 명시적으로 하며 method reference를 사용할 수 있다. String[] arr = { &quot;program&quot;, &quot;creek&quot;, &quot;is&quot;, &quot;a&quot;, &quot;java&quot;, &quot;site&quot; }; Stream&lt;String&gt; stream = Stream.of(arr); stream.forEach(x -&gt; System.out.println(x)); 위의 코드는 다음과 같이 다음과 같이 변경 가능하다. Stream&lt;String&gt; stream = Stream.of(arr); stream.forEach(System.out::println); 3.2 Lambda Parameter Type 컴파일러가 Lambda Parameter Type을 헷갈려하는 경우 type을 추가하면 된다. (State newState) -&gt; System.out.println(&quot;State changed :&quot; + newState.getName()); 3.3 Lambda 함수의 body 3.3.1 body 부분 Lambda함수는 ‘-&gt;’ 뒷 부분이다. 예를 들어 다음 Lambda함수에서 System.out.println(&quot;State changed&quot;)이 body이다. (oldState, newState) -&gt; System.out.println(&quot;State changed&quot;) 3.3.2 여러 줄인 경우 Lambda 함수가 &lt;5&gt;여러 줄로 구성된 경우 {}를 사용하면 된다. (oldState, newState) -&gt; { System.out.println(&quot;Old state: &quot; + oldState); System.out.println(&quot;New state: &quot; + newState); } 3.3 Lambda 함수의 return 3.3.1 명시적인 return 다음과 같이 명시적으로 return을 사용할 수 있다. (param) -&gt; return &quot;return value&quot;; 3.3.2 비명시적 return Lambda &lt;6&gt;내부에서 계산된 값 또는 새로 만들어진 값을 return하는 경우 ‘return’을 생략할 수 있다. (param) -&gt; &quot;return value&quot;; 4. Object로서의 Lambda 기본적으로 Lambda expression은 object라서 다른 변수에 대입 가능하고, 함수의 argument로 사용가능하다. 4.1 문제 다음과 같이 Book Class의 page를 비교하는 interface가 있는 경우를 생각해보자. public class Book { private int page; public Book(int page){ this.page = page; } public int getPage(){ return this.page; } } public interface MyComparator { public boolean isTheSame(Book b1, Book b2); } 4.2 구현 위의 MyComparator을 어떻게 구현하는게 좋을까? Lambda를 이용하여 빠르게 구현할 있고, 변수에 대입하여 사용할 수 있다. MyComparator comparator = (b1, b2) -&gt; b1.getPage() == b2.getPage(); Book b1 = new Book(10); Book b2 = new Book(10); boolean result = comparator.isTheSame(b1, b2); System.out.println(result);",
    "url": "http://localhost:4000/docs/java/2016-08-23-java-lambda.html",
    "relUrl": "/docs/java/2016-08-23-java-lambda.html"
  },
  "35": {
    "id": "35",
    "title": "Java - Collection Framework",
    "content": "1. 용어 Java Collection Framework은 Java가 제공하는 잘 정의된 객체의 그룹을 다루기 위한 framework의 이름이고 java.util 패키지안에 있다. Collection은 Java collection framework을 구성하는 2개의 그룹 중 한 그룹의 최상위 레벨 인터페이스이고 Collections는 static 메소드만으로 구성된 유틸리티 클래스이다. 그런데 때로는 Collection과 Collections를 추상 명사로도 사용하므로 혼란스러울 수 있다. 예를 들어 Collections를 유틸리티 클래스가 아닌 객체 집합이라는 의미로도 많은 인터넷 상의 글들에서 사용되곤 한다. 2. Collection Framework 계층 구조 2.1 인터페이스들 전체 Colleciton Framework은 크게 2개의 그룹으로 구분된다. (그림 출처: 소설같은자바 Third Edition) java.util.Collection java.util.Map 2.1.1 java.util.Collection 인터페이스 그룹 아래의 것들이 java.util.Collection의 구현체가 아닌 인터페이스들이다. java.util.List : List 자료 구조 (ordered, sequential) java.util.Set : Set 자료 구조 (unique element) java.util.SortedSet : 정렬된 set java.util.NavigableSet java.util.Queue : Queue 자료 구조 (한쪽에서 삽입, 반대에서 추출) java.util.Deque : Deque 자료 구조 (FIFO와 FILO 모두 지원) 2.1.2 java.util.Map 인터페이스 그룹 java.util.Map은 key/value pair를 다루는데 사용된다. 다음과 같은 인터페이스들이 java.util.Map 인터페이스를 상속한다. java.util.SortedMap: key가 ascending order로 정렬된 map java.util.NavigableMap 2.2 Collection의 클래스들 Collection Framework에서 인터페이스들을 구현한 주요 클래스들은 다음과 같다. 위 그림 중 leaf node에 해당하는 것들이다. 아래 클래스 말고도 아래 설명할 Legacy 클래스들, Abstract 클래스들, Concurrent를 위한 클래스 들이 있다. ArrayList: Dynamic Array LinkedList: Linked List ArrayDeque: Dynamic Array를 이용한 Deque구현 TreeSet: Tree 구조로 set을 구현 HashSet: Hash table LinkedHashSet: 삽입 순서로 iteration될 수 있는 HashSet TreeMap: Tree를 사용하여 Map 구현 HashMap: Hash table을 이용해 Map 구현 LinkedHashMap: 삽입 순서로 iteration될 수 있는 HashMap 위의 클래스들의 구현 스타일(가로)과 인터페이스(세로)를 정리하면 다음과 같다. Interface Hash Table Resizable Array Balanced Tree Linked List Hash Table + Linked List Set HashSet   TreeSet   LinkedHashSet List   ArrayList   LinkedList   Deque   ArrayDeque   LinkedList   Map HashMap   TreeMap   LinkedHashMap Legacy 클래스들 Java Collection Framework의 Legacy 클래스들이 있다. 그것들은 다음과 같다. Vector: ArrayList과 유사. synchronized Stack: Vector를 이용한 LIFO 구현 Dictionary: key/value 저장(Map과 유사)하는 abstract class Hashtable: Dictionary의 구현 Properties: Hashtable의 subclass로 key/value 모두 String인 경우에 리스트를 관리 BitSet: Bit 값을 저장하는 특별한 유형의 array. 필요시 사이즈 증가 가능 2.3 Collection 알고리즘 java.util.Collection의 알고리즘을 담당하는 것이 Collections 클래스이다. 자세한 메소드는 여기를 참고하자. 2.4 Concurrent Collection들 2.4.1 인터페이스 Concurrent programming을 지원하기 위한 Concurrent Collection 인터페이스들은 별도로 정의되어 있다. BlockingQueue TransferQueue BlockingDeque ConcurrentMap ConcurrentNavigableMap 2.4.1 클래스 LinkedBlockingQueue ArrayBlockingQueue PriorityBlockingQueue DelayQueue SynchronousQueue LinkedBlockingDeque LinkedTransferQueue CopyOnWriteArrayList CopyOnWriteArraySet ConcurrentSkipListSet ConcurrentHashMap ConcurrentSkipListMap 3. 자료 구조 관점 계층 구조가 아닌 자료 구조 관점에서 설명을 해보자. Collection Framework이 제공하는 자료구조는 크게 다음과 같은 4가지로 구분할 수 있다. 순서가 있는 자료구조(List) 순서가 없고 중복이 안되는 집합 자료구조(Set) 검색이 용이하도록 key/value 쌍으로 저장하는 자료구조(Map) 정렬이 되어서 저장하는 특수한 자료구조(Sorted) 각 자료구조에 대해 살펴보자. 3.1 순서가 있는 자료 구조 (List) 순서가 있는 자료구조는 element의 중복을 허용하며 주로 선형 구조를 가진다. Collection Framework은 크게 다음 4가지의 Class를 가지고 있다. ArrayList: resizable array, synchronized 보장하지 않음 Vector: resizable array, synchronized 보장 LinkedList: linked list Stack: stack 3.1.1 ArrayList ArrayList의 특성은 다음과 같다. 동기화를 보장하지 않으며 동기화가 필요할 때는 Collections.synchronizeList() 메소드를 통해 동기화가 보장되는 List를 반환받아 사용한다. resizable하다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. boolean add(E e) void add(int index, E e) boolean remove(Object o) E remove(int index) E get(int index) E set(int index, E e) Object[] toArray() Note: Collection에서는 ArrayList가 메모리 크기의 잇점과 Cache 친화적이라는 점으로 인해 ArrayList가 LinkedList에 비해 훨씬 많이 쓰인다. 굳이 LinkedList를 사용할 필요가 거의 없다 3.1.2 Vector Vector의 특성은 다음과 같다. 동기화를 보장하는 resizable Array이다. ArrayList와 지원 메소드와 속성이 거의 동일하다. 동기화를 보장(Thread-safe)할 필요가 없는 경우 ArrayList를 추천하며, 심지어 동기화가 필요한 경우 조차도 ArrayList를 동기화 시켜 사용되기 때문에 이제 Vector는 자주 사용되지 않는 자료구조이다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. boolean add(E e) void add(int index, E e) boolean remove(Object o) E remove(int index) E get(int index) E set(int index, E e) Object[] toArray() ArrayList의 메소드와 동일함을 알 수 있다. 3.1.3 LinkedList LinkedList의 특성은 다음과 같다. 동기화를 보장하지 않으며 동기화가 필요할 때는 Collections.synchronizeList() 메소드를 통해 동기화가 보장되는 List를 반환받아 사용한다. ArrayList와 유사하지만, 선입 선출인 Queue와 양쪽 끝에서의 처리를 하는 Deque의 속성과 메소드를 가지고 있다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. boolean add(E e) void add(int index, E e) E get(int index) boolean remove(Object o) E remove(int index) E set(int index, E e) Object[] toArray() 위의 메소드는 ArrayList와 동일하며, 다음은 LinkedList만의 메소드이다. Queue 자료구조의 메소드는 기본적으로 tail에 넣고 front에서 뺀다. 그리고, offer()가 삽입하는 것, poll()이 빼는 것, peek()이 읽는 것이다. Deque 자료구조를 지원하기 위해 addFirst/Last, getFirst/Last, removeFirst/Last를 지원한다. LinkedList를 이용해서 deque로 사용할지, queue로 사용할지에 따라 적당한 메소드를 사용하면 된다. void addFirst(E e): front에 삽입 void addLast(E e): tail에 삽입 E getFirst(): front에서 읽기 E getLast(): tail에서 읽기 E removeFirst(): front에서 삭제 E removeLast(): tail에서 삭제 boolean offerFirst(E e): == addFirst() boolean offerLast(E e): == addLast() E pollFirst(): = removeFirst() E pollLast(): = removeLast() E peekFirst(): = getFirst() E peekLast(): = getLast() boolean offer(E e): = offerLast() E poll(): = pollFirst() E peek(): = peekFirst() 3.1.3 Stack Deque 인터페이스의 속성을 물려받아 메소드만 LIFO에 맞게 정의한 것이다. Stack의 특성은 다음과 같다. LIFO(후입 선출)을 지원 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. boolean empty() E push(E item): 삽입. E를 그대로 반환 E pop(): 제거 E peek(): 읽기 int search(Object o): 반환하는 값은 top부터의 거리를 의미. 만약 1을 반환하면 top. -1을 반환하면 없다는 것 3.2 순서가 없는 집합 자료 구조 (Set) 순서가 없는 자료구조는 element의 중복을 허용하지 않는 특성이 있다. 순서의 의미가 없으므로 index를 통해 접근하지 않는다. Collection Framework은 크게 다음의 Set Class를 가지고 있다. HashSet: Java Collection의 대표 Set 자료구조 Set 인터페이스를 상속한 SortedSet 인터페이스를 구현한 TreeSet TreeSet은 정렬을 하는 특수한 자료구조이므로 이후 별도로 다룬다. 3.2.1 HashSet HashSet은 Set자료구조이므로 가장 중요한 것은 자료구조안에 아이템이 있는 지 확인하는 것이다. 이는 contains() 메소드를 이용한다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. boolean empty() boolean add(E e) boolean contains(Object o): 존재하면 true boolean remove(Object o) HashSet을 순회하는 방법은 다음과 같다. iterator foreach Stream forEach 예는 다음과 같다. HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;1&quot;); set.add(&quot;2&quot;); set.add(&quot;3&quot;); /*iterator*/ Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext()){ System.out.println(it.next()); } /*foreach*/ for(String s: set){ System.out.println(s); } /*Stream*/ set.forEach(System.out::println); 출력은 다음과 같다. 입력과 상관없이 정렬되어 출력된다는 것을 알 수 있다. 하지만, 이 정렬을 믿고 코딩을 하면 안된다. 정렬이 필요하면 TreeSet을 사용하는 것이 좋다. 1 2 3 1 2 3 1 2 3 3.3 Key/Value 쌍으로 저장하는 자료 구조 (Map) Key를 이용해서 Value를 찾는 검색 기능을 제공하는 자료구조이다. Java는 크게 다음의 Map Class를 가지고 있다. HashMap: 동기화를 보장하지 않는 Java Collection Framework의 대표 Map Hashtable: 동기화를 보장 (Collection Framework이 아닌 Legacy Directory abstract class를 구현) Map 인터페이스를 상속한 SortedMap 인터페이스를 구현한 TreeMap TreeMap은 정렬을 하는 특수한 자료구조이므로 이후 별도로 다룬다. Hashtable은 동기화를 지원하기 때문에 상대적으로 HashMap에 비해 느리다. 그리고 HashMap을 필요한 경우에 동기화를 걸 수 있으므로 Hashtable은 자주 사용하지 않게 되었다. 3.3.1 HashMap HashMap은 Map자료구조이므로 key/value 쌍으로 데이터를 저장하고, 내부적으로 Hash기법을 구현하고 있다. 동기화가 필요한 경우 다음과 같이 사용할 수 있다. Map&lt;&gt;map = Collections.synchronizedMap(new HashMap&lt;&gt;()); 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. HashMap(int) : 초기 capacity 설정하며 생성 boolean isEmpty() boolean containsKey(Object key) boolean containsValue(Object value) V get(Object key): 만약 data가 없으면 null V getOrDefault(Object Key, V defaultValue): 만약 data가 없으면 default value를 반환 V put(K key, V value): 삽입 - 만약 이전에 존재하던 key가 있으면 덮어쓰고 이전 값을 반환. null을 반환하면 key가 없었던 것. V putIfAbsent(K key, V value): 만약 key가 존재하지 않으면 삽입. 만약 존재하지 않았다면 null 반환하고 아니면 이전 value 반환 V replace(K key, V value): 현재 key의 value를 대체. 만약 이전에 없었다면 null 반환(이전 value가 null일수도 있다) boolean replace(K key, V oldValue, V newValue): 만약 대체되면 true 반환 V remove(Object key) boolean remove(Object key, Object value) Set&lt;Map.Entry&lt;K,V» entrySet() : Set 자료구조로 반환 Set keySet() : key들만 모아서 Set 자료구조로 반환 Collection values(): value들만 Collection으로 반환 HashMap의 element를 순회하기 위해서는 Set으로 변환하거나 stream을 이용한다. Set으로 변환시 필요하다면 Key나 Value로만 Set을 구성할 수도 있다. 위의 entrySet(), KeySet(), values()을 참조하자. Map을 Set으로 변환 후 iterator로 순회 Map을 Set으로 변화하며 forEach로 순회 stream forEach 예는 다음과 같다. Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;k1&quot;, &quot;haha&quot;); map.put(&quot;k3&quot;, &quot;kaka&quot;); map.put(&quot;k2&quot;, &quot;nana&quot;); //Map --&gt; Set and iterator Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while(it.hasNext()){ Map.Entry&lt;String, String&gt; elem = it.next(); System.out.println(elem.getKey() + &quot;,&quot; + elem.getValue()); } //Map --&gt; Set and foreach for(Map.Entry&lt;String, String&gt; elem: map.entrySet()){ System.out.println(elem.getKey() + &quot;,&quot; + elem.getValue()); } //stream map.forEach((k, v)-&gt; System.out.println(k +&quot;,&quot;+v)); 출력은 다음과 같다. key를 기준으로 정렬되어 순회가 된다는 것을 알 수 있다. 하지만, 이 정렬을 믿고 코딩을 하면 안된다. 정렬이 필요하면 TreeMap을 사용하는 것이 좋다. k1,haha k2,nana k3,kaka k1,haha k2,nana k3,kaka k1,haha k2,nana k3,kaka 3.3.2 Hashtable Hashtable은 HashMap과 거의 동일하다. 그리고 Hashtable은 Collection framework의 Map 인터페이스가 아닌 Directory 추상 클래스를 구현하고 있다. 동기화를 기본으로 지원한다는 점이 다르다. 하지만, 이로 인해 일반적인 경우 성능 문제가 있어서 잘 사용하지 않는다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. 3.4 정렬된 자료 구조 (Sorted) 기존 데이터 구조에 정렬 속성을 추가한 자료 구조이다. 인터페이스로는 Set 인터페이스를 상속받은 SortedSet과 Map 인터페이스를 상속받은 SortedMap 인터페이스가 있다. 각각 TreeSet 클래스와 TreeMap 클래스로 구현되어 있다. 3.4.1 TreeSet data들이 자동으로 오름차순으로 정렬된다. 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. HashSet의 메소드와 동일한 메소드를 제공하며, 특별히 정렬된 순으로 순회가 유리한 메소드를 제공한다. Iterator iterator(): 오름순 Iterator descendingIterator(): 내림순 last(): 가장 큰 element first(): 가장 작은 element 사용예는 다음과 같다. TreeSet &lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); set.add(1); set.add(3); set.add(2); Iterator iterator = set.descendingIterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); //3 2 1 } System.out.println(set.first()); //1 System.out.println(set.last()); //3 Custom Comparator TreeSet에 custom comparator를 추가하는 것은 TreeSet 생성시 constructor에 comparator를 추가하면 된다. //Cup.java public class Cup { private final int size; public Cup(int size) { this.size = size; } int getSize(){ return this.size; } } 위와 같은 Cup Class의 객체들을 size에 따라 오름차순으로 정렬하고자 할 때 아래와 같이 하면 컴파일이 실패한다. Set&lt;Cup&gt; set = new TreeSet&lt;Cup&gt;(); set.add(new Cup(1)); set.add(new Cup(3)); set.add(new Cup(2)); set.forEach((c)-&gt;System.out.println(c.getSize())); 다음과 같이 constructor에 comparator를 Lambda로 추가하면 3 2 1로 출력이 된다. Set&lt;Cup&gt; set = new TreeSet&lt;Cup&gt;((c1, c2) -&gt; c2.getSize() - c1.getSize() ); HashSet -&gt; TreeSet HashSet을 TreeSet으로 변환하는 것은 다음과 같이 addAll()을 사용한다. Set&lt;String&gt; set = new HashSet&lt;String&gt;(); ... TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.addAll(set); 3.4.2 TreeMap data들이 Key를 기준으로 default로 오름차순으로 정렬된다. 동기화를 지원하지 않으면 동기화가 필요한 경우 다음과 같이 한다. SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…)); 주요 메소드는 다음과 같으며 자세한 API 사용법은 여기를 참고하자. HashMap의 메소드와 동일한 메소드를 제공한다. HashMap에서 살펴봤다시피 Map을 순회 하기 위해서는 Set으로 변환하는데, TreeMap은 특별히 정렬된 순서의 Set을 반환하는 메소드를 제공한다. Map.Entry&lt;K,V&gt; firstEntry(): 정렬된 entry중 가장 처음 것 반환. empty이면 null Map.Entry&lt;K,V&gt; lastEntry(): 정렬된 entry중 가장 마지막 것 반환. empty이면 null Map.Entry&lt;K,V&gt; pollFirstEntry():정렬된 entry중 가장 처음 entry 제거 Map.Entry&lt;K,V&gt; pollLastEntry(): 정렬된 entry중 가장 마지막 entry 제거 NavigableSet entrySet(): Set 반환 사용 예는 다음과 같다. TreeMap map = new TreeMap(); map.put(&quot;Zara&quot;, new Double(3434.34)); map.put(&quot;Mahnaz&quot;, new Double(123.22)); map.put(&quot;Ayan&quot;, new Double(1378.00)); Set set = map.entrySet(); Iterator i = set.iterator(); while(i.hasNext()) { Map.Entry entry = (Map.Entry)i.next(); System.out.println(entry.getKey() + &quot;,&quot; + entry.getValue()); } System.out.println(map.firstEntry().getKey()); System.out.println(map.lastEntry().getKey()); 결과는 다음과 같이 key순으로 순회할 수 있다. Ayan,1378.0 Mahnaz,123.22 Zara,3434.34 Ayan Zara Custom Comparator TreeMap에 custom comparator를 추가하는 것은 TreeMap 생성시 constructor에 comparator를 추가하면 된다. Cup Class의 객체를 Key로 하고 그 size에 따라 내림차순으로 정렬해보자. //Cup.java public class Cup { private final int size; public Cup(int size) { this.size = size; } int getSize(){ return this.size; } } constructor에 lambda로 comparator를 입력으로 준다. TreeMap&lt;Cup, Double&gt; map = new TreeMap&lt;Cup, Double&gt;((c1, c2)-&gt; c2.getSize()-c1.getSize()); map.put(new Cup(3), new Double(0.34)); map.put(new Cup(1), new Double(123.22)); map.put(new Cup(2), new Double(178.00)); map.forEach((k, v)-&gt; System.out.println(k.getSize() + &quot;,&quot; +v)); System.out.println(map.firstEntry().getKey().getSize()); System.out.println(map.lastEntry().getKey().getSize()); 결과는 다음과 같다. key를 내림차순으로 정렬했고, 이에 따라 firstEntry와 lastEntry도 역시 결정되었다. 3,0.34 2,178.0 1,123.22 3 1 key가 아닌 value 순으로 순회하기 Map 자료구조는 value순으로 정렬을 지원하지 않는다. 만약 Value 순 정렬이 반드시 필요하다면 key와 value의 쌍을 저장하고 정렬하는 TreeSet을 먼저 만든 뒤, map의 entry들을 TreeSet에 복수한 후 순회하는 방법을 사용한다 . TreeMap&lt;String, Double&gt; map = new TreeMap&lt;&gt;(); map.put(&quot;Zara&quot;, new Double(3434.34)); map.put(&quot;Mahnaz&quot;, new Double(123.22)); map.put(&quot;Ayan&quot;, new Double(1378.00)); Set &lt;Map.Entry&lt;String, Double&gt;&gt; set = new TreeSet&lt;Map.Entry&lt;String, Double&gt;&gt;( (e1, e2)-&gt;(e1.getValue().compareTo(e2.getValue())) ); set.addAll(map.entrySet()); for(Map.Entry&lt;String, Double&gt; entry: set){ System.out.println(entry.getKey() + &quot;,&quot; + entry.getValue()); } 결과는 다음과 같이 key가 아닌 value순으로 순회할 수 있다. Mahnaz,123.22 Ayan,1378.0 Zara,3434.34 Reference Java 8 API Java Collection Tutorial Collections Framework Overview Collection Framework – Class Hierarchy Collection Interface Difference Between Collection And Collections In Java",
    "url": "http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html",
    "relUrl": "/docs/java/2016-08-29-java-collection-framework.html"
  },
  "36": {
    "id": "36",
    "title": "Java - List 인터페이스",
    "content": "1. 개요 List 인터페이스는 순차적인 객체 집합들을 다루기 위한 Java Collection Framework의 인터페이스이다. Java Collection Framework의 최상위 인터페이스인 Collection 인터페이스를 상속한다. List 인터페이스에서 다루는 객체 집합의 속성은 다음과 같다. 0부터 시작하는 index에 의해 순서가 매겨진다. index를 통해 element를 접근할 수 있다. index를 통해 특정 위치에 element를 삽입하거나 제거할 수 있다. 이 경우 이후 element들의 index가 시프트된다. 중복 element가 존재할 수 있다. null element가 존재할 수 있다. List 인터페이스에서 추가된 주요 메소드는 다음과 같다. E get(int index) E set(int index, E e): 특정 index의 element를 대체 void add(int index, E e) E remove(int index): 특정 index의 element를 제거하며 반환 int indexOf(Object o): o와 일치하는 첫번째 element의 index를 반환 int lastIndexOf(Object o): o와 일치하는 마지막 element의 index반환 ListIterator listIterator(): List interator 획득 2. 구현 클래스 비교 List 인터페이스를 구현한 Array, LinkedList, Vector 클래스에 대해서 알아보자. 2.1 ArrayList 클래스 ArrayList는 크기가 가변 가능한 Array로서 구현된 클래스이다. 크기가 가변되는 점을 제외하고는 일반 Array와 동일하게 사용되어 질 수 있고 성능도 마찬가지이다. random access가 가능하므로 get()/set()의 성능이 좋은 반면 add()/remove()의 성능은 나쁘다. 2.2 LinkedList 클래스 LinkedList는 doubly linked list로서 구현된 클래스이다. List이므로 get()/set()에서의 성능이 좋지 못하다. 2.3 Vector 클래스(Legacy) java.util.Collection의 Legacy 클래스인 Vector는 ArrayList와 동일하다. 차이라면 Vector는 synchronized라는 것이다. 이로인해 ArrayList에 비해 성능적으로 불리하다. 많은 java 프로그래머들은 Vector대신 ArrayList를 사용하며, synchronized가 필요한 경우조차도 명시적으로 ArrayList를 synchronized하는 방법을 선호한다. 즉, Vector 클래스는 잘 사용되지 않는 클래스이다.",
    "url": "http://localhost:4000/docs/java/2016-08-30-java-collection-list.html",
    "relUrl": "/docs/java/2016-08-30-java-collection-list.html"
  },
  "37": {
    "id": "37",
    "title": "Java - ArrayList 클래스",
    "content": "1. 개요 ArrayList 클래스의 기본 초기 크기는 10이고, 10보다 더 커져야 하면 자동으로 증가된다. 또한 생성 시점에 크기를 명시할 수 있다. List 인터페이스 외에도 RandomAccess, Cloneable, Serializable 인터페이스를 구현한다. 2. ArrayList 클래스의 장점과 메소드들 Array와 비교하여 ArrayList의 장점이 무엇인지 살펴보자. 동적으로 크기가 변경된다. ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;ONE&quot;); list.add(&quot;TWO&quot;); System.out.println(list.size()); //2 list.remove(&quot;TWO&quot;); System.out.println(list.size()); //1 특정 위치에 element를 추가/삭제할 수 있다. Array는 이 경우 시프트를 해야 한다. ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;ONE&quot;); list.add(&quot;TWO&quot;); System.out.println(list); //[One, TWO] list.add(1, &quot;1.5&quot;); System.out.println(list); //[One, 1.5, TWO] list.remove(1); System.out.println(list); //[One, TWO] 다양한 메소드들을 지원한다. generic이 사용되지 않는다면, 다양한 타입의 객체를 저장할 수 있다. ArrayList list = new ArrayList(); list.add(&quot;ONE&quot;); list.add(2); list.add(new Float(3.0)); System.out.println(list); //[One, 2, 3.0] 크기 가변이 발생하는 삽입/삭제를 많이 할 경우 Array에 비해 성능이 나쁠 것이라고 생각하지만, 사실 그렇지 않다. 하나의 ListIterator를 사용하여 forward/backward 양방향 순회가 가능하다. ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;ONE&quot;); list.add(&quot;TWO&quot;); list.add(&quot;THREE&quot;); ListIterator iterator = list.listIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); //forward } while (iterator.hasPrevious()) { System.out.println(iterator.previous()); //backward } 여러 개의 null element를 저장할 수 있다. (Array도 가능한 부분) ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(null); list.add(null); System.out.println(list); //[100, null, null] 중복된 element를 저장할 수 있다. (Array도 가능한 부분) ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(100); list.add(100); System.out.println(list); //[100, 100, 100] 3. ArrayList와 Array간 변환 Array와 ArrayList는 Java에서 매우 많이 사용되어지는 자료구조이다. 이름은 유사하지만, 자료 구조의 특성이 다르기 때문에 변환하는 작업이 직관적이지는 않다. 3.1 Array를 ArrayList로 변환 많은 개발자가 Arrays.asList(array) 메소드를 사용해 array를 ArrayList로 변환한다. 하지만, 이 메소드는 가변적인 사이즈를 지원하는 ArrayList와 다른 클래스를 반환한다. 그러므로 다른 방법이 필요하다. 3.1.1 ArrayList 생성시 Arrays.asList() 메소드 사용 가장 많이 선호되는 방법이다. List&lt;&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); 예를 들어 Class의 instance를 저장한 array의 경우는 다음과 같이 쉽게 변환 가능하다. String [] array = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); System.out.println(list); //[one, two, three] int와 같은 primitive type의 경우는 안타깝게도 위와 같이 할 수 없다. 아래와 같이 하나씩 옮겨야 한다. int[] array = {1, 2, 3}; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i : array) { list.add(i); } System.out.println(list); //[1, 2, 3] 3.1.2 Collections.addAll() 메소드 사용 source와 destination을 일종의 복사를 하는 방식이다. 이 역시 안타깝데도 primitive type의 경우는 사용할 수 없다. Collections.addAll(list, array) String [] array = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, array); System.out.println(list); //[one, two, three] 3.1.3 List 인터페이스의 addAll() 메소드 사용 List의 addAll() 메소드를 사용하는 방식이다. 이 역시 안타깝데도 primitive type의 경우는 사용할 수 없다. list.addAll(Arrays.asList(array)) String [] array = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.addAll(Arrays.asList(array)); System.out.println(list); //[one, two, three] 3.1.4 Java 8의 Stream 사용하기 Java 8의 Stream에 대해서는 따로 정리된 내용을 확인하자. List list = Arrays.stream(array).collect(Collectors.toList()) 이 역시 안타깝데도 primitive type의 경우는 사용할 수 없다. String [] array = new String[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}; List&lt;String&gt; list = Arrays.stream(array).collect(Collectors.toList()); System.out.println(list); //[one, two, three] 3.2 ArrayList를 Array로 변환 아주 간단하다. Array를 크기에 맞게 생성 후 List 인터페이스의 toArray() 메소드를 사용해서 복사하면 된다. list.toArray(array) List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;one&quot;); list.add(&quot;two&quot;); list.add(&quot;three&quot;); String [] array = new String[list.size()]; list.toArray(array); for(String s: array){ System.out.println(s); } 결과는 다음과 같다. one two three 4. Reference Collection Framework – List Interface Advantages Of Using ArrayList Over Arrays Collection Framework – The ArrayList Class How To Remove Duplicate Elements From ArrayList In Java? Array To ArrayList And ArrayList To Array In Java With Examples",
    "url": "http://localhost:4000/docs/java/2016-08-31-java-arraylist.html",
    "relUrl": "/docs/java/2016-08-31-java-arraylist.html"
  },
  "38": {
    "id": "38",
    "title": "Java - LinkedList 클래스",
    "content": "1. 개요 java.util.LinkedList는 Serializable, Cloneable, Iterable, Collection, Deque, List, Queue과 같은 많은 인터페이스를 구현하고 있다. 특히 **List와 Deque 인터페이스의 doubly-linked list 구현**이다. 그래서 대부분의 성능은 doubly linked list의 성능을 따른다. 2. Deque 구현 Deque 인터페이스는 first와 last로 삽입/삭제하는 것을 모두 지원하기 때문에 조금 복잡하다. 3. LinkedList 클래스만의 메소드 - Queue와 Stack 자료 구조 지원 LinkedList는 이런 Deque 속성과 LinkedList를 모두 구현하며, 또한 스스로 Stack 자료구조와 Queue 자료구조를 지원하는 메소드를 제공하고 있다. 3.1 Queue 자료 구조를 위한 메소드 Queue는 알다시피 FIFO이다. 다음 Queue 메소드를 지원한다. offer(): Queue에 삽입 poll(): Queue에서 제거하며 읽기 peek(): Queue에서 제거하지 않고 읽기 예제는 다음과 같다. LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); list.offer(100); list.offer(200); list.offer(300); System.out.println(list); //[100, 200, 300] System.out.println(list.poll()); //100 System.out.println(list); //[200, 300] System.out.println(list.peek()); //200 System.out.println(list); //[200, 300] 3.2 Stack 자료 구조를 위한 메소드 Queue는 알다시피 LIFO이다. 다음 Stack 메소드를 지원한다. push(): Stack에 삽입 pop(): Stack에서 제거하며 읽기 peek(): Stack에서 제거하지 않고 읽기 예제는 다음과 같다. LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); list.push(100); list.push(200); list.push(300); System.out.println(list); //[300, 200, 100] System.out.println(list.pop()); //300 System.out.println(list); //[200, 100] System.out.println(list.peek()); //200 System.out.println(list); //[200, 100] 3. Reference Java 8 API 문서 Java LinkedList Programming Examples Collection Framework – The Deque Interface ArrayList Vs LinkedList In Java",
    "url": "http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html",
    "relUrl": "/docs/java/2016-08-31-java-linkedlist.html"
  },
  "39": {
    "id": "39",
    "title": "Java - Stream",
    "content": "functional programming을 지원하기 위한 Java 8의 핵심인 Stream에 대해 알아보자. java2s.com의 내용을 개인적으로 정리한 것이므로 자세한 내용은 해당 사이트를 참고하자. 1. 개요 1.1 정의 Java 8에서의 Stream의 정의는 다음과 같다 . “a sequence of elements from a source that supports aggregate operations.” Stream은 Collection 객체, Array, I/O로부터의 sequence 입력을 집합적으로 처리하기 위한 명령을 지원하는 프레임웍이라고 생각하자. 1.2 Stream과 Collection의 비교 아래의 Stream 특성이 Collection과 다른 점이다. Stream은 element를 저장하지 않고 필요할 때에만 처리된다. Stream operation들은 그 source 데이터를 바꾸지 않고, 결과를 저장한 새로운 stream을 반환할 뿐이다. Collection은 유한한 크기를 가지고 있으나 Stream은 그렇지 않다. limit()나 findFirst()등의 operation을 이용해 유한한 시간내에 처리할 수 있도록 지원한다. Stream은 한번 사용되고 버려진다. 1.3 Java Stream API Stream을 다루는 API는 java.util.stream package 안에 있다. Stream은 AutoCloseable interface를 상속한다. AutoCloseable | +--BaseStream | +--IntStream | +--LongStream | +--DoubleStream | +--Stream&lt;T&gt; 1.4 BaseStream BaseStream의 method는 다음과 같다. Iterator iterator(): Terminal operation, 스트림의 element를 순회 sequential(): intermediate operation, sequential 스트림을 반환 parallel(): intermediate operation, parallel 스트림을 반환 boolean isParallel(): parallel스트림 여부 반환 unordered(): intermediate operation, unordered 버전의 스트림을 반환 1.5 Optional 1.5.1 개요 Java8에서 소개된 java.util.Optional 클래스는 **NullPointerException**을 우아하게 다룰 수 있다. 만약 스트림 operation이 null을 반환해야 하는 경우, null이 아닌 Optional을 반환한다. isPresent(): null인지 아닌지 확인 get(): null이 아니라면 null이 아닌 value를 반환하고 null인 경우 NoSuchElementException을 던짐 결과가 primitive인 경우 Optional을 상속한 OptionalInt, OptionalLong, OptionalDouble 클래스를 사용할 수 있으며, 값은 get()이 아닌 getAsInt(), getAsLong(), getAsDouble()을 통해 Optional 객체로부터 primitive 값을 획득할 수 있다. 1.5.2 Optional 예제 1 Optional&lt;String&gt; str = Optional.of(&quot;hi&quot;); if (str.isPresent()) { System.out.println(str.get()); } else { System.out.println(&quot;Optional is empty.&quot;); } 결과는 다음과 같다. hi 1.5.3 Optional 예제 2 - primitive OptionalInt maxOdd = IntStream.of(10, 20, 30).filter(n -&gt; n % 2 == 1).max(); if (maxOdd.isPresent()) { int value = maxOdd.getAsInt(); System.out.println(&quot;Maximum odd integer is &quot; + value); } else { System.out.println(&quot;Stream is empty.&quot;); } 결과는 다음과 같다. Stream is empty. 2. Stream의 생성 Stream의 생성 방법은 다음과 같다. 2.1 값(value)로 부터 직접 Stream interface 중 of()를 사용하여 value로 부터 직접 Stream을 생성할 수 있다. &lt;T&gt; Stream&lt;T&gt; of(T t) //하나의 value &lt;T&gt; Stream&lt;T&gt; of(T...values) // multiple value 하나의 value로 부터 생성하는 것은 다음과 같다. Stream&lt;String&gt; stream = Stream.of(&quot;java2s.com&quot;); stream.forEach(System.out::println); multiple value로부터 생성하는 예는 다음과 같다. Stream&lt;String&gt; stream = Stream.of(&quot;XML&quot;, &quot;Java&quot;, &quot;CSS&quot;, &quot;SQL&quot;); stream.forEach(System.out::println); 2.2 Empty stream 빈 Stream을 생성한 후 값을 추가하여 Stream을 만들 수 있다. 2.2.1 Stream Builder 사용 Stream builder를 만든 후 값들을 추가 하는 것은 다음과 같다. Stream&lt;String&gt; stream = Stream.&lt;String&gt;builder() .add(&quot;XML&quot;) .add(&quot;Java&quot;) .add(&quot;CSS&quot;) .add(&quot;SQL&quot;) .build(); stream.forEach(System.out::println); // } 2.2.2 IntStream의 range() 사용 정수 스트림을 생성하는 IntStream 인터페이스의 range() method를 이용하여 Stream을 만들 수 있다. 그 예는 다음과 같다. IntStream oneToFive = IntStream.range(1, 6); // = IntStream oneToFive = IntStream.rangeClosed(1, 5); oneToFive.forEach(System.out::println); } InStream외에도 LongStream, DoubleStream 인터페이스가 있다. 2.2.3 Stream의 empty() method Stream&lt;String&gt; stream = Stream.empty(); stream.forEach(System.out::println); } 2.3 function을 이용한 생성 필요할 때 값들을 생성하는 function들을 가지고 있다. 이 function들을 이용하여 무한한 길이의 Stream 생성할 수 있다. &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f) //sequential ordered stream를 생성 &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) //sequential unordered stream을 생성 IntStream, LongStream, DoubleStream도 동일하게 iterate와 generate() function을 가지고 있다. 또한 Random class에서 제공하는 ints(), longs(), doubles()로 무한한 IntStream, LongStream, DoubleStream을 반환한다. 2.3.1 Stream.iterate() iterate()는 seed와 function을 인자로 가진다. seed는 스트림의 첫번째 element이다. 첫번째 element를 두번째 인자인 function에 집어넣어 스트림의 두번째 element를 만들어 낸다. 예를 들어 다음은 무한한 자연수의 스트림을 만드는 코드이다. Stream&lt;Long&gt; naturalNumbers = Stream.iterate(1L, n -&gt; n + 1); 무한한 길이이므로 주로 Intermediate operation 중 하나인 숫자 제한을 하는 limit(long maxSize)와 결합하여 사용한다. 그 예는 다음과 같다. Stream&lt;Long&gt; tenNaturalNumbers = Stream.iterate(1L, n -&gt; n + 1) .limit(10); //1 2 3 4 5 6 7 8 9 10 filter(), skip()과 결합하여 사용한 예는 다음과 같다. skip은 몇개를 건너 뛰느냐를 지정한다. Stream.iterate(2L, n -&gt; n + 1) .filter(x-&gt;x%2!=0) .skip(100) .limit(4) .forEach(System.out::println);//203 205 207 209 2.3.2 Stream.generate() ‘generate(Supplier s)&#39;는 supplier를 이용하여 무한한 sequential unordered 스트림을 생성한다. 예를 들어 다음과 같다. Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 출력은 다음과 같다. 0.28717330520043527 0.5642316709475632 0.24729530988007464 0.5199892875599263 0.9355928642452513 supplier는 다음과 같이 static method로 정의할 수 있다. public class Solution { public static void main(String[] args) { Stream.generate(Solution::next) .limit(5) .forEach(System.out::println); //1 2 3 4 5 } static int i = 0; private static int next(){ return ++i; } } Stream.generate()의 supplier로 Random::nextInt()를 사용할 수도 있다. Stream.generate(new Random()::nextInt) .limit(5) .forEach(System.out::println); 이때의 출력값은 다음과 같이 random값이다. 755239976 768110885 220701942 210236989 -649010462 2.3.3 Random class 이용 Random 클래스의 ints(), longs(), doubles()도 무한한 수의 sequence를 반환한다. 단, 그 값을 정의할 수는 없다. 그 예는 다음과 같다. new Random().ints() .limit(5) .forEach(System.out::println); 결과는 다음과 같이 random이다. 755239976 768110885 220701942 210236989 -649010462 2.4 Array로부터의 생성 다음과 같이 Arrays 클래스를 사용하여 Array에서 Stream을 생성할 수 있다. Stream&lt;String&gt; names = Arrays.stream(new String[] {&quot;XML&quot;, &quot;Java&quot;}); //or IntStream numbers = Arrays.stream(new int[]{1, 2, 3}); 2.5 Collection으로부터 생성 Collection 인터페이스는 stream()메소드와 parallelStream()메소드를 제공하고 있다. 이 메소드들을 이용해 스트림을 바로 생성할 수 있다. 그 예는 다음과 같다. Set&lt;String&gt; names = new HashSet&lt;&gt;(); names.add(&quot;XML&quot;); names.add(&quot;Java&quot;); names.stream().forEach(System.out::println); names.parallelStream().forEach(System.out::println); 2.6 String으로부터 생성 2.6.1 문자열 sequence로부터 String, StringBuffer, StringBuilder는 문자열 sequence를 반환하는 chars()를 가지고 있다. 이를 통해 스트림을 생성한다. 그 예는 다음과 같다. String str = &quot;5 123,123,qwe,1,123, 25&quot;; str.chars() .filter(n -&gt; !Character.isDigit((char)n) &amp;&amp; !Character.isWhitespace((char)n)) .forEach(n -&gt; System.out.print((char)n)); 출력결과는 다음과 같다. ,,qwe,,, 2.6.1 정규표현식(Regular expression)으로부터 java.util.regex.Pattern의 splitAsStream(CharSequence input) method는 String에서 패턴에 일치하는 것을 기준으로 자른 element들을 스트림으로 반환한다. 아래의 예는 다음과 같다. String str = &quot;XML,CSS,HTML&quot;; Pattern.compile(&quot;,&quot;) .splitAsStream(str) .forEach(System.out::println); 출력 예는 다음과 같다. XML CSS HTML 2.7 File로부터의 입력 Java 8은 File IO에서 Stream을 지원한다. 그리고, 파일을 close()함과 동시에 스트림도 멈추게 된다. 다음과 같다. Path path = Paths.get(&quot;./Solution.java&quot;); try (Stream&lt;String&gt; lines = Files.lines(path)) { lines.forEach(System.out::println); } catch (IOException e) { System.out.println(&quot;Can&#39;t open the file&quot;); } 다음음 directory로부터 stream을 가져오는 예이다. Path dir = Paths.get(&quot;.&quot;); System.out.printf(&quot;%nThe file tree for %s%n&quot;, dir.toAbsolutePath()); try (Stream&lt;Path&gt; fileTree = Files.walk(dir)) { fileTree.forEach(System.out::println); } catch (IOException e) { e.printStackTrace(); } 3 예제 설명을 위한 예제 코드 Intermediate 및 terminal operation을 설명하기 이전에 그 예제로 사용하기 위한 Employee class는 다음과 같다. id, name, gender, date, income을 attribute로 가지며 persons() 메소드를 이용해 persons List를 반환한다. import java.time.LocalDate; import java.time.Month; import java.util.Arrays; import java.util.List; class Employee { public static enum Gender { MALE, FEMALE } private long id; private String name; private Gender gender; private LocalDate dob; private double income; public Employee(long id, String name, Gender gender, LocalDate dob, double income) { this.id = id; this.name = name; this.gender = gender; this.dob = dob; this.income = income; } public long getId(){ return this.id; } public String getName() { return name; } public Gender getGender() { return gender; } public boolean isMale() { return this.gender == Gender.MALE; } public boolean isFemale() { return this.gender == Gender.FEMALE; } public double getIncome() { return income; } public void setIncome(double income) { this.income = income; } public static List&lt;Employee&gt; persons() { Employee p1 = new Employee(1, &quot;Jake&quot;, Gender.MALE, LocalDate.of(1971, Month.JANUARY, 1), 2343.0); Employee p2 = new Employee(2, &quot;Jack&quot;, Gender.MALE, LocalDate.of(1972, Month.JULY, 21), 7100.0); Employee p3 = new Employee(3, &quot;Jane&quot;, Gender.FEMALE, LocalDate.of(1973, Month.MAY, 29), 5455.0); Employee p4 = new Employee(4, &quot;Jode&quot;, Gender.MALE, LocalDate.of(1974, Month.OCTOBER, 16), 1800.0); Employee p5 = new Employee(5, &quot;Jeny&quot;, Gender.FEMALE, LocalDate.of(1975, Month.DECEMBER, 13), 1234.0); Employee p6 = new Employee(6, &quot;Jason&quot;, Gender.MALE, LocalDate.of(1976, Month.JUNE, 9), 3211.0); List&lt;Employee&gt; persons = Arrays.asList(p1, p2, p3, p4, p5, p6); return persons; } @Override public String toString() { String str = String.format(&quot;(%s, %s, %s, %s, %.2f) n&quot;, id, name, gender, dob, income); return str; } } 4 Intermediate(중간) operation 중간에서 스트림 입력을 받아 스트림을 출력으로 내는 operation들을 intermediate operation들이라고 한다. 그것들은 다음과 같다. peek(): debugging을 위한 액션 수행 filter(): 조건에 일치하는 element로만 구성된 스트림 반환 map(): 1 대 1 맵핑을 수행한 스트림 반환(예를 들어 element에서 특정 attribute만 뽑아서 스트림으로 만들기) distinct(): equals() 메소드를 확인하여 동일하지 않은 element로 구성된 스트림 반환 sorted(): 자연스러운 순서 또는 Comparator에 의해 정해진 순서에 따라 스트림을 정렬 skip(): 앞에서 n개까지를 제외한 스트림 반환 limit(): 앞에서부터 n개까지의 스트림 반환 flatMap(): 평탄화된 스트림 반환 4.1 peek() 4.1.1 개요 peek()는 debug 용으로 사용되며 스트림 파이프라인을 거쳐가는 element들을 프린트하는 목적으로 주로 사용된다. peek(Consumer&lt;? super T&gt; action) IntStream, LongStream, DoubleStream 모두 peek() 메소드를 제공한다. 4.1.2 예제 Employee.persons().stream() .peek(e -&gt; System.out.println(&quot;Original: &quot; + e.getName())) .filter(Employee::isFemale) .peek(e -&gt; System.out.println(&quot;Filtered: &quot; + e.getName())) .forEach(System.out::println); 이렇게 하면 출력은 다음과 같다. Original: Jake Original: Jack Original: Jane Filtered: Jane (3, Jane, FEMALE, 1973-05-29, 5455.00) Original: Jode Original: Jeny Filtered: Jeny (5, Jeny, FEMALE, 1975-12-13, 1234.00) Original: Jason 그런데 intermediate operation인 peek을 맨뒤 두면 어떤 일이 생길까? Employee.persons().stream() .peek(e -&gt; System.out.println(&quot;Original: &quot; + e.getName())) .filter(Employee::isFemale) .peek(e -&gt; System.out.println(&quot;Filtered: &quot; + e.getName())); 이렇게 하면 출력에 아무것도 찍히지 않게 된다. 중간의 “Original” … “ 도 나타나지 않는다. 4.2 filter() filter는 조건에 맞는 element로만 구성된 스트림을 반환한다. 그 예는 다음과 같다. Employee.persons() .stream() .filter(p-&gt;p.getIncome() &gt; 4000.0) .map(Employee::getName) .forEach(System.out::println); 위에서는 java lambda를 이용해 조건을 입력했고 결과는 다음과 같다. Jack Jane 4.3 map() 4.3.1 개요 map은 Stream의 element 각각에 함수를 적용한 결과로 구성된 스트림을 반환한다. 그러므로 입력 스트림과 출력 스트림의 element의 수는 같다. map은 다음과 같은 interface를 사용할 수 있다. &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper) DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper) IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper) LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper) 위의 메소드들은 IntStream, LongStream, DoubleStream도 모두 적용된다. 스트림에 sum(), max(), min()등을 수행하기 위해서는 숫자 type의 스트림인 경우 그대로 하고, 만약 숫자 type이 아닌 경우에는 mapToInt(), mapToLong(), mapToDouble()을 이용해 변환한 뒤에 해당 operation을 수행한다. 4.3.2 map() 예제 Employee.persons() .stream() .filter(p-&gt;p.getIncome() &lt; 4000.0) .map(p-&gt;p.getName()) .forEach(System.out::println); 출력은 다음과 같다. Jake Jode Jeny Jason 4.3.3 mapToDouble() 예제 double totalIncome = Employee.persons() .stream() .mapToDouble(Employee::getIncome) .sum(); System.out.println(&quot;Total Income: &quot; + totalIncome); 출력은 다음과 같다. 만약 그냥 map()으로 하면 compile error이다. Total Income: 21143.0 4.4 flatMap() 4.3.1 개요 map() operation은 1 대 1 mapping을 만드는데 반해 flatMap()은 1 대 n mapping을 지원한다. 즉, 한 개의 element입력을 받아 n개의 element를 만들 수 있다는 것이다. 4.3.2 예제 1 다음과 같이 Stream.of(1, 2, 3) .flatMap(n -&gt; Stream.of(n, n+1)) .forEach(System.out::println); 출력은 다음과 같다. 1 2 2 3 3 4 4.3.3 예제 2 다음과 같이 하는 것도 가능하다. 3개의 element를 받아서 각 element마다 0부터 끝까지의 길이를 Stream으로 만든 뒤에 이를 각각 charAt()을 이용해 각 위치의 character를 반환한 후 이를 mapToObj로 Typed primitive로 변환 후 출력한 것이다. 각 단계 별로 하나씩 진행하는 것이 아니라 각 element마다 병렬로 처리되는 것을 머리속에 그릴 수 있어야 할 것이다. Stream.of(&quot;XML&quot;, &quot;Java&quot;, &quot;CSS&quot;) .flatMap(str -&gt; IntStream.range(0, str.length()) .mapToObj(str::charAt)) .forEach(System.out::println); 출력은 다음과 같다. X M L J a v a C S S 4.5 sorted() 4.3.1 개요 unordered 스트림을 ordered 스트림으로 변환한다. 4.3.2 예제 1 다음과 같이 List&lt;Integer&gt; numbers = Arrays.asList(3,7,9,3,1,2,1, 2, 3, 4, 5); numbers.stream() .filter(n -&gt; n % 2 == 1) .sorted() .forEach(System.out::println); 결과는 1 1 3 3 3 5 7 9 5. Terminal operation stream을 입력으로 받아 결과를 내는 operation들을 terminal operation들이라고 한다. 그것들은 다음과 같다. forEach: 스트밍의 각 element에 액션 수행 toArray: 스트림을 Array로 변환하여 반환 collect: 스트림을 Collection으로 변환하여 반환 reduce: 스트림으로부터 하나의 값을 얻기 위한 reduction operation을 수행 count: element의 갯수 반환 max: 가장 큰 element 반환 min: 가장 작은 element 반환 findFirst: 스트림의 첫번째 element 반환 findAny: 스트림 중 하나의 element 반환(empty이면 Optional object 반환) anyMatch: 만약 하나의 element라도 정해진 조건을 만족하면 true반환(empty이면 false 반환) allMatch: 만약 모든 element가 정해진 조건을 만족하면 true 반환(empty라도 true) noneMatch: 만약 모든 element가 정해진 조건을 만족하지 않으면 false 반환(empty이면 true) 5.1 forEach() 5.1.1 개요 forEach는 각 element에 대해 액션을 수행하는 operation이다. forEach()는 스트밍의 입력에 대한 처리 순서를 약속하지 않는다. void forEach(Consumer&lt;? super T&gt; action) 처리 순서에 대한 확신을 갖기 위해서는 forEachOrdered를 사용해야 한다. 대신 parallel stream에서는 성능이 떨어진다. void forEachOrdered(Consumer&lt;? super T&gt; action) IntStream, LongStream, DoubleStream 모두 동일한 메소드를 제공한다. 5.1.2 예제 아래와 같이 forEach이용해 하나씩 출력할 수 있다. Employee.persons() .stream() .filter(Employee::isFemale) .forEach(System.out::println); 결과는 다음과 같다. (3, Jane, FEMALE, 1973-05-29, 5455.00) (5, Jeny, FEMALE, 1975-12-13, 1234.00) 5.2 reduce() 5.2.1 개요 reduce는 스트림의 모든 element들을 하나의 값으로 변환하는 것이다. 이것은 두 개의 인자를 가지는데 첫번째는 seed이고 두번째는 accumulator function이다. 만약 스트림이 empty이면 seed가 결과가 된다. accumulator는 2개의 인자를 가진다. seed와 첫번째 element가 accumlator의 입력으로 들어가고, 결과가 반환되면 다시 그 결과와 다음 element가 accumulator의 입력으로 다시 들어가고 이런 식으로 마지막 element까지 반복한다. reduce method는 다음과 같이 정의된다. T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) reduce() operation이 병렬로 처리될 때 combiner를 이용해서 중간 값들을 묶을 수 있다. 즉, 병렬 처리시를 위한 특별한 reduce()는 다음과 같다. 자세한 내용은 예제(5.2.4) 를 살펴보자. &lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner) 5.2.2 간단한 예 아래와 같이 reduce 이용해 총합을 만들어 낼 수 있다. List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .reduce(0, Integer::sum); System.out.println(sum); //15 5.2.3 예제 위의 예를 참고해서 모든 employee의 income의 합을 계산해 보자. double sum = Employee.persons() .stream() .map(Employee::getIncome) .reduce(0.0, Double::sum); System.out.println(sum); //21143.0 5.2.4 병렬 연산 예 모든 employee의 income의 합을 병렬로 계산하는 예는 다음과 같다. double sum = Employee.persons() .stream() .reduce(0.0, (partialSum, person) -&gt; partialSum + person.getIncome(), Double::sum); System.out.println(sum); //21143.0 5.2.4 복잡한 병렬 연산의 예 - thread 이제 매우 복잡한 병렬 reduce()의 예를 살펴보자. stream()의 경우 main thread 하나를 이용함을 알 수 있다. 하지만, parallelStream()를 이용해 stream을 만드는 경우 Thread.currentThread().getName()로 출력해보면 thread가 여러개 사용되고 있음을 알 수 있다. double sum = Employee.persons().stream() .reduce( 0.0, (Double partialSum, Employee p) -&gt; { double accumulated = partialSum + p.getIncome(); System.out.println(Thread.currentThread().getName() + &quot; - Accumulator: partialSum = &quot; + partialSum + &quot;, person = &quot; + p + &quot;, accumulated = &quot; + accumulated); return accumulated; }, (a, b) -&gt; { double combined = a + b; System.out.println(Thread.currentThread().getName() + &quot; - Combiner: a = &quot; + a + &quot;, b = &quot; + b + &quot;, combined = &quot; + combined); return combined; }); System.out.println(&quot;--&quot;); System.out.println(sum); sum = Employee.persons().parallelStream() .reduce( 0.0, (Double partialSum, Employee p) -&gt; { double accumulated = partialSum + p.getIncome(); System.out.println(Thread.currentThread().getName() + &quot; - Accumulator: partialSum = &quot; + partialSum + &quot;, person = &quot; + p + &quot;, accumulated = &quot; + accumulated); return accumulated; }, (a, b) -&gt; { double combined = a + b; System.out.println(Thread.currentThread().getName() + &quot; - Combiner: a = &quot; + a + &quot;, b = &quot; + b + &quot;, combined = &quot; + combined); return combined; }); System.out.println(sum); 출력은 다음과 같다. main - Accumulator: partialSum = 0.0, person = (1, Jake, MALE, 1971-01-01, 2343.00) , accumulated = 2343.0 main - Accumulator: partialSum = 2343.0, person = (2, Jack, MALE, 1972-07-21, 7100.00) , accumulated = 9443.0 main - Accumulator: partialSum = 9443.0, person = (3, Jane, FEMALE, 1973-05-29, 5455.00) , accumulated = 14898.0 main - Accumulator: partialSum = 14898.0, person = (4, Jode, MALE, 1974-10-16, 1800.00) , accumulated = 16698.0 main - Accumulator: partialSum = 16698.0, person = (5, Jeny, FEMALE, 1975-12-13, 1234.00) , accumulated = 17932.0 main - Accumulator: partialSum = 17932.0, person = (6, Jason, MALE, 1976-06-09, 3211.00) , accumulated = 21143.0 -- 21143.0 main - Accumulator: partialSum = 0.0, person = (4, Jode, MALE, 1974-10-16, 1800.00) , accumulated = 1800.0 ForkJoinPool.commonPool-worker-3 - Accumulator: partialSum = 0.0, person = (1, Jake, MALE, 1971-01-01, 2343.00) , accumulated = 2343.0 main - Accumulator: partialSum = 0.0, person = (5, Jeny, FEMALE, 1975-12-13, 1234.00) , accumulated = 1234.0 ForkJoinPool.commonPool-worker-2 - Accumulator: partialSum = 0.0, person = (6, Jason, MALE, 1976-06-09, 3211.00) , accumulated = 3211.0 ForkJoinPool.commonPool-worker-1 - Accumulator: partialSum = 0.0, person = (2, Jack, MALE, 1972-07-21, 7100.00) , accumulated = 7100.0 ForkJoinPool.commonPool-worker-2 - Combiner: a = 1234.0, b = 3211.0, combined = 4445.0 ForkJoinPool.commonPool-worker-2 - Combiner: a = 1800.0, b = 4445.0, combined = 6245.0 ForkJoinPool.commonPool-worker-3 - Accumulator: partialSum = 0.0, person = (3, Jane, FEMALE, 1973-05-29, 5455.00) , accumulated = 5455.0 ForkJoinPool.commonPool-worker-3 - Combiner: a = 7100.0, b = 5455.0, combined = 12555.0 ForkJoinPool.commonPool-worker-3 - Combiner: a = 2343.0, b = 12555.0, combined = 14898.0 ForkJoinPool.commonPool-worker-3 - Combiner: a = 14898.0, b = 6245.0, combined = 21143.0 21143.0 5.3 seed 값 없는 reduce() 5.3.1 개요 seed가 없이 reduce()를 수행하는 것은 위에서 본 sum과 같은 accumulator가 아닌 max나 min값을 찾는 경우에는 가능하다. reduce(BinaryOperator accumulator) 결과값이 없을 수도 있으므로 반환은 Optional&lt;T&gt; type으로 받아서 isPresent()를 이용해 확인한다. 자세한 내용은 아래 예제를 참고로 하자. 5.3.2 간단 예제 Optional&lt;Integer&gt; max = Stream.of(1, 2, 3, 4, 5).reduce(Integer::max); if (max.isPresent()) { System.out.println(&quot;max = &quot; + max.get()); } else { System.out.println(&quot;max is not defined.&quot;); } max = Stream.&lt;Integer&gt; empty().reduce(Integer::max); if (max.isPresent()) { System.out.println(&quot;max = &quot; + max.get()); } else { System.out.println(&quot;max is not defined.&quot;); } 출력은 다음과 같다. max = 5 max is not defined. 5.3.3 예제 Employee 중에 가장 많은 income인 것을 찾는 것은 다음과 같다. Optional&lt;Employee&gt; person = Employee .persons() .stream() .reduce((p1, p2) -&gt; p1.getIncome() &gt; p2.getIncome() ? p1 : p2); if (person.isPresent()) { System.out.println(&quot;Highest earner: &quot; + person.get()); } else { System.out.println(&quot;Could not get the highest earner.&quot;); } 출력은 다음과 같다. Highest earner: (2, Jack, MALE, 1972-07-21, 7100.00) 5.4 sum() 5.4.1 개요 sum()을 적용하기 위해서는 숫자 type의 스트림인 경우 그대로 하고, 만약 숫자 type이 아닌 경우에는 mapToInt(), mapToLong(), mapToDouble()을 이용해 변환한 뒤에 sum()을 한다. 5.4.2 예제 double totalIncome = Employee.persons() .stream() .mapToDouble(Employee::getIncome) .sum(); System.out.println(&quot;Total Income: &quot; + totalIncome); 출력은 다음과 같다. 만약 그냥 map()으로 하면 compile error이다. Total Income: 21143.0 5.5 max()와 min() 5.5.1 개요 max()와 min()이 없을 수도 있으므로 seed 값 없는 reduce()와 동일하게 반환은 Optional&lt;T&gt; type으로 받아서 isPresent()를 이용해 확인한다. max()와 min()의 인자는 Comparator이거나, 숫자 스트림의 경우는 인자가 없어도 된다. 예를 들어 다음 두 가지는 동일하게 유효하다. OptionalInt optionalInt = Stream.of(1, 1, 1, 1, 1).mapToInt(i-&gt;i).max(); if (optionalInt.isPresent()) { System.out.println(optionalInt.getAsInt()); } else { System.out.println(&quot;Could not get the max.&quot;); } OptionalInt optionalInt = IntStream.of(1, 1, 1, 1, 1).max(); if (optionalInt.isPresent()) { System.out.println(optionalInt.getAsInt()); } else { System.out.println(&quot;Could not get the max.&quot;); } 위의 두 결과 모두 1이다. 5.5.2 max() 예제 다음과 같이 Optional로 반환받은 객체에 접근할 때는 get() method를 통해 접근한다. Optional&lt;Employee&gt; maxIncomeEmployee = Employee.persons().stream() .max(Comparator.comparingDouble(Employee::getIncome)); if (maxIncomeEmployee.isPresent()) { System.out.println(&quot;Highest earner: &quot; + maxIncomeEmployee.get().getIncome()); } else { System.out.println(&quot;Could not get the highest earner.&quot;); } 출력은 다음과 같다. Highest earner: 7100.0 max() operation이전에 numeric으로 변환하는 것도 가능하다. 다음 코드를 사용하면 동일한 결과를 얻는다. OptionalDouble income = Employee.persons() .stream() .mapToDouble(Employee::getIncome).max(); if (income.isPresent()) { System.out.println(&quot;Highest income: &quot; + income.getAsDouble()); } else { System.out.println(&quot;Could not get the highest income.&quot;); } 5.6 count() 5.6.1 개요 count()는 스트림의 element 숫자를 반환한다. type은 long이다. 5.6.2 예제 long personCount = Employee.persons().stream().count(); System.out.println(&quot;Person count: &quot; + personCount); 출력은 다음과 같다. Person count: 6 5.7 collect() 5.7.1 개요 collect()는 스트림의 데이터를 그룹화 할 수 있다. collect() 정의는 다음과 같다. &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner) &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector) supplier: 결과를 저장할 mutable container(Collection) accumulator: mutable container에 결과를 쌓을 함수 combiner: 병렬 연산시 부분 결과를 모으는 함수 설명이 어려운데 예를 들어 다음의 예를 생각해보자. 우리가 다루고 있는 예제의 Employee의 이름만 따로 저장한 ArrayList 자료구조를 Stream에서 반환하고자 한다. map은 결과물이 역시 Stream이기 때문에 적당하지 않고, 이럴때 사용할만한 것이 collect()이다. 첫번째 인자가 바로 ArrayList, 두번째가 ArrayList에 Employee의 이름을 추가하는 동작, 세번째 인자가 병렬 연산시 통째로 ArrayList를 다른 ArrayList 뒤에 붙이는 연산이다. List&lt;String&gt; names = Employee.persons() .stream() .map(Employee::getName) .collect(ArrayList::new, ArrayList::add, ArrayList::addAll); System.out.println(names); 첫번째 ArrayList::new 대신 () -&gt; new ArrayList&lt;&gt;()`로 해도 된다. List&lt;String&gt; names = Employee.persons() .stream() .map(Employee::getName) .collect(()-&gt;new ArrayList&lt;&gt;(), ArrayList::add, ArrayList::addAll); System.out.println(names); 결과는 다음과 같다. [Jake, Jack, Jane, Jode, Jeny, Jason] 5.7.2 Collectors interface collect()는 Collectors interface를 argument로 받을 수 있다. 이렇게 하면 위와 같이 복잡하게 supplier, accumulator를 정하는 것이 아니라 쉽게 Collection으로 변경 가능다. Collectors interface는 다음과 같다. Collectors.toList() Collectors.toSet() Collectors.toCollection() 사용 예는 다음과 같다. Set&lt;String&gt; uniqueNames = Person.persons() .stream() .map(Person::getName) .collect(Collectors.toSet()); System.out.println(uniqueNames); 5.7.3 예제 Employee의 name을 기준으로 sorting한 결과를 출력하는 것을 구현해보자. 만약 같은 이름이 여러 개 있는 경우에는 한번만 출력하도록 한다. SortedSet&lt;String&gt; uniqueSortedNames= Employee.persons() .stream() .map(Employee::getName) .collect(Collectors.toCollection(TreeSet::new)); System.out.println(uniqueSortedNames); 출력은 다음과 같다. [Jack, Jake, Jane, Jason, Jeny, Jode] 5.8 collect()와 Statistics 5.8.1 java.util의 Statistics class들 숫자 데이터의 통계를 낼때 java.util에서 제공하는 다음의 class들을 사용할 수 있다. Statistics 클래스들은 마치 Collection과 같은 역할을 한다. DoubleSummaryStatistics LongSummaryStatistics IntSummaryStatistics 사용방법은 Statistics 객체를 생성 후 accept() method로 값을 추가한 후, getCount(), getSum(), getMin(), getAverage(), getMax() 메소드를 이용해 원하는 값을 얻는 것이다. 다음은 그 예이다. DoubleSummaryStatistics stats = new DoubleSummaryStatistics(); stats.accept(100.0); stats.accept(300.0); long count = stats.getCount(); double sum = stats.getSum(); double min = stats.getMin(); double avg = stats.getAverage(); double max = stats.getMax(); System.out.printf( &quot;count=%d, sum=%.2f, min=%.2f, average=%.2f, max=%.2f%n&quot;, count, sum, min, max, avg); 결과는 다음과 같다. count=2, sum=400.00, min=100.00, average=300.00, max=200.00 5.8.1 스트림에서의 Statistics 사용 5.8.1.1 collect()와 supplier, accumulator, combiner 위에서 확인했다시피 Statistics는 Collection과 유사하기에 collect()에서 Collection의 supplier, accumulator를 등록해서 사용하는 것과 거의 동일하게 쓸 수 있다. 그리고, 병렬 연산을 위해 Statistics는 combine() 메소드를 제공한다. 다음은 그 사용 예이다. DoubleSummaryStatistics incomeStats = Employee.persons() .stream() .map(Employee::getIncome) .collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine); System.out.println(incomeStats); 결과는 다음과 같다. DoubleSummaryStatistics{count=6, sum=21143.000000, min=1234.000000, average=3523.833333, max=7100.000000} 5.8.1.2 Collectors interface Collectors는 숫자 연산을 위해 다음과 같은 method들을 제공하고 있다. 이를 이용해 Stream에서 바로 값을 획득할 수 있다. Collectors.counting() Collectors.maxBy() Collectors.minBy() Collectors.summarizingInt() Collectors.summingInt() Collectors.averagingInt() Collectors.summarizingLong() Collectors.summingLong() Collectors.averagingLong() Collectors.summarizingDouble() Collectors.summingDouble() Collectors.averagingDouble() 다음은 그 사용 예이다. DoubleSummaryStatistics incomeStats = Employee.persons() .stream() .collect(Collectors.summarizingDouble(Employee::getIncome)); System.out.println(incomeStats); 결과는 다음과 같다. DoubleSummaryStatistics{count=6, sum=21143.000000, min=1234.000000, average=3523.833333, max=7100.000000} 5.9 collect() 사용한 스트림의 Map 변환 5.9.1 개요 collect()를 이용해 Collection으로 변경하는 것의 한 종류는 Map을 변경하는 것이다. 스트림의 element에서 key와 value를 추출하는 function을 등록하여 Map으로 변환한다. 만약 중복된 key값이 있다면 IllegalStateException exception이 발생된다. 아래에서 keyMapper는 key를 추출하는 function, valuemapper는 value를 추출하는 function이다. toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper) 추가적으로 merge function을 제공할 수 있다. 이것은 중복된 key가 있는 경우 어떻게 처리할 지를 결정하는 function으로 argument는 old value와 new value이고 반환 값은 merge된 value이다. toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction) 또한 Supplier를 통해 Map 5.9.2 예제 1 Map&lt;Long,String&gt; idToNameMap = Employee.persons() .stream() .collect(Collectors.toMap(Employee::getId, Employee::getName)); System.out.println(idToNameMap); 결과는 {1=Jake, 2=Jack, 3=Jane, 4=Jode, 5=Jeny, 6=Jason} 5.9.3 예제 2 - merge function 일부러 중복된 key를 택해보자. gender를 key로 하고, 각 gender의 해당하는 이름을 ,를 경계로 출력하는 것을 해보자. Map&lt;Employee.Gender,String&gt; genderToNamesMap = Employee.persons() .stream() .collect(Collectors.toMap(Employee::getGender, Employee::getName, (oldValue, newValue) -&gt; String.join(&quot;, &quot;, oldValue, newValue))); System.out.println(genderToNamesMap); 결과는 {FEMALE=Jane, Jeny, MALE=Jake, Jack, Jode, Jason} 5.9.4 예제 3 - merge function gender를 key로 하고, 각 gender의 해당하는 Employee의 숫자를 출력하는 것을 해보자. Map&lt;Employee.Gender, Long&gt; countByGender = Employee.persons() .stream() .collect(Collectors.toMap(Employee::getGender, p -&gt; 1L, (oldCount, newCount) -&gt; newCount+oldCount)); System.out.println(countByGender); 결과는 {FEMALE=2, MALE=4} 5.9.5 예제 4 - merge function gender를 key로 하고, 각 gender별로 가장 수입이 놓은 사람의 정보를 출력하도록 해보자. Map&lt;Employee.Gender, Employee&gt; highestEarnerByGender = Employee.persons() .stream() .collect(Collectors.toMap(Employee::getGender, Function.identity(), (oldPerson, newPerson) -&gt; newPerson.getIncome() &gt; oldPerson.getIncome() ? newPerson : oldPerson)); System.out.println(highestEarnerByGender); 결과는 {FEMALE=(3, Jane, FEMALE, 1973-05-29, 5455.00) , MALE=(2, Jack, MALE, 1972-07-21, 7100.00) } 5.10 collect()와 joining() 5.10.1 개요 Collectors.joining()은 CharSequence 스트림에서 character들을 모아서 String으로 반환한다. Collectors.joining(): 모든 element를 모음 Collectors.joining(CharSequence delimiter): delimiter를 element 사이에 넣어서 모음 Collectors.joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix): prefix와 suffix를 String의 맨 앞과 뒤에 추가 5.10.2 예제 List&lt;Employee&gt; persons = Employee.persons(); String names = persons.stream() .map(Employee::getName) .collect(Collectors.joining()); System.out.println(names); //JakeJackJaneJodeJenyJason String delimitedNames = persons.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;, &quot;)); System.out.println(delimitedNames); //Jake, Jack, Jane, Jode, Jeny, Jason String prefixedNames = persons.stream() .map(Employee::getName) .collect(Collectors.joining(&quot;, &quot;, &quot;Hello &quot;, &quot;. Goodbye.&quot;)); System.out.println(prefixedNames); //Hello Jake, Jack, Jane, Jode, Jeny, Jason. Goodbye. 5.11 collect()와 groupingBy() 5.11.1 개요 Collectors.groupingBy()는 같은 속성을 가진 group으로 Map을 만든다. 함수의 정의는 다음과 같다. groupingBy(Function&lt;? super T,? extends K&gt; classifier) groupingBy(Function&lt;? super T,? extends K&gt; classifier, Collector&lt;? super T,A,D&gt; downstream) classifier function: map의 key를 만드는 function downstream function: 모여진 group에 대해 수행할 function으로 value를 만든다. 5.11.2 예제 1 gender를 key로 하고, 각 gender별로 숫자 출력하자. toMap()을 이용한 5.9.4 예제 3과 동일하다. Map&lt;Employee.Gender, Long&gt; countByGender = Employee.persons() .stream() .collect(Collectors.groupingBy(Employee::getGender, Collectors.counting())); System.out.println(countByGender); 결과는 {MALE=4, FEMALE=2} 5.11.3 예제 2 gender를 key로 하고, 각 gender별로 사람 이름을 ,로 구분하여 출력하자. toMap()을 이용한 5.9.3 예제 2와 동일하다. Map&lt;Employee.Gender, String&gt; namesByGender = Employee.persons() .stream() .collect(Collectors.groupingBy(Employee::getGender, Collectors.mapping(Employee::getName, Collectors.joining(&quot;, &quot;)))); System.out.println(namesByGender); 결과는 {MALE=Jake, Jack, Jode, Jason, FEMALE=Jane, Jeny} 5.11.4 예제 3 gender를 key로 하고, 각 gender별로 사람이름을 List에 저장하자. Map&lt;Employee.Gender, List&lt;String&gt;&gt; namesByGender = Employee.persons() .stream() .collect(Collectors.groupingBy(Employee::getGender, Collectors.mapping(Employee::getName, Collectors.toList()))); System.out.println(namesByGender); 결과는 {FEMALE=[Jane, Jeny], MALE=[Jake, Jack, Jode, Jason]} 5.12 collect()와 partitioningBy() 5.12.1 개요 Collectors.partitioningBy()는 특별한 경우의 grouping이다. groupingBy()가 키를 기준으로 여러개의 group을 가질 수 있다면 partitioningBy()는 조건문을 기준으로 만족하는 것과 아닌 것, 두 개의 group만 가진다. 생성되는 Map의 키는 이로 인해 boolean 타입만이 가능하다. partitioningBy(Predicate&lt;? super T&gt; predicate) partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T,A,D&gt; downstream) 5.12.2 예제 1 gender를 기준으로 나누는 것의 예는 다음과 같다. Map&lt;Boolean, List&lt;Employee&gt;&gt; partionedByMaleGender = Employee.persons() .stream() .collect(Collectors.partitioningBy(Employee::isMale)); System.out.println(partionedByMaleGender); 결과는 {false=[(3, Jane, FEMALE, 1973-05-29, 5455.00) , (5, Jeny, FEMALE, 1975-12-13, 1234.00) ], true=[(1, Jake, MALE, 1971-01-01, 2343.00) , (2, Jack, MALE, 1972-07-21, 7100.00) , (4, Jode, MALE, 1974-10-16, 1800.00) , (6, Jason, MALE, 1976-06-09, 3211.00) ]} 5.12.3 예제 2 gender를 기준으로 나누고 downstream function을 이용해 reduction operation을 수행하는 예이다. Map&lt;Boolean,String&gt; partionedByMaleGender = Employee.persons() .stream() .collect(Collectors.partitioningBy(Employee::isMale, Collectors.mapping(Employee::getName, Collectors.joining(&quot;, &quot;)))); System.out.println(partionedByMaleGender); 결과는 {false=Jane, Jeny, true=Jake, Jack, Jode, Jason} 5.13 collect()와 collectingAndThen() 5.13.1 개요 Collector의 결과를 다른 type으로 변환할 때 Collectors.collectingAndThen()를 사용한다. Collectors.toList(), Collectors.toSet(), Collectors.toCollection()와의 차이는 finisher function을 이용해 결과를 다시 한번 변환할 수 있다는 것이다. collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 5.13.2 예제 다음은 List로 변환된 스트림을 다시 unmodifiableList로 변환한 예이다. List&lt;String&gt; names = Employee.persons() .stream() .map(Employee::getName) .collect(Collectors.collectingAndThen(Collectors.toList(), result -&gt; Collections.unmodifiableList(result))); System.out.println(names); 결과는 다음과 같다. [Jake, Jack, Jane, Jode, Jeny, Jason] 5.14 findAny()와 findFirst() 5.14.1 개요 findAny()는 스트림의 element가 있으면 반환하는 것으로 주로 filter()와 함께 사용된다. findFirst()는 스트림에서 첫번째로 일치하는 element를 반환한다. 이 두 operation 모두 short-circuiting operation으로 전체 스트림에 대해 처리할 필요없이 결과를 바로 반환한다. Optional&lt;T&gt; findAny() Optional&lt;T&gt; findFirst() 반환 type은 Optional&lt;T&gt;이다. primitive type 스트림인 IntStream, LongStream, DoubleStream에서도 동일한 operation을 제공한다. 5.14.2 findAny() 예제 List&lt;Employee&gt; persons = Employee.persons(); Optional&lt;Employee&gt; anyMale = persons.stream().filter(Employee::isMale).findAny(); if (anyMale.isPresent()) { System.out.println(anyMale.get()); } else { System.out.println(&quot;No male found.&quot;); } 결과는 다음과 같다. (1, Jake, MALE, 1971-01-01, 2343.00) 5.14.3 findFirst() 예제 List&lt;Employee&gt; persons = Employee.persons(); Optional&lt;Employee&gt; firstMale = persons.stream().filter(Employee::isMale).findFirst(); if (firstMale.isPresent()) { System.out.println(firstMale.get()); } else { System.out.println(&quot;No male found.&quot;); } 결과는 다음과 같다. (1, Jake, MALE, 1971-01-01, 2343.00) 5.15 allMatch(), anyMatch(), noneMatch() 5.15.1 개요 allMatch()는 스트림의 element가 모두 조건을 만족하면 반환 true를 반환한다. anyMatch()는 스트림에서 하나라도 조건을 만족하면 true를 반환한다. noneMatch()은 모든 element가 조건을 만족하지 않으면 true를 반환한다. 이 세 operation 모두 short-circuiting operation으로 전체 스트림에 대해 처리할 필요없이 결과를 바로 반환할 수 있다. boolean allMatch(Predicate&lt;? super T&gt; predicate) boolean anyMatch(Predicate&lt;? super T&gt; predicate) boolean noneMatch(Predicate&lt;? super T&gt; predicate) primitive type 스트림인 IntStream, LongStream, DoubleStream에서도 동일한 operation을 제공한다. 5.15.2 allMatch() 예제 List&lt;Employee&gt; persons = Employee.persons(); boolean allMales = persons.stream().allMatch(Employee::isMale); System.out.println(&quot;All males: &quot; + allMales); System.out.println(&quot;No male found.&quot;); } 결과는 다음과 같다. All males: false 5.15.3 anyMatch() 예제 List&lt;Employee&gt; persons = Employee.persons(); boolean anyoneEarnsOver5000 = persons.stream().anyMatch(p -&gt; p.getIncome() &gt; 5000); System.out.println(&quot;Anyone earns over 5000: &quot; + anyoneEarnsOver5000); 결과는 다음과 같다. Anyone earns over 5000: true 6. Parallel Stream 6.1 개요 스트림은 sequential과 parallel 2종류가 있다. sequential 스트림은 하나의 thread에 의해 순차적으로 처리되며 parallel 스트림은 다수의 thread에 의해 병렬로 처리되어 진다. 스트림의 모든 API들은 기본적으로 sequential로 동작하며, 이를 parallel로 바꾸기 위해서는 parallel 스트림을 명시적으로 만들어야 한다. parallelStream(): Collection(List 또는 Set)에서 Parallel 스트림 생성 parallel(): sequential 스트림을 Parallel 스트림으로 변환 sequential(): Parallel 스트림을 sequential 스트림으로 변환 6.2 parallelStream() Collection(List 또는 Set)에서 Parallel 스트림 생성한다. String names = Employee.persons() .parallelStream() .filter(Employee::isMale) .map(Employee::getName) .collect(Collectors.joining(&quot;, &quot;)); System.out.println(names); 결과는 Jake, Jack, Jode, Jason 6.3 parallel() squential을 parallel 스트림으로 변환한다. String names = Employee.persons() // The data source .stream() // Produces a sequential stream .filter(Employee::isMale) // Processed in serial .parallel() // Produces a parallel stream .map(Employee::getName) // Processed in parallel .collect(Collectors.joining(&quot;, &quot;)); // Processed in parallel System.out.println(names); 결과는 Jake, Jack, Jode, Jason 참고 java2s.com java8 tutorial programcreek의 simple java 8 Java Optional java.util.stream Package Reference - Stream java.util.stream Package Reference - Collectors java.util.stream Package Reference - Stream.Builder java.util.stream Package Reference - InStream java.util.stream Package Reference - LongStream java.util.stream Package Reference - DoubleStream",
    "url": "http://localhost:4000/docs/java/2016-09-04-java-stream.html",
    "relUrl": "/docs/java/2016-09-04-java-stream.html"
  },
  "40": {
    "id": "40",
    "title": "Java - StringBuilder",
    "content": "1. 개요 Java의 String은 immutable한 것이고 StringBuilder와 StringBuffer는 mutable하다. 그리고 StringBuffer는 동기화를 지원하므로 일반적인 상황에서는 StringBulider의 성능이 우세하다. MSDN에서는 StringBuilder를 다음과 같이 정의하고 있다. StringBuilder Class represents a mutable string of characters. 2. 생성 2.1 정의 Name Description StringBuilder() 빈 StringBuilder - default 크기는 16 StringBuilder(int) 특정 크기로 생 StringBuilder(String) 특정 string으로 생성 2.2 예제 빈 StringBuilder는 크기가 16인데, 16 글자까지 append를 해도 크기가 증가하지 않는다. StringBuilder stringBuilder=new StringBuilder(); System.out.println(stringBuilder.capacity()); //16 stringBuilder.append(&quot;1234567890123456&quot;); System.out.println(stringBuilder.capacity()); //16 하지만, 그 이상의 문자의 경우엔 충분할 만큼 크기를 할당한다. StringBuilder stringBuilder=new StringBuilder(); System.out.println(stringBuilder.capacity()); //16 stringBuilder.append(&quot;12345678901234567&quot;); System.out.println(stringBuilder.capacity()); //34 또한, 문자열과 함께 생성한 경우엔 크기가 다름을 알 수 있다. StringBuilder stringBuilder=new StringBuilder(&quot;1234567890123456&quot;); System.out.println(stringBuilder.capacity()); //32 3. 메소드 주의할 점은 index가 2개가 있을 때 뒤의 startIndex는 범위에 포함되고(inclusive) endIndex는 포함되지 않는(exclusive)다는 것이다. Name Description StringBuilder append(String s) 스트링에 덧붙이기 StringBuilder insert(int offset, String s) 특정 offset부터 덮어쓰기 StringBuilder replace(int startIndex, int endIndex, String str) startIndex부터 endIndex까지 str로 대체 StringBuilder delete(int startIndex, int endIndex) startIndex부터 endIndex이전까지 제거 StringBuilder reverse() 스트링 뒤집기 int capacity() 현재 capacity 획득 void ensureCapacity(int minimumCapacity) 적어도 minimumCapacity까지는 확보하도록 명령 char charAt(int index) 특정 위치의 문자 획득 int length() 길이 획득 String substring(int beginIndex) beginIndex부터의 substring을 반환 String substring(int beginIndex, int endIndex) beginIndex부터 endIndex까지의 substring을 반환 3.1 append() StringBuilder append(String s) : 스트링에 덧붙이기 StringBuilder sb=new StringBuilder(&quot;Hello &quot;); sb.append(&quot;Java&quot;); System.out.println(sb);//Hello Java 3.2 insert() StringBuilder insert(int offset, String s): 특정 offset부터 덮어쓰기 StringBuilder sb=new StringBuilder(&quot;Hello &quot;); sb.insert(1,&quot;&quot;); System.out.println(sb);//Hello 3.3 replace() StringBuilder replace(int startIndex, int endIndex, String str): startIndex부터 endIndex까지 str로 대체. endIndex는 포함되지 않음. insert()가 덮어 쓰는 것에 비해 replace()는 다음의 과정을 수행하는 것이다. startIndex부터 endIndex이전까지를 잘라내고 그 앞부분과 뒷부분으로 2개의 substring을 만든다. 사이에 str을 위치시킨다. 3개의 substring을 합친다. StringBuilder one=new StringBuilder(&quot;Hello world!&quot;); one.replace(4,7,&quot;&quot;); System.out.println(one);//Hellorld! StringBuilder another=new StringBuilder(&quot;Hello world!&quot;); another.replace(4,10,&quot;&quot;); System.out.println(another);//Helld! StringBuilder third=new StringBuilder(&quot;Hello world!&quot;); third.replace(4,8,&quot;&quot;); System.out.println(third);//Hell rld! 3.4 delete() StringBuilder delete(int startIndex, int endIndex) : startIndex부터 endIndex이전까지 제거 StringBuilder sb=new StringBuilder(&quot;Hello&quot;); sb.delete(1,3); System.out.println(sb);//Hlo 3.5 reverse() StringBuilder reverse(): 스트링 뒤집기 StringBuilder sb=new StringBuilder(&quot;Hello&quot;); sb.reverse(); System.out.println(sb);// olleH 3.6 capacity() int capacity(): 현재 capacity 획득 StringBuilder stringBuilder=new StringBuilder(); System.out.println(stringBuilder.capacity()); //16 3.7 ensureCapacity() void ensureCapacity(int minimumCapacity): 적어도 minimumCapacity까지는 확보하도록 명령 만약 현재 capacity보다 클 경우 최소한 (현capacity2)+2 만큼을 확보한다. 아래의 예를 보면 처음의 ensureCapacity()에서 10은 현재 capacity인 16보다 작은 값이므로 무시한다. 두번째 20은 16보다 크므로 (162)+2만큼을 확보한다. StringBuilder sb=new StringBuilder(); sb.ensureCapacity(10); System.out.println(sb.capacity());// 16 - default sb.ensureCapacity(20); System.out.println(sb.capacity());// 34 3.8 charAt() char charAt(int index): 특정 위치의 문자 획득 StringBuilder sb=new StringBuilder(&quot;Hello&quot;); System.out.println(sb.charAt(4)); //&#39;o&#39; 3.9 length() int length(): 길이 획득 StringBuilder sb=new StringBuilder(&quot;Hello&quot;); System.out.println(sb.length()); //5 3.10 substring() String substring(int beginIndex): beginIndex부터의 substring을 반환 String substring(int beginIndex, int endIndex): beginIndex부터 endIndex까지의 substring을 반환 StringBuilder sb=new StringBuilder(&quot;Hello&quot;); System.out.println(sb.substring(1)); //ello System.out.println(sb.substring(1,3)); //el",
    "url": "http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html",
    "relUrl": "/docs/java/2016-09-06-java-stringbuilder.html"
  },
  "41": {
    "id": "41",
    "title": "Java - Comparator Interface 사용",
    "content": "예제를 통해 Comparator interface의 사용 방법을 살펴보자. Comparator를 사용하기 위해서는 int compare(Object o1, Object o2)를 Override해야 한다. 1. 요구사항 score를 큰 것부터 작은 순으로 정렬하고, 같을 경우엔 name을 알파벳 순으로 정렬하는 것이다. 입력은 다음과 같다. 5 amy 100 david 100 heraldo 50 aakansha 75 aleksa 150 출력은 다음과 같다. aleksa 150 amy 100 david 100 aakansha 75 heraldo 50 2. 구현 //Checker.java import java.util.Comparator; class Checker implements Comparator&lt;Player&gt; { @Override public int compare(Player o1, Player o2) { if( o2.score == o1.score){ o1.name.compareTo(o2.name); } return o2.score - o1.score; } } //Player class Player{ String name; int score; Player(String name, int score){ this.name = name; this.score = score; } } //Solution.java import java.util.Arrays; import java.util.Scanner; class Solution { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int n = scan.nextInt(); Player player[] = new Player[n]; Checker checker = new Checker(); for(int i=0; i &lt; n; i++){ player[i] = new Player(scan.next(), scan.nextInt()); } scan.close(); Arrays.sort(player, checker); for(int i = 0; i &lt; player.length; i++){ System.out.printf(&quot;%s %s n&quot;, player[i].name, player[i].score); } } }",
    "url": "http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html",
    "relUrl": "/docs/java/2016-09-12-java-comparator-interface.html"
  },
  "42": {
    "id": "42",
    "title": "Java - Generic function",
    "content": "예제를 통해 Generic function의 사용 방법을 살펴보자. 1. 요구사항 String array와 integer array등 다양한 타입의 array를 입력으로 받아 element를 하나씩 출력하는 printArray()함수를 구현한다. 2. 구현 public class Printer { &lt;T&gt; void printArray(T [] array) { for(T t: array) { System.out.println(t); } } }",
    "url": "http://localhost:4000/docs/java/2016-09-12-java-generic-function.html",
    "relUrl": "/docs/java/2016-09-12-java-generic-function.html"
  },
  "43": {
    "id": "43",
    "title": "Java - BitSet class 예제",
    "content": "Java의 BitSet class의 사용방법을 알아보자. 0. Methods API는 여기를 참조하자. 반드시 이해해야 하는 것은 BitSet은 일종의 boolean element로 이루어진 Array라는 것이다. BitSet instance를 출력하면 true인 bit의 index가 Array처럼 출력된다. 1. set 1.1 void set(int bitIndex) bitIndex를 true로 set 1.2 void set(int bitIndex, boolean value) bitIndex를 value로 set 1.3 void set(int fromIndex, int toIndex) fromIndex부터 toIndex이전까지(즉, toIndex는 exclusive) true로 set 1.4 void set(int fromIndex, int toIndex, boolean value) fromIndex부터 toIndex이전까지(즉, toIndex는 exclusive) value로 set 1.5 예제 import java.util.*; public class Solution { public static void main(String[] args) { BitSet bitset = new BitSet(8); // assign values to bitset1 bitset.set(0); bitset.set(1); bitset.set(2); bitset.set(3); bitset.set(4); bitset.set(5); // print the sets System.out.println(&quot;Bitset:&quot; + bitset); // set more values bitset.set(1, 10, false); // print the sets System.out.println(&quot;Bitset:&quot; + bitset); } } 출력은 다음과 같다. Bitset:{0, 1, 2, 3, 4, 5} Bitset1:{0} 2. get 2.1 boolean get(int bitIndex) bitIndex의 value를 획득 2.2 BitSet get(int fromIndex, int toIndex) fromIndex부터 toIndex이전까지(즉, toIndex는 exclusive)를 BitSet으로 반환 2.3 예제 import java.util.*; public class Solution { public static void main(String[] args) { BitSet bitset = new BitSet(8); // assign values to bitset bitset.set(0); bitset.set(1); bitset.set(2); bitset.set(3); bitset.set(4); bitset.set(5); // print the sets System.out.println(&quot;Bitset:&quot; + bitset); // get index 1 to 4 of bitset System.out.println(&quot;&quot; + bitset.get(1,4)); } } 출력은 다음과 같다. Bitset:{0, 1, 2, 3, 4, 5} Bitset:{0} 3. flip 3.1 void flip(int bitIndex) bitIndex의 value를 toggle 3.2 void flip(int fromIndex, int toIndex) fromIndex부터 toIndex이전까지(즉, toIndex는 exclusive) value들을 각각 toggle 3.3 예제 import java.util.*; public class Solution { public static void main(String[] args) { BitSet bitset = new BitSet(8); // assign values to bitset bitset.set(0); bitset.set(1); bitset.set(2); bitset.set(3); bitset.set(4); bitset.set(5); // print the sets System.out.println(&quot;Bitset:&quot; + bitset); // flip from index 2 to index 5 of bitset and print it bitset.flip(2,5); System.out.println(&quot;&quot; + bitset); } } 출력은 다음과 같다. Bitset:{0, 1, 2, 3, 4, 5} {0, 1, 5} 4. Bitwise Operation 4.1 void and(BitSet set) set과 logical AND한 것으로 update ####4.2 void andNot(BitSet set) set에서 true인 것을 모두 false로 update 4.3 boolean intersects(BitSet set) 두개의 BitSet instance에서 하나의 bit index라도 모두 true인 경우 true를 반환 4.4 void or(BitSet set) Logical OR operation 4.5 void xor(BitSet set) Logical XOR operation. 두개의 set에서 각 Bit의 값이 다른 경우만 true 4.6 예제 Bitwise Operation의 예는 다음과 같다. import java.util.BitSet; class BitSetDemo { public static void main(String args[]) { BitSet bits1 = new BitSet(16); BitSet bits2 = new BitSet(16); // set some bits for(int i=0; i&lt;16; i++) { if((i%2) == 0) bits1.set(i); if((i%5) != 0) bits2.set(i); } System.out.println(&quot;Initial pattern in bits1: &quot;); System.out.println(bits1); System.out.println(&quot; nInitial pattern in bits2: &quot;); System.out.println(bits2); // AND bits bits2.and(bits1); System.out.println(&quot; nbits2 AND bits1: &quot;); System.out.println(bits2); // OR bits bits2.or(bits1); System.out.println(&quot; nbits2 OR bits1: &quot;); System.out.println(bits2); // XOR bits bits2.xor(bits1); System.out.println(&quot; nbits2 XOR bits1: &quot;); System.out.println(bits2); } } 결과는 다음과 같다. Initial pattern in bits1: {0, 2, 4, 6, 8, 10, 12, 14} Initial pattern in bits2: {1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14} bits2 AND bits1: {2, 4, 6, 8, 12, 14} bits2 OR bits1: {0, 2, 4, 6, 8, 10, 12, 14} bits2 XOR bits1: {} 5. Bitwise Operation Bitwise Operation의 예는 다음과 같다. import java.util.BitSet; class BitSetDemo { public static void main(String args[]) { BitSet bits1 = new BitSet(16); BitSet bits2 = new BitSet(16); // set some bits for(int i=0; i&lt;16; i++) { if((i%2) == 0) bits1.set(i); if((i%5) != 0) bits2.set(i); } System.out.println(&quot;Initial pattern in bits1: &quot;); System.out.println(bits1); System.out.println(&quot; nInitial pattern in bits2: &quot;); System.out.println(bits2); // AND bits bits2.and(bits1); System.out.println(&quot; nbits2 AND bits1: &quot;); System.out.println(bits2); // OR bits bits2.or(bits1); System.out.println(&quot; nbits2 OR bits1: &quot;); System.out.println(bits2); // XOR bits bits2.xor(bits1); System.out.println(&quot; nbits2 XOR bits1: &quot;); System.out.println(bits2); } } 결과는 다음과 같다. Initial pattern in bits1: {0, 2, 4, 6, 8, 10, 12, 14} Initial pattern in bits2: {1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14} bits2 AND bits1: {2, 4, 6, 8, 12, 14} bits2 OR bits1: {0, 2, 4, 6, 8, 10, 12, 14} bits2 XOR bits1: {} 5. 기타 5.1 int cardinality() true인 bit의 숫자 반환 5.2 void clear() 모든 bit를 false로 5.3 void clear(int bitIndex) bitIndex를 false로 5.4 void clear(int fromIndex, int toIndex) fromIndex부터 toIndex이전까지(즉, toIndex는 exclusive)를 false로",
    "url": "http://localhost:4000/docs/java/2016-09-13-java-bitset.html",
    "relUrl": "/docs/java/2016-09-13-java-bitset.html"
  },
  "44": {
    "id": "44",
    "title": "Java - Priority Queue",
    "content": "Java의 Priority Queue의 method에 대해 살펴보자. 주의할 것은 Java priority queue는 null element를 허용하지 않는다는 것이다. 1. 생성자 1.1 PriorityQueue() default capacity가 11이며 natural ordering을 하는 priority queue를 생성한다. 1.2 PriorityQueue(int initialCapacity) 주어진 capacity로 natural ordering을 하는 priority queue를 생성한다. 1.3 PriorityQueue(Collection&lt;? extends E&gt; c) Collection으로부터 Priority queue를 생성한다. 1.4 PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) 주어진 capacity로 comparator가 설정한 ordering을 하는 priority queue를 생성한다. 1.5 PriorityQueue(PriorityQueue&lt;? extends E&gt; c) Priority queue로부터 Priority queue를 생성한다. 1.6 PriorityQueue(SortedSet&lt;? extends E&gt; c) Sorted Set으로부터 Priority queue를 생성한다. 2. 주요 메소드 2.1 boolean add(E e) = boolean offer(E e) element를 추가한다. 2.2 E poll() head에서 element를 제거하며 읽는다. 만약 queue가 empty이면 null을 반환한다. 2.3 E peek() head에서 element를 제거하지 않고 읽는다. 만약 queue가 empty이면 null을 반환한다. 2.5 boolean contains(Object o) 특정 object가 저장되어 있는지 확인 2.6 Iterator iterator() queue의 element를 iteration하기 위한 iterator획득 2.7 int size() element의 수 2.8 toArray() Array 변환 3. 예제 import java.util.PriorityQueue; import java.util.Comparator; public class Solution { public static void main(String[] args) { PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { public int compare(Integer w1, Integer w2) { return w2.compareTo(w1); //descendant order } }); priorityQueue.add(12); priorityQueue.add(1); priorityQueue.add(5); priorityQueue.add(22); priorityQueue.add(3); priorityQueue.add(30); while(priorityQueue.size() &gt; 0) { System.out.println(priorityQueue.poll()); } } } 결과는 다음과 같다. 30 22 12 5 3 1",
    "url": "http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html",
    "relUrl": "/docs/java/2016-09-13-java-priority-queue.html"
  },
  "45": {
    "id": "45",
    "title": "Java - (멀티쓰레딩 1) Thread 구현",
    "content": "Java 쓰레드 구현 Java의 일반 쓰레드 구현 방식은 다음과 같다. Thread 클래스를 상속한 클래스의 객체를 생성과 동시에 구동 Thread 클래스를 상속한 클래스의 객체를 생성한 후 나중에 구동 Runnable 인터페이스를 구현한 클래스의 객체를 생성과 동시에 구동 Runnable 인터페이스를 구현한 클래스의 객체를 생성한 후 나중에 구동 4번을 inline으로 구현하기 4번을 anonymous로 구현하기 4번을 Lambda로 구현하기 4번째가 가장 많이 사용되는 방식이다. 그 이유는 다음과 같다. 쓰레드 관련 코드와 태스크 관련 코드의 구현이 분리된다. 쓰레드 생성과 실행 등의 제어가 더 용이하다. 5,6,7번째의 경우에는 태스크를 별도 클래스가 아닌 함수로 구현하기 때문에 사용할 때 제약이 있다. 대신 UI 이벤트 처리등에 많이 사용된다. 1. Thread 객체를 만들자 마자 실행하는 경우 Thread 클래스를 상속하여 쓰레드를 구현할 때는 3가지만 생각하면 된다. Thread class를 상속 public void run()을 구현 start()로 run() 메소드를 호출 여기서는 run() 메소드를 호출을 Thread 객체의 constructor에서 호출하는 것이다. 예제는 다음과 같다. import java.util.concurrent.TimeUnit; public class FirstWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); new MyThreadTask(); Thread t = new MyThreadTask(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask extends Thread { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; this.start(); } } 출력은 다음과 같은데 순서는 달라질 수 있다. Main thread starts here... Main thread ends here... &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 &lt;2&gt;TICK TICK 1 &lt;1&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;2&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;1&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 4 2. Thread 객체를 원하는 시점에 실행하는 경우 run() method를 호출을 Thread 객체를 받는 변수에서 호출하는 것이다. 좀 더 정교한 제어가 가능하다. 아래 코드는 위와 코드와 동일하게 동작하지만, Thread 객체 바깥에서 실행을 제어한다. import java.util.concurrent.TimeUnit; public class SecondWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); new MyThreadTask().start(); //start() 호출 Thread t = new MyThreadTask(); t.start(); //start() 호출 System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask extends Thread { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; //this.start(); //제거 } } 3. Runnable 객체를 만들자 마자 실행하는 경우 Runnable 인터페이스를 이용해 쓰레드를 구동할 때는 3가지만 생각하면 된다. Runnable 인터페이스 구현 public void run()을 구현 Thread(Runnable) 객체를 만들어 start()로 run() 메소드를 호출 1번과 같이 constructor에서 바로 실행시키는 경우이다. 차이점은 주석으로 표시해 두었다. import java.util.concurrent.TimeUnit; public class ThirdWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); new MyThreadTask(); //Thread t = new MyThreadTask(); //Thread 타입 변로 받을 수 없음 new MyThreadTask(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { //extends Thread --&gt; implements Runnable private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; //this.start(); new Thread(this).start(); //Thread(Runnable).start()로 실행시킴 } } 4. Runnable 객체를 원하는 시점에 실행하는 경우 run() 메소드를 호출을 Runnable 레퍼런스에서 호출하는 것이다. 좀 더 정교한 제어가 가능하다. 아래 코드는 위와 코드와 동일하게 동작하지만, Runnable 객체 바깥에서 실행을 제어한다. import java.util.concurrent.TimeUnit; public class FourthWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); new Thread(new MyThreadTask()).start(); //start()호출 Thread t = new Thread(new MyThreadTask()); t.start(); //start()호출 System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; //new Thread(this).start(); //제거 } } 5. Runnable을 inline으로 구현하기 다음은 Runnable를 별도의 클래스 없이 inline으로 구현한 것이다. 주로 UI 이벤트 등의 처리에 많이 사용한다. import java.util.concurrent.TimeUnit; public class FifthWay { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); Runnable myThreadTask = new Runnable(){ //Runnable 객체 @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } }; Thread thread = new Thread(myThreadTask); thread.start(); System.out.println(&quot;Main thread ends here...&quot;); } } 실행결과는 다음과 같다. Main thread starts here... Main thread ends here... TICK TICK 0 TICK TICK 1 TICK TICK 2 TICK TICK 3 TICK TICK 4 6. inline Runnable을 Anonymous로 구현 UI event등의 처리에 많이 사용하는 방식이다. import java.util.concurrent.TimeUnit; public class Sixth { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); new Thread(new Runnable(){ @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); System.out.println(&quot;Main thread ends here...&quot;); } } 7. Runnable Lambda로 구현하기 위의 6번째를 Lambda로 구현한 것이다. 장황한 코드가 많이 사라졌음을 알 수 있다. import java.util.concurrent.TimeUnit; public class Seventh { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); new Thread(()-&gt;{ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } ).start(); System.out.println(&quot;Main thread ends here...&quot;); } }",
    "url": "http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html",
    "relUrl": "/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html"
  },
  "46": {
    "id": "46",
    "title": "Java - (멀티쓰레딩 2) Executor 기본",
    "content": "Java Executor 1. 개요 Java의 일반 쓰레드 구동 방식은 다양하지만, Executor는 단지 하나의 방식으로 간단하게 쓰레드를 구동할 수 있다. 아래의 두 가지를 하면 된다. 태스크를 정의한 클래스의 생성 Executor Service에 태스크 객체를 제공 Executor 프레임웍은 다음과 같은 특징을 지닌다. 쓰레드 풀을 사용 무거운 쓰레드는 미리 할당 가능 태스크와 쓰레드를 생성하고 관리하는 것을 분리 쓰레드 풀안의 쓰레드는 한번해 하나씩 여러 태스크를 실행 태스크 큐를 이용해 태스크를 관리 Executor Service를 더이상 필요 없으면 중지 Executor Service가 멈추면 모든 쓰레드도 중지 2. 주요 클래스와 인터페이스 Executor 인터페이스: 태스크와 쓰레드를 분리하고 실행을 담당 void execute(Runnable task); ExecutorService 인터페이스: Executor 인터페이스를 확장하며 라이프 사이클을 제어 &lt;T&gt; Future &lt;T&gt; submit(Callable&lt;T&gt; task); Future &lt;?&gt; submit(Runnable task); void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); ... Executors 클래스: 다양한 executor서비스의 인스턴스를 생성하는 Factory 클래스. public static ExecutorService newFixedThreadPool(int nThreads); public static ExecutorService newCachedThreadPool(); public static ExecutorService newSingleThreadExecutor(); public static ExecutorService newSingleThreadScheduledExecutor(); ... Future 인터페이스: 태스크가 중지되었는지 아닌지를 확인하거나 태스크로부터 응답 획득 v get() throws InterruptedException, ExcutionException; boolean isDone(); ... 3. Executor를 이용한 쓰레드 구현 Java의 일반 쓰레드 구동 방식에 사용된 에를 그대로 이용해 보자. 일반 Thread 클래스 대신에 Executor 프레임웍을 쓴 것은 다음과 같다. 3.1 FixedThreadPool 사용 FixedThreadPool을 이용한 예제는 다음과 같다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class UsingFixedThreadPool { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newFixedThreadPool(2); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } MyThreadTask는 그대로이고 Thread를 이용해 Runnable 객체를 구동하는 것을 ExecutorService로 대체했다. 그리고 반드시 shutdown()을 해줘야만 thread가 모두 중지된다. 만약 빼먹으면 leakage가 발생하는 것이니 주의하자. 실행 결과는 다음과 같다. Main thread starts here... &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 Main thread ends here... &lt;1&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;2&gt;TICK TICK 1 &lt;1&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;2&gt;TICK TICK 4 그런데 아래와 같이 ThreadPool의 숫자는 2개로 유지한 채 태스크를 실행하는 수를 4번으로 2배 늘리면 어떻게 될까? ExecutorService execService = Executors.newFixedThreadPool(2); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); 결과는 다음과 같다. 쓰레드 id 3과 4는 1과 2가 완료된 이후에야 쓰레드를 점유함을 알 수 있다. Main thread starts here... &lt;2&gt;TICK TICK 0 Main thread ends here... &lt;1&gt;TICK TICK 0 &lt;1&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;1&gt;TICK TICK 3 &lt;2&gt;TICK TICK 1 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 2 &lt;3&gt;TICK TICK 0 &lt;3&gt;TICK TICK 1 &lt;2&gt;TICK TICK 3 &lt;3&gt;TICK TICK 2 &lt;2&gt;TICK TICK 4 &lt;3&gt;TICK TICK 3 &lt;4&gt;TICK TICK 0 &lt;3&gt;TICK TICK 4 &lt;4&gt;TICK TICK 1 &lt;4&gt;TICK TICK 2 &lt;4&gt;TICK TICK 3 &lt;4&gt;TICK TICK 4 3.2 CachedThreadPool 사용 CachedThreadPool은 FixedThreadPool과 달리 태스크의 숫자에 따라 쓰레드의 숫자가 가변된다는 것이다. 그러므로 생성시 쓰레드 숫자를 지정할 필요가 없다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class UsingCachedThreadPool { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); //ExecutorService execService = Executors.newFixedThreadPool(2); ExecutorService execService = Executors.newCachedThreadPool(); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } 실행 결과는 다음과 같이 newFixedThreadPool을 사용했을 때와 동일하다. Main thread starts here... &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 Main thread ends here... &lt;1&gt;TICK TICK 1 &lt;2&gt;TICK TICK 1 &lt;2&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;2&gt;TICK TICK 4 &lt;1&gt;TICK TICK 2 &lt;1&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 이제, 아래와 같이 태스크를 실행하는 수를 4번으로 2배 늘려보자. ExecutorService execService = Executors.newCachedThreadPool(); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); 결과는 다음과 같다. 쓰레드 id 1,2,3,4가 섞여서 실행되고 있음을 알 수 있다. 즉, 가변적으로 쓰레드 숫자가 늘어난 것이다. Main thread starts here... &lt;2&gt;TICK TICK 0 &lt;1&gt;TICK TICK 0 &lt;3&gt;TICK TICK 0 &lt;4&gt;TICK TICK 0 Main thread ends here... &lt;2&gt;TICK TICK 1 &lt;2&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;3&gt;TICK TICK 1 &lt;4&gt;TICK TICK 1 &lt;3&gt;TICK TICK 2 &lt;1&gt;TICK TICK 1 &lt;2&gt;TICK TICK 4 &lt;1&gt;TICK TICK 2 &lt;3&gt;TICK TICK 3 &lt;4&gt;TICK TICK 2 &lt;3&gt;TICK TICK 4 &lt;1&gt;TICK TICK 3 &lt;4&gt;TICK TICK 3 &lt;4&gt;TICK TICK 4 &lt;1&gt;TICK TICK 4 3.3 SingleThreadExecutor 이것은 이전에 다룬 Executor와 동일한데, 단지 쓰레드의 숫자가 단지 하나이고 하나의 태스크가 완료된 이후에 다음 태스크가 실행된다. 이것을 사용하면 동기화를 고려해야 할 필요없이, 즉 synchronized를 사용하지 않고도 안전하게 실행할 수 있다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class UsingSingleThreadExecutor { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newSingleThreadExecutor(); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } 실행 결과는 다음과 같이 하나의 태스크가 완전히 실행된 후에야 다음 태스크가 실행된다. Main thread starts here... Main thread ends here... &lt;1&gt;TICK TICK 0 &lt;1&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;1&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 0 &lt;2&gt;TICK TICK 1 &lt;2&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;2&gt;TICK TICK 4",
    "url": "http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html",
    "relUrl": "/docs/java/2016-09-16-java-multithreading-executor-basic.html"
  },
  "47": {
    "id": "47",
    "title": "Java - vararg을 stream으로 변환",
    "content": "Java method의 가변 길이 argument(vararg)를 stream으로 변환하는 것을 해보자. 1. 올바른 방법 vararg는 일종이 array이다. 그러므로 다음과 같이 Stream.of()나 Arrays.stream()을 사용해야 한다. 1.1 numeric type의 vararg인 경우 1.1.1 Stream.of() 사용 예제를 통해 살펴보자. 적당한 type의 Stream을 선택하여 사용한다. import java.util.stream.IntStream; class Adder { static int add(int ... ints) { //vararg return IntStream.of(ints).sum(); } } public class Solution { public static void main(String[] args) { System.out.println(Adder.add(1, 2, 1, 4)); //8 } } 1.1.2 Arrays.stream() 사용 Array에서 stream을 직접 생성해보자. import java.util.Arrays; class Adder { static int add(int ... ints) { //vararg return Arrays.stream(ints).sum(); } } 1.2 비 numeric type의 vararg인 경우 1.2.1 Stream.of() 사용 예제를 통해 살펴보자. import java.util.stream.Stream; class Car { private int price; public Car(int price) { this.price = price; } public int getPrice() { return price; } } class CarPriceAdder { static int add(Car ... cars) { //vararg return Stream.of(cars).mapToInt(car-&gt;car.getPrice()).sum(); } } public class Solution { public static void main(String[] args) { Car accent = new Car(100); Car outback = new Car(200); System.out.println(CarPriceAdder.add(accent, outback)); //300 } } 1.2.2 Arrays.stream() 사용 Array에서 stream을 직접 생성해보자. import java.util.Arrays; class CarPriceAdder { static int add(Car ... cars) { //vararg return Arrays.stream(cars).mapToInt(car-&gt;car.getPrice()).sum(); } } 2. 올바르지 않은 방법 2.1 Collection처럼 접근하는 경우 vararg는 Collection이 아니므로 직접 stream을 생성할 수 없다. 그러므로 아래 코드는 컴파일이 안된다. class CarPriceAdder { static int add(Car ... cars) { //vararg return cars.stream().mapToInt(car-&gt;car.getPrice()).sum(); } }",
    "url": "http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html",
    "relUrl": "/docs/java/2016-09-16-java-vararg-stream-conversion.html"
  },
  "48": {
    "id": "48",
    "title": "Java - Annotation",
    "content": "Java Annotation은 클래스, 메소드, 필드의 선언시 정보 제공을 목적으로 사용된다. 이에 대해 알아보자. 1. Java Annotation의 목적 Java annotation은 다음 3가지의 목적으로 사용된다. 컴파일러를 위한 정보 제공: 컴파일 시 error나 warning 관련 정보 컴파일 시와 배포시 처리 시 정보 제공: code나 XML 등을 생성하기 위한 정보 제공 런타임 처리시 2. 미리 정의된 Annotation 타입들 java.lang에 미리 정의된 Annotation 타입들은 다음과 같다. 2.1 일반 2.1.1 @Deprecated @Deprecated static void deprecatedMethod() { } 2.1.2 @Override interface의 method 구현시 또는 상속시 overriding한 경우 사용 @Override int overriddenMethod() { } 2.1.3 @SuppressWarnings 컴파일러에게 특정 Warning을 숨기도록 명령한다. 아래의 예는 Deprecated method라는 warning을 표시하지 않도록 하는 것이다. @SuppressWarnings(&quot;deprecation&quot;) void useDeprecatedMethod() { objectOne.deprecatedMethod(); } 2.1.4 @SafeVarargs 메소드의 varargs 아규먼트에 안전하지 않은 operation을 허용하지 않도록 한다. 2.1.5 @FunctionalInterface functional interface로 의도 되었다는 것을 명시한다. 2.2 다른 Annotation의 선언 적용되는 것들 2.2.1 @Retention RetentionPolicy.SOURCE : Annotation이 소스 레벨에서만 유지되고 컴파일러에 의해서는 무시됨을 명시. 이를 이용해 annotation을 comment 대신 사용 RetentionPolicy.CLASS : 컴파일로 수준에서 유지되고 런타임에는 (JVM에 의해서는) 무시됨 RetentionPolicy.RUNTIME : JVM 수준에서 유지됨 2.2.2 @Documented javadoc 툴에 의해 문서화 되어야함 2.2.3 @Target Annotation이 특정 대상에만 적용될 수 있음을 명시. 그 예는 다음과 같다. ElementType.ANNOTATION_TYPE: annotation type ElementType.CONSTRUCTOR: constructor ElementType.FIELD: field 또는 property ElementType.LOCAL_VARIABLE: local variable ElementType.METHOD: method-level annotation. ElementType.PACKAGE: package declaration. ElementType.PARAMETER: 메소드 parameter ElementType.TYPE: class의 element 2.2.4 @Inherited 상속된 annotation type 2.2.5 @Repeatable Annotation이 같은 선언에서 반복될 수 있음을 명시 3. Annotation 만들기 Annotation선언은 interface 선언하는 것과 동일하다. 단지 interface대신 @interface여야 한다. 메소드로 선언된 것들은 xxx = yyy형태로 입력하고, default 값은 default 키워드를 이용해 선언한다. //ClassPreamble.java package app; import java.lang.annotation.*; public @interface ClassPreamble { String author(); String date(); int currentRevision() default 1; String lastModified() default &quot;N/A&quot;; String lastModifiedBy() default &quot;N/A&quot;; // Note use of array String[] reviewers(); } 위와 같이 선언하면 다음과 같이 사용할 수 있다. //App.java package app; @ClassPreamble ( author = &quot;John Doe&quot;, date = &quot;3/17/2002&quot;, currentRevision = 6, lastModified = &quot;4/12/2004&quot;, lastModifiedBy = &quot;Jane Doe&quot;, reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;} ) public class App { public static void main(String argc[]) { System.out.println(&quot;Hello&quot;); } } 다음과 같이 @Documented를 추가해서 javadoc에서 참조하고, 또한 comment 대신으로 사용하기 위해 @Retention(RetentionPolicy.SOURCE)을 추가할 수 있다. 그리고 @Target(ElementType.TYPE)으로 클래스에만 적용할 수 있다. //ClassPreamble.java @Documented @Target(ElementType.TYPE) @Retention(RetentionPolicy.SOURCE) @interface ClassPreamble { ... } 4. 예제 Reflection의 isAnnotationPresent()과 getAnnotation()과 결합하여 Annotation을 사용한 예를 보자. Annotation에 userRole과 BudgetLimit을 정하고 Reflection을 통해 이를 읽어 내는 것이다. import java.lang.annotation.*; import java.lang.reflect.*; import java.util.*; /* Annotation 선언 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface FamilyBudget { String userRole() default &quot;GUEST&quot;; int budgetLimit() default 100; } class FamilyMember { /* Annotation 사용 */ @FamilyBudget(userRole=&quot;SENIOR&quot;, budgetLimit=100) public void seniorMember(int budget, int moneySpend) { System.out.println(&quot;Senior Member&quot;); System.out.println(&quot;Spend: &quot; + moneySpend); System.out.println(&quot;Budget Left: &quot; + (budget - moneySpend)); } /* Annotation 사용 */ @FamilyBudget(userRole=&quot;JUNIOR&quot;, budgetLimit=50) public void juniorUser(int budget, int moneySpend) { System.out.println(&quot;Junior Member&quot;); System.out.println(&quot;Spend: &quot; + moneySpend); System.out.println(&quot;Budget Left: &quot; + (budget - moneySpend)); } } public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int testCases = Integer.parseInt(in.nextLine()); while (testCases &gt; 0) { String role = in.next(); int spend = in.nextInt(); try { Class annotatedClass = FamilyMember.class; Method[] methods = annotatedClass.getMethods(); for (Method method : methods) { /* Annotation 정보 획 */ if (method.isAnnotationPresent(FamilyBudget.class)) { FamilyBudget family = method .getAnnotation(FamilyBudget.class); String userRole = family.userRole(); int budgetLimit = family.budgetLimit(); if (userRole.equals(role)) { if(spend &lt;= budgetLimit){ method.invoke(FamilyMember.class.newInstance(), budgetLimit, spend); }else{ System.out.println(&quot;Budget Limit Over&quot;); } } } } } catch (Exception e) { e.printStackTrace(); } testCases--; } } } 입력은 3 SENIOR 75 JUNIOR 45 SENIOR 40 출력은 Senior Member Spend: 75 Budget Left: 25 Junior Member Spend: 45 Budget Left: 5 Senior Member Spend: 40 Budget Left: 60 5. 참조 Oracle Annotation 튜토리얼",
    "url": "http://localhost:4000/docs/java/2016-09-17-java-annotation.html",
    "relUrl": "/docs/java/2016-09-17-java-annotation.html"
  },
  "49": {
    "id": "49",
    "title": "Java - (멀티쓰레딩 3) 쓰레드 이름 설정",
    "content": "Java 쓰레드 이름 설정 디버깅의 편리를 위해 Java 쓰레드에 이름을 부여하는 것이 좋다. 그 방법을 알아보자. 1. 실행 시 쓰레드 이름 부여하기 run() 메소드안에서 Thread.currentThread().setName()을 이용해서 쓰레드 이름을 부여한다. 이 방식은 일반 thread는 물론이고 Executor에도 동일하게 적용되는 방식이다. import java.util.concurrent.TimeUnit; public class NamingThreadsFirstWay { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); Thread t = new Thread(new MyThreadTask()); t.start(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ Thread.currentThread().setName(&quot;MyThreadTask&quot;); //setName() String threadName = Thread.currentThread().getName(); //getName() for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + threadName + &quot;, &quot; + id+ &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } 실행 결과는 다음과 같다. Main thread starts here... Main thread ends here... &lt;MyThreadTask, 1&gt;TICK TICK 0 &lt;MyThreadTask, 1&gt;TICK TICK 1 &lt;MyThreadTask, 1&gt;TICK TICK 2 &lt;MyThreadTask, 1&gt;TICK TICK 3 &lt;MyThreadTask, 1&gt;TICK TICK 4 2. 생성 시점에 부여하기 Thread() constructor의 두번째 아규먼트로 이름을 입력한다. import java.util.concurrent.TimeUnit; public class NamingThreadsSecondWay { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); Thread t = new Thread(new MyThreadTask(), &quot;MyThreadTask&quot;); //이름 추가 t.start(); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ //Thread.currentThread().setName(&quot;MyThreadTask&quot;); //제거 String threadName = Thread.currentThread().getName(); for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + threadName + &quot;, &quot; + id+ &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } 결과는 앞의 예제와 동일하다. Main thread starts here... Main thread ends here... &lt;MyThreadTask, 1&gt;TICK TICK 0 &lt;MyThreadTask, 1&gt;TICK TICK 1 &lt;MyThreadTask, 1&gt;TICK TICK 2 &lt;MyThreadTask, 1&gt;TICK TICK 3 &lt;MyThreadTask, 1&gt;TICK TICK 4 3. Executor의 쓰레드 생성시 이름 부여하기 Executor 프레임웍에서 쓰레드에 이름을 부여하고 디버깅을 하려면 ThreadFactory 인터페이스를 구현해야 한다. ThreadFactory 인터페이스는 newFixedThreadPool(), newCachedThreadPool(), newSingleThreadExecutor()의 아규먼트롤 사용 가능하며 다음의 메소드를 구현해야 한다. public Thread newThread(Runnable r); Runnable의 객체를 받아서 new Thread를 생성하여 반환하면 되는데 이때 Thread constructor에 이름을 추가하여 반환하면 Executor가 생성한 쓰레드에 이름이 할당된다. 다음이 그 예이다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class NamingExecutorThreads { public static void main(String argc[]) { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newFixedThreadPool(2, new NamedThreadsFactory()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.execute(new MyThreadTask()); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); //Mythread-x 형태로 쓰레드 이름 설정 } } class MyThreadTask implements Runnable { private static int count = 0; private int id; @Override public void run(){ String threadName = Thread.currentThread().getName(); for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + threadName + &quot;, &quot; + id+ &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyThreadTask() { this.id = ++count; } } 결과는 다음과 같다. Main thread starts here... &lt;MyThread-1, 1&gt;TICK TICK 0 &lt;MyThread-2, 2&gt;TICK TICK 0 Main thread ends here... &lt;MyThread-1, 1&gt;TICK TICK 1 &lt;MyThread-2, 2&gt;TICK TICK 1 &lt;MyThread-2, 2&gt;TICK TICK 2 &lt;MyThread-2, 2&gt;TICK TICK 3 &lt;MyThread-2, 2&gt;TICK TICK 4 &lt;MyThread-1, 1&gt;TICK TICK 2 &lt;MyThread-2, 3&gt;TICK TICK 0 &lt;MyThread-2, 3&gt;TICK TICK 1 &lt;MyThread-2, 3&gt;TICK TICK 2 &lt;MyThread-1, 1&gt;TICK TICK 3 &lt;MyThread-2, 3&gt;TICK TICK 3 &lt;MyThread-2, 3&gt;TICK TICK 4 &lt;MyThread-1, 1&gt;TICK TICK 4 &lt;MyThread-2, 4&gt;TICK TICK 0 &lt;MyThread-2, 4&gt;TICK TICK 1 &lt;MyThread-2, 4&gt;TICK TICK 2 &lt;MyThread-2, 4&gt;TICK TICK 3 &lt;MyThread-2, 4&gt;TICK TICK 4",
    "url": "http://localhost:4000/docs/java/2016-09-17-java-name-threads.html",
    "relUrl": "/docs/java/2016-09-17-java-name-threads.html"
  },
  "50": {
    "id": "50",
    "title": "Java - (멀티쓰레딩 5) 데몬 쓰레드",
    "content": "데몬 쓰레드 데몬쓰레드는 다른 User 스레드의 작업을 돕는 보조적인 역할을 수행하도록 되어 있다. 그래서 핵심적인 특징은 다른 User 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 종료되어진다. 메인 쓰레드는 당연히도 User 스레드이다. 1. 일반 쓰레드의 경우 일반 스레드에서 스레드를 데몬 스레드로 지정하는 방법은 setDaemon() 메소드이다. setDaemon(true)후에 start()를 시키면 된다. import java.util.concurrent.TimeUnit; public class DaemonThreads { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread t1 = new Thread(new MyRunnableTask(100), &quot;Thread-1&quot;); Thread t2 = new Thread(new MyRunnableTask(500), &quot;Thread-2&quot;); t2.setDaemon(true); t1.start(); t2.start(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private String taskId; private long sleepTime; @Override public void run() { boolean isRunningInDaemonThread = Thread.currentThread().isDaemon(); String threadType = isRunningInDaemonThread ? &quot;DAEMON&quot; : &quot;USER&quot;; String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot;+ threadType + &quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); for(int i = 0; i&lt;10; i++) { System.out.println(&quot;&lt;&quot; + currentThreadName +&quot;,&quot;+ threadType + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot; + i); try { TimeUnit.MILLISECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot;+ threadType + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public MyRunnableTask(long sleepTime) { this.id = ++count; this.taskId = &quot;MyRunnableTask&quot; + id; this.sleepTime = sleepTime; } } 위와 같이 빨리 수행되는 t1과 늦게 수행되는 t2를 구동하면서 t2를 데몬스레드로 지정하면 결과가 다음과 같이 된다. Main thread와 t1이 종료하면 t2는 더이상 진행하지 않고 즉시 종료된다. [main] thread starts here... [main] thread ends here... #### &lt;Thread-1,USER,MyRunnableTask1&gt; starting...#### #### &lt;Thread-2,DAEMON,MyRunnableTask2&gt; starting...#### &lt;Thread-2,DAEMON,MyRunnableTask2&gt; TICK TICK0 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK0 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK1 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK2 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK3 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK4 &lt;Thread-2,DAEMON,MyRunnableTask2&gt; TICK TICK1 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK5 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK6 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK7 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK8 &lt;Thread-1,USER,MyRunnableTask1&gt; TICK TICK9 &lt;Thread-2,DAEMON,MyRunnableTask2&gt; TICK TICK2 #### &lt;Thread-1,USER,MyRunnableTask1&gt; done...#### 2. Executor의 경우 Executor의 경우도 setDaemon()을 동일하게 사용한다. 단지 언제 호출을 하느냐가 문제인데 이것은 이전에 살펴본 ThreadFactory 인터페이스를 통해 구현한다. 이전에 쓰레드의 이름을 주기 위해 NamedThreadsFactory 클래스를 구현했는데 이것을 상속한 DaemoneThreadsFactory를 이용해 쓰레드을 데몬으로 설정하는 것을 알아보자. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class DaemonThreadsUsingExecutors { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool( new DaemoneThreadsFactory()); execService.execute(new MyRunnableTask(100)); execService.execute(new MyRunnableTask(400)); execService.shutdown(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class DaemoneThreadsFactory extends NamedThreadsFactory { private static int count = 0; @Override public Thread newThread(Runnable r) { Thread t = super.newThread(r); count++; if(count%2 == 0){ t.setDaemon(true); //setDaemon() } return t; } } 짝수 쓰레드를 데몬으로 만들었는데, 이 경우도 역시 Main 쓰레드와 User 쓰레드가 종료되면 데몬 쓰레드는 더이상 진행하지 않고 즉시 종료된다. [main] thread starts here... #### &lt;MyThread-1,USER,MyRunnableTask1&gt; starting...#### #### &lt;MyThread-2,DAEMON,MyRunnableTask2&gt; starting...#### &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK0 &lt;MyThread-2,DAEMON,MyRunnableTask2&gt; TICK TICK0 [main] thread ends here... &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK1 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK2 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK3 &lt;MyThread-2,DAEMON,MyRunnableTask2&gt; TICK TICK1 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK4 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK5 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK6 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK7 &lt;MyThread-2,DAEMON,MyRunnableTask2&gt; TICK TICK2 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK8 &lt;MyThread-1,USER,MyRunnableTask1&gt; TICK TICK9 #### &lt;MyThread-1,USER,MyRunnableTask1&gt; done...####",
    "url": "http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html",
    "relUrl": "/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html"
  },
  "51": {
    "id": "51",
    "title": "Java - (멀티쓰레딩 4) 쓰레드에서 값 반환",
    "content": "쓰레드에서 값 반환 하기 쓰레드로부터 값을 리턴 받는 방법을 살펴보자. 일반 쓰레드의 경우를 살펴본 후 Executor의 경우도 살펴보자. 1. 일반 쓰레드의 경우 일반 쓰레드에서 리턴 값을 얻는 방법은 아래 두 가지가 있다. 블록킹: synchronized를 이용해 변경 시점까지 락을 거는 방법 논블록킹: Observer Pattern을 이용하는 방법 1.1 블록킹 synchronized를 이용해 변경 시점까지 락을 거는 방법으로 데이터를 읽는 메소드를 락을 걸고 쓰레드가 실행되는 마지막에 락을 푼다. 그 예는 다음과 같다. this.wait()로 기다리고 this.notifyAll()로 해제한다. done 변수를 이용해 synchronized로 무조건 들어가지 않도록 했으며, done은 volatile로 선언해서 어떤 스레드가 값을 변경하든, 항상 최신값을 읽어갈 수 있게 해준다. 참고로 volatile은 항상 최신 값을 읽게는 해주지만 operation을 atomic하게는 만들지 않으며, synchronized는 operation을 atomic하게 해준다. 즉, volatile은 동기화를 할 뿐이지 lock은 아니다. import java.util.concurrent.TimeUnit; public class ReturningValueFirstWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); MyThreadTask task1 = new MyThreadTask(); MyThreadTask task2 = new MyThreadTask(); new Thread(task1,&quot;firstThread&quot;).start(); new Thread(task2,&quot;secondThread&quot;).start(); System.out.println(&quot;task1 result:&quot; + task1.getRandomSum()); System.out.println(&quot;task2 result:&quot; + task2.getRandomSum()); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; private volatile boolean done = false; private int randomSum = 0; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } /********** Unlock ************/ done = true; synchronized (this) { System.out.println(Thread.currentThread().getName() + &quot;: Notifying the result&quot;); this.notifyAll(); } } public int getRandomSum(){ /*********** Lock ************/ if(!done) { synchronized (this) { try { System.out.println(Thread.currentThread().getName() + &quot;: Waiting for the result&quot;); this.wait(); } catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(Thread.currentThread().getName() + &quot;: Woken up&quot;); } return randomSum; } public MyThreadTask() { this.id = ++count; } } 결과는 다음과 같다. main 스레드가 getRandomSum()에서 wait()를 하고 있다가 스레드에서 notifyAll()을 한 시점에 풀려나서 값을 읽는 것이다. 타이밍 상 main 스레드는 한번만 락이 걸렸다가 풀렸음에도 두 스레드 모두 done이 true가 되어 있었다. Main thread starts here... main: Waiting for the result &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 &lt;1&gt;TICK TICK 1 &lt;2&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;2&gt;TICK TICK 2 &lt;1&gt;TICK TICK 3 &lt;2&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 4 secondThread: Notifying the result firstThread: Notifying the result main: Woken up task1 result:1868 task2 result:4049 Main thread ends here... 1.2 논블록킹 Observer pattern을 이용하는 것으로 스레드가 끝났을 때 등록된 Listener의 메소드를 호출하는 방식이다. 예제는 다음과 같다. import java.util.concurrent.TimeUnit; public class ReturningValueSecondWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); MyThreadTask task1 = new MyThreadTask(new RandomSumObserver(&quot;task1&quot;)); //Register the listeners MyThreadTask task2 = new MyThreadTask(new RandomSumObserver(&quot;task2&quot;)); //Register the listeners new Thread(task1,&quot;firstThread&quot;).start(); new Thread(task2,&quot;secondThread&quot;).start(); System.out.println(&quot;Main thread ends here...&quot;); } } /** Listener interface **/ interface ResultListener&lt;T&gt; { public void notifyResult(T t); } /** Listener **/ class RandomSumObserver implements ResultListener&lt;Integer&gt; { private String taskId; public RandomSumObserver(String taskId) { this.taskId = taskId; } @Override public void notifyResult(Integer result) { System.out.println(taskId + &quot; result:&quot; + result); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; private int randomSum = 0; private ResultListener&lt;Integer&gt; listener; //listener @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } this.listener.notifyResult(randomSum); //Invoke the listener } public MyThreadTask(ResultListener&lt;Integer&gt; listener) { //Register listener this.id = ++count; this.listener = listener; } } 결과는 다음과 같다. 블록킹 없이 쓰레드의 연산이 수행되면 자동으로 등록된 Listener를 실행시킨다. Main thread starts here... Main thread ends here... &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 &lt;1&gt;TICK TICK 1 &lt;2&gt;TICK TICK 1 &lt;1&gt;TICK TICK 2 &lt;2&gt;TICK TICK 2 &lt;1&gt;TICK TICK 3 &lt;2&gt;TICK TICK 3 &lt;1&gt;TICK TICK 4 &lt;2&gt;TICK TICK 4 task1 result:2004 task2 result:3088 2. Executor의 경우 2.1 Callable 인터페이스의 사용 Executor는 Runnable 인터페이스 대신 Callable 인터페이스를 이용해 태스크를 만들어서 결과를 반환한다. callable 인터페이스에서 오버라이드해야 하는 메소드는 call()이다. public T call() throws Exception ExecutorService.submit()을 하고 Future를 반환 받는다. Future&lt;T&gt; ExecutorService.submit(Callable c) ExecutorService.shutdown() 이후에 태스크의 결과는 Future의 get() 메소드를 이용해 반환 받는다. 이때 반드시 try/catch 블록으로 감싸야 한다. 또한 값을 반환하지 않는 Runnable 객체도 동일하게 할 수 있는데 이때 반환 값은 null이다. 또한 Runnable 객체를 submit할때 두번째 아규먼트로 값을 넣는 것이 있는데 이것은 향후 Future로 반환 시 동일한 값이 반환되게 된다. 자세한 내용은 아래 코드를 참조하자. import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; public class ReturningValuesUsingExecutorsFirstWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool(); //Callable Future&lt;Integer&gt; result1 = execService.submit(new MyCallableTask()); Future&lt;Integer&gt; result2 = execService.submit(new MyCallableTask()); //Runnable Future&lt;?&gt; result3 = execService.submit(new MyRunnableTask()); Future&lt;?&gt; result4 = execService.submit(new MyRunnableTask(), 110.1); execService.shutdown(); try { System.out.println(&quot;result1:&quot; + result1.get()); System.out.println(&quot;result2:&quot; + result2.get()); System.out.println(&quot;result3:&quot; + result3.get()); System.out.println(&quot;result4:&quot; + result4.get()); } catch(Exception e) { e.printStackTrace(); } System.out.println(&quot;Main thread ends here...&quot;); } } class MyCallableTask implements Callable&lt;Integer&gt; { private static int count = 0; private int id; private static String taskName = &quot;CallableTaks&quot;; private int randomSum = 0; @Override public Integer call() throws Exception { for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } return randomSum; //값을 반환 } public MyCallableTask() { this.id = ++count; } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private static String taskName = &quot;RunnableTaks&quot;; @Override public void run() { for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyRunnableTask() { this.id = ++count; } } 결과는 다음과 같다. Runnable과 Callable이 동일하게 실행되며, 결과도 반환받는데 Runnable은 null이고, 아규먼트를 추가한 경우 그 아규먼트가 동일하게 반환된다. Main thread starts here... &lt;CallableTaks-1&gt;TICK TICK 0 &lt;CallableTaks-2&gt;TICK TICK 0 &lt;RunnableTaks-1&gt;TICK TICK 0 &lt;RunnableTaks-2&gt;TICK TICK 0 &lt;CallableTaks-1&gt;TICK TICK 1 &lt;RunnableTaks-2&gt;TICK TICK 1 &lt;RunnableTaks-1&gt;TICK TICK 1 &lt;CallableTaks-2&gt;TICK TICK 1 &lt;CallableTaks-1&gt;TICK TICK 2 &lt;RunnableTaks-2&gt;TICK TICK 2 &lt;CallableTaks-2&gt;TICK TICK 2 &lt;RunnableTaks-1&gt;TICK TICK 2 &lt;CallableTaks-1&gt;TICK TICK 3 &lt;RunnableTaks-2&gt;TICK TICK 3 &lt;RunnableTaks-1&gt;TICK TICK 3 &lt;CallableTaks-2&gt;TICK TICK 3 &lt;CallableTaks-1&gt;TICK TICK 4 &lt;RunnableTaks-2&gt;TICK TICK 4 &lt;CallableTaks-2&gt;TICK TICK 4 &lt;RunnableTaks-1&gt;TICK TICK 4 result1:1852 result2:2129 result3:null result4:110.1 Main thread ends here... 2.2 CompletionService의 사용 (1) CompletionService 인터페이스를 이용해 태스크의 리턴을 획득할 수 있다. 4개의 인터페이스를 제공하는데 다음과 같다. Future submit(Callable task): Callable 등록 Future submit(Runnable task, V result); Runnable 등록 Future take(): 종료된 태스크의 인스턴스. 종료가 될때까지 블록되고 종료가 된 태스크가 있으면 그 태스크의 인스턴스를 반환 Future poll(): take() 메소드와 동일하지만 블록되지않음. 만약 종료된 태스크가 없으면 null을 반환 주의할 점은 Future submit(Runnable task)가 없다는 것이다. 즉, 결과값을 반환하지 않는 태스크는 처리하지 않는다는 것이다. 아래 예제는 ReturingValuesUsingExecutorsSecondWay클래스를 제외하고 2.1과 완전히 동일하다. 주의할 것은 앞의 에제에서는 Runnable 객체를 submit할 때 어떤 종류의 것이라도 두번째 아규먼트로 넣을 수 있었으나 CompletionService의 경우는 지정한 타입을 준수해야 한다는 것이다. import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; public class ReturingValuesUsingExecutorsSecondWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool(); CompletionService&lt;Integer&gt; tasks = new ExecutorCompletionService&lt;&gt;(execService); //Callable tasks.submit(new MyCallableTask()); tasks.submit(new MyCallableTask()); //Runnable tasks.submit(new MyRunnableTask(), 110); execService.shutdown(); for(int i = 0; i&lt; 3; i++) { try { System.out.println(&quot;Result: &quot; + tasks.take().get()); //block } catch (ExecutionException e) { e.printStackTrace(); } } System.out.println(&quot;Main thread ends here...&quot;); } } class MyCallableTask implements Callable&lt;Integer&gt; { private static int count = 0; private int id; private static String taskName = &quot;CallableTaks&quot;; private int randomSum = 0; @Override public Integer call() throws Exception { for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } return randomSum; //값을 반환 } public MyCallableTask() { this.id = ++count; } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private static String taskName = &quot;RunnableTaks&quot;; @Override public void run() { for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyRunnableTask() { this.id = ++count; } } 결과는 다음과 같다. Main thread starts here... &lt;CallableTaks-1&gt;TICK TICK 0 &lt;CallableTaks-2&gt;TICK TICK 0 &lt;RunnableTaks-1&gt;TICK TICK 0 &lt;CallableTaks-1&gt;TICK TICK 1 &lt;CallableTaks-2&gt;TICK TICK 1 &lt;RunnableTaks-1&gt;TICK TICK 1 &lt;CallableTaks-2&gt;TICK TICK 2 &lt;RunnableTaks-1&gt;TICK TICK 2 &lt;CallableTaks-1&gt;TICK TICK 2 &lt;CallableTaks-2&gt;TICK TICK 3 &lt;CallableTaks-1&gt;TICK TICK 3 &lt;RunnableTaks-1&gt;TICK TICK 3 &lt;RunnableTaks-1&gt;TICK TICK 4 &lt;CallableTaks-1&gt;TICK TICK 4 &lt;CallableTaks-2&gt;TICK TICK 4 Result: 1766 Result: 110 Result: 2772 Main thread ends here... 2.3 CompletionService의 사용 (2) 실무에서는 단순한 Integer를 반환하는 것이 아니라 개발자가 정의한 클래스의 객체를 생성해서 반환하는 경우가 많다. 예를 들어 Generic을 이용해 다음과 같은 반환 값을 위한 클래스를 정의한 경우 어떻게 수정해야 하는지 살펴보자. //TaskResult.java public class TaskResult&lt;S, R&gt; { private S taskId; private R result; public TaskResult(S taskId, R result) { this.taskId = taskId; this.result = result; } public S getTaskId() { return taskId; } public R getResult() { return result; } @Override public String toString() { return &quot;TaskResult [taskId=&quot; + taskId + &quot;, result=&quot; + result + &quot;]&quot;; } } 아래 코드에서 //type change라고 표시해 놓은 부분이 2.2와 달라진 부분이다. public class ReturingValuesUsingExecutorsThirdWay { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool(); CompletionService&lt;TaskResult&lt;String,Integer&gt;&gt; tasks = new ExecutorCompletionService&lt;&gt;(execService); //type change tasks.submit(new MyCallableTask()); tasks.submit(new MyCallableTask()); tasks.submit(new MyRunnableTask(), new TaskResult&lt;String, Integer&gt;(&quot;RunnableTask&quot;, 101));//type change execService.shutdown(); for(int i = 0; i&lt; 3; i++) { try { System.out.println(tasks.take().get()); } catch (ExecutionException e) { e.printStackTrace(); } } System.out.println(&quot;Main thread ends here...&quot;); } } class MyCallableTask implements Callable&lt;TaskResult&lt;String, Integer&gt;&gt; {//type change private static int count = 0; private int id; private static String taskName = &quot;CallableTaks&quot;; private int randomSum = 0; @Override public TaskResult&lt;String, Integer&gt; call() throws Exception {//type change for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } return new TaskResult&lt;String, Integer&gt;(taskName + id, randomSum); // type change } public MyCallableTask() { this.id = ++count; } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private static String taskName = &quot;RunnableTaks&quot;; @Override public void run() { for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + taskName +&quot;-&quot;+id + &quot;&gt;TICK TICK &quot; + i); try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public MyRunnableTask() { this.id = ++count; } } 실행 결과는 다음과 같다. Main thread starts here... &lt;CallableTaks-1&gt;TICK TICK 0 &lt;CallableTaks-2&gt;TICK TICK 0 &lt;RunnableTaks-1&gt;TICK TICK 0 &lt;CallableTaks-1&gt;TICK TICK 1 &lt;CallableTaks-2&gt;TICK TICK 1 &lt;RunnableTaks-1&gt;TICK TICK 1 &lt;CallableTaks-1&gt;TICK TICK 2 &lt;CallableTaks-2&gt;TICK TICK 2 &lt;RunnableTaks-1&gt;TICK TICK 2 &lt;CallableTaks-1&gt;TICK TICK 3 &lt;CallableTaks-2&gt;TICK TICK 3 &lt;RunnableTaks-1&gt;TICK TICK 3 &lt;CallableTaks-1&gt;TICK TICK 4 &lt;CallableTaks-2&gt;TICK TICK 4 &lt;RunnableTaks-1&gt;TICK TICK 4 TaskResult [taskId=CallableTaks2, result=3670] TaskResult [taskId=CallableTaks1, result=1640] TaskResult [taskId=RunnableTask, result=101] Main thread ends here...",
    "url": "http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html",
    "relUrl": "/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html"
  },
  "52": {
    "id": "52",
    "title": "Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기",
    "content": "쓰레드 동작의 완료를 확인한다는 것은 다음 2가지를 말한다. 일반 쓰레드에서 쓰레드가 살아있는지 확인하기 Executor에서 태스크가 종료되었는지 확인하기 사실 일반 쓰레드에서도 쓰레드가 살아있는지를 확인하는 것보다 태스크의 종료에 대해 관심이 더 많지만 쓰레드 API 수준에서는 제공하지 않는다. 1. 일반 쓰레드에서 쓰레드가 살아있는지 확인하기 일반 스레드에서 쓰레드가 살이있는지 확인하는 방법은 Thread.isAlive() 메소드를 사용하는 것이다. 예제로 확인하자. import java.util.concurrent.TimeUnit; public class ThreadAliveCheck { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread thread = new Thread(new MyRunnableTask(10), &quot;Thread-1&quot;); boolean threadIsAlive = thread.isAlive(); System.out.println(&quot;thread Aliveness before start: &quot; + threadIsAlive); thread.start(); for(int i = 0; i&lt; 4; i++) { TimeUnit.MILLISECONDS.sleep(20); System.out.println(&quot;thread Aliveness : &quot; + thread.isAlive()); } System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private String taskId; private long sleepTime; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); for(int i = 0; i&lt;4; i++) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot; + i); try { TimeUnit.MILLISECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public MyRunnableTask(long sleepTime) { this.id = ++count; this.taskId = &quot;MyRunnableTask&quot; + id; this.sleepTime = sleepTime; } } 아래 결과와 같이 쓰레드가 동작하고 있는동안에만 isAlive()가 true를 반환함을 알 수 있다. [main] thread starts here... thread Aliveness before start: false #### &lt;Thread-1,MyRunnableTask1&gt; starting...#### &lt;Thread-1,MyRunnableTask1&gt; TICK TICK0 &lt;Thread-1,MyRunnableTask1&gt; TICK TICK1 thread Aliveness : true &lt;Thread-1,MyRunnableTask1&gt; TICK TICK2 &lt;Thread-1,MyRunnableTask1&gt; TICK TICK3 thread Aliveness : true #### &lt;Thread-1,MyRunnableTask1&gt; done...#### thread Aliveness : false thread Aliveness : false [main] thread ends here... 2. Executor에서 태스크가 종료되었는지 확인하기 태스크의 종료는 반드시 태스크가 정상적으로 종료함만을 의미하지 않는다. Exception으로 종료되는 것도 포함해서 종료되었는지 확인하는 것은 Future.isDone()함수이다. 예제는 다음과 같다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class ExecutorTaskCompleteCheck { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool( new NamedThreadsFactory()); Future&lt;?&gt; future = execService.submit(new MyRunnableTask(10)); execService.shutdown(); for(int i = 0; i&lt; 4; i++) { TimeUnit.MILLISECONDS.sleep(20); System.out.println(&quot;Task completion : &quot; + future.isDone()); } System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class MyRunnableTask implements Runnable { private static int count = 0; private int id; private String taskId; private long sleepTime; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); for(int i = 0; i&lt;4; i++) { System.out.println(&quot;&lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot; + i); try { TimeUnit.MILLISECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public MyRunnableTask(long sleepTime) { this.id = ++count; this.taskId = &quot;MyRunnableTask&quot; + id; this.sleepTime = sleepTime; } } 결과는 다음과 같다. [main] thread starts here... #### &lt;MyThread-1,MyRunnableTask1&gt; starting...#### &lt;MyThread-1,MyRunnableTask1&gt; TICK TICK0 &lt;MyThread-1,MyRunnableTask1&gt; TICK TICK1 &lt;MyThread-1,MyRunnableTask1&gt; TICK TICK2 Task completion : false &lt;MyThread-1,MyRunnableTask1&gt; TICK TICK3 #### &lt;MyThread-1,MyRunnableTask1&gt; done...#### Task completion : true Task completion : true Task completion : true [main] thread ends here... 참고로 Future future = ExecutorService.submit(new Callable()) 대신 FutureTask future = new FutureTask(new Callable())로 사용할 수 있다.",
    "url": "http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html",
    "relUrl": "/docs/java/2016-09-19-java-multithreading-check-aliveness.html"
  },
  "53": {
    "id": "53",
    "title": "Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기",
    "content": "1 일반 쓰레드 쓰레드에서 Exception을 던지면 main 쓰레드에서 어떻게 처리해야 할까? 단지 catch만 하면 될까? 일반적으로 생각하는 Exception 처리의 문제점을 살펴보고 어떻게 해결해야 할지 알아보자. 1.1 쓰레드의 Uncaughted Exception 쓰레드에서 동작 중에 Exception을 발생시키는 경우 어떻게 처리해야 할까? 제대로 처리하지 못하면 Exception leakage가 발생하게 되어 어플리케이션이 비정상적으로 종료되고 만다. 쓰레드의 Exception을 처리할 때 뭐가 문제인지를 다음 2가지 예를 통해 살펴본다. Exception을 처리하지 않을 때 쓰레드 밖에서 쓰레드가 던진 Exception을 바로 받아서 처리할 때 1.1.1 처리되지 않는 Exception 아래의 예는 쓰레드에서 RuntimeException을 던지고 아무것도 하지 않는 경우이다. public class HandlingUncaughtExceptionsForThreads { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); new Thread(new ExceptionLeakingTask(), &quot;Mythread-1&quot;).start(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } 아래 처럼 쓰레드에서 RuntimeException을 던졌을 경우 제대로 처리하지 않으면 어플리케이션이 비정상적으로 종료된다. [main] thread starts here... [main] thread ends here... Exception in thread &quot;Mythread-1&quot; java.lang.RuntimeException at t1.ExceptionLeakingTask.run(HandlingUncaghtExceptionForEveryThread.java:22) at java.lang.Thread.run(Thread.java:745) 1.1.2 try/catch 블록을 이용한 직접 Exception을 처리하기 이제 try/catch 블록을 이용해서 태스크에서 던진 RuntimeException을 아래와 같이 처리해 보자. public class HandlingUncaughtExceptionsForThreads { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); try { new Thread(new ExceptionLeakingTask(), &quot;Mythread-1&quot;).start(); } catch(RuntimeException re) { System.out.println(&quot;!!!!!![&quot;+ currentThreadName + &quot;]&quot; + &quot; Caught Exception!!!&quot;); } System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } 결과는 다음과 같다. 위의 Exception을 처리하지 않은 것과 같은 결과를 얻었다. 특히 catch 구문은 아예 동작하지 않았다. 이를 통해 쓰레드가 던진 Exception을 쓰레드 바깥에서 try/catch로 바로 받을 수 없다는 것을 알 수 있다. [main] thread starts here... [main] thread ends here... Exception in thread &quot;Mythread-1&quot; java.lang.RuntimeException at t1.ExceptionLeakingTask.run(HandlingUncaghtExceptionForEveryThread.java:22) at java.lang.Thread.run(Thread.java:745) 1.2 UncaughtExceptionHandler 인터페이스로 처리하기 UncaughtException을 처리하기 위해 UncaughtExceptionHandler 인터페이스를 구현하자. UncaughtExceptionHandler 인터페이스는 다음의 메소드 하나만을 가진다. void uncaughtException(Thread thread, Throwable e) UncaughtExceptionHandler를 이용하는 방법은 3가지가 있다. 1.2.1 시스템 내의 모든 쓰레드를 위한 디폴트 handler 지정하기 시스템 내의 모든 쓰레드를 위한 디폴트 handler로 지정하여 UncaughtException을 처리한다. 이를 위해 아래 메소드를 이용해 쓰레드를 시작하기 이전에 디폴트로 지정한다. 주의할 것은 아래 메소드는 static이라는 것이다. 어디에서나 Thread.sefDefaultUncaughtExceptionHandler()을 호출할 수 있다. static void Thread.setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) 아래의 예는 ThreadExceptionHandler 인터페이스를 구현하고 그 객체를 디폴트 handler로 등록한 것이다. 이 경우 try/catch는 필요없다. import java.lang.Thread.UncaughtExceptionHandler; public class HandlingUncaughtExceptionsForThreads { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;DefaultHandler&quot;)); Thread thread1 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-1&quot;); Thread thread2 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-2&quot;); thread1.start(); thread2.start(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } 결과는 다음과 같다. 정상적으로 Exception이 처리되는 것을 볼 수 있다. 쓰레드 하나가 아닌 모든 쓰레드의 Exception을 처리한다. [main] thread starts here... [main] thread ends here... DefaultHandler caught Exception in Thread - Mythread-1 =&gt; java.lang.RuntimeException DefaultHandler caught Exception in Thread - Mythread-2 =&gt; java.lang.RuntimeException 1.2.2 쓰레드 별로 handler를 각기 지정하기 각 쓰레드 별로 각기 다른 Exception Handler를 지정하는 방법은 아래 메소드를 이용하는 것이다. static이 아니라는 것을 명심하자. void Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 예제는 다음과 같다. 디폴트 handler 대신 각 쓰레드마다 UncaughtExceptionHandler를 등록했다. ExceptionLeakingTask 클래스와 ThreadExceptionHandler는 동일하다. 여기서는 하나의 ExceptionLeakingTask 클래스를 구현했지만, 각기 다른 쓰레드마다 별도의 handler를 등록하여 처리할 수 있다는 것을 명심하자. import java.lang.Thread.UncaughtExceptionHandler; public class HandlingUncaughtExceptionsForThreads { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); //Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;DefaultHandler&quot;)); Thread thread1 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-1&quot;); thread1.setUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Handler-1&quot;)); Thread thread2 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-2&quot;); thread2.setUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Handler-2&quot;)); thread1.start(); thread2.start(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } 결과는 다음과 같다. 각기 다른 handler 객체가 정상적으로 Exception이 처리되는 것을 볼 수 있다. [main] thread starts here... [main] thread ends here... Handler-2 caught Exception in Thread - Mythread-2 =&gt; java.lang.RuntimeException Handler-1 caught Exception in Thread - Mythread-1 =&gt; java.lang.RuntimeException 1.2.3 디폴트 handler와 쓰레드 별 handler를 조합해서 사용하기 위에서 살펴본 디폴트 handler와 쓰레드 별로 각기 다른 handler를 등록하는 것을 조합해서 사용해 보자. 이것은 다음과 같다. 디폴트 UncaughtException handler를 등록 디폴트 handler를 오버라이드해서 쓰레드별 handler를 등록하기 예제를 보면 쉽게 이해 할 수 있다. 아래 예제에서는 thread1은 DefaultHandler를 이용하고, thread2는 Handler-2를 이용한다. import java.lang.Thread.UncaughtExceptionHandler; public class HandlingUncaughtExceptionsForThreads { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;DefaultHandler&quot;)); Thread thread1 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-1&quot;); //thread1.setUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Handler-1&quot;)); Thread thread2 = new Thread(new ExceptionLeakingTask(), &quot;Mythread-2&quot;); thread2.setUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Handler-2&quot;)); thread1.start(); thread2.start(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } 결과는 다음과 같다. thread1은 DefaultHandler를 이용하고, thread2는 Handler-2를 이용하여 Exception을 처리하는 것을 알 수 있다. [main] thread starts here... [main] thread ends here... DefaultHandler caught Exception in Thread - Mythread-1 =&gt; java.lang.RuntimeException Handler-2 caught Exception in Thread - Mythread-2 =&gt; java.lang.RuntimeException 2 Executor에서의 UncaughtException 처리하기 일단 Executor에서의 UncaughtException 처리는 일반 쓰레드에서의 처리와 크게 다르지 않음을 명심하자. 일반 쓰레드의 경우와 동일하게 UncaughtExceptionHandler 인터페이스를 구현하자. UncaughtExceptionHandler 인터페이스는 다음의 메소드 하나만을 가진다. void uncaughtException(Thread thread, Throwable e) UncaughtExceptionHandler를 이용하는 방법은 3가지가 있다. 2.2.1 시스템 내의 모든 쓰레드를 위한 디폴트 handler 지정하기 어떻게 사용하는지는 바로 예제를 통해 알아보자. import java.lang.Thread.UncaughtExceptionHandler; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; public class HandlingUncaughtExceptionsForExecutors { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Default Handler&quot;)); ExecutorService execService1 = Executors.newCachedThreadPool(); execService1.execute(new ExceptionLeakingTask()); execService1.execute(new ExceptionLeakingTask()); ExecutorService execService2 = Executors.newCachedThreadPool(); execService2.execute(new ExceptionLeakingTask()); execService2.execute(new ExceptionLeakingTask()); execService1.shutdown(); execService2.shutdown(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(){ handlerName = &quot;This&quot;; } public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } 결과는 다음과 같다. 시스템 전부에 걸쳐 디폴트 handler가 잘 처리하고 있음을 알 수 있다. [main] thread starts here... Default Handler caught Exception in Thread - pool-1-thread-2 =&gt; java.lang.RuntimeException Default Handler caught Exception in Thread - pool-1-thread-1 =&gt; java.lang.RuntimeException Default Handler caught Exception in Thread - pool-2-thread-1 =&gt; java.lang.RuntimeException Default Handler caught Exception in Thread - pool-2-thread-2 =&gt; java.lang.RuntimeException [main] thread ends here... 2.2.2 쓰레드 별로 handler를 각기 지정하기 ThreadFactory를 구현하고 아래 setUncaughtExceptionHandler()를 사용하면 된다. void Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 예제는 다음과 같다. ThreadFactory를 이용해 디폴트 handler 대신 각 쓰레드마다 UncaughtExceptionHandler를 등록했다. ThreadFactory는 이전에 사용한 Thread마다 이름을 부여하는데 사용한 NamedThreadsFactory를 상속받았다. import java.lang.Thread.UncaughtExceptionHandler; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; public class HandlingUncaughtExceptionsForExecutors { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); //Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Default Handler&quot;)); //ExecutorService execService1 = Executors.newCachedThreadPool(); ExecutorService execService1 = Executors.newCachedThreadPool(new ThreadFactoryWithExceptionHandler()); execService1.execute(new ExceptionLeakingTask()); execService1.execute(new ExceptionLeakingTask()); //ExecutorService execService2 = Executors.newCachedThreadPool(); ExecutorService execService2 = Executors.newCachedThreadPool(new ThreadFactoryWithExceptionHandler()); execService2.execute(new ExceptionLeakingTask()); execService2.execute(new ExceptionLeakingTask()); execService1.shutdown(); execService2.shutdown(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(){ handlerName = &quot;This&quot;; } public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class ThreadFactoryWithExceptionHandler extends NamedThreadsFactory { public Thread newThread(Runnable r) { Thread thread = super.newThread(r); thread.setUncaughtExceptionHandler(new ThreadExceptionHandler()); return thread; } } 결과는 다음과 같다. 시스템 전부에 걸쳐 DefaultHandler가 잘 처리하고 있음을 알 수 있다. [main] thread starts here... This caught Exception in Thread - MyThread-1 =&gt; java.lang.RuntimeException This caught Exception in Thread - MyThread-2 =&gt; java.lang.RuntimeException This caught Exception in Thread - MyThread-3 =&gt; java.lang.RuntimeException This caught Exception in Thread - MyThread-6 =&gt; java.lang.RuntimeException [main] thread ends here... 2.2.3 디폴트 handler와 쓰레드 별 handler를 조합해서 사용하기 위에서 살펴본 디폴트 handler와 쓰레드 별로 각기 다른 handler를 등록하는 것을 조합해서 사용해 보자. 이것은 일반 쓰레드와 동일한 컨셉이다. 디폴트 UncaughtException handler를 등록 디폴트 handler를 오버라이드해서 쓰레드별 handler를 등록하기 컨셉이 동일하므로 예제를 통해 확인해보자. 아래는 ThreadFactory에서 쓰레드를 만들때 번갈아 가며 디폴트가 아닌 handler를 사용하도록 한 예제이다. import java.lang.Thread.UncaughtExceptionHandler; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; public class HandlingUncaughtExceptionsForExecutors { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread.setDefaultUncaughtExceptionHandler(new ThreadExceptionHandler(&quot;Default Handler&quot;)); //ExecutorService execService1 = Executors.newCachedThreadPool(); ExecutorService execService1 = Executors.newCachedThreadPool(new ThreadFactoryWithExceptionHandlerAlternator()); execService1.execute(new ExceptionLeakingTask()); execService1.execute(new ExceptionLeakingTask()); //ExecutorService execService2 = Executors.newCachedThreadPool(); ExecutorService execService2 = Executors.newCachedThreadPool(new ThreadFactoryWithExceptionHandlerAlternator()); execService2.execute(new ExceptionLeakingTask()); execService2.execute(new ExceptionLeakingTask()); execService1.shutdown(); execService2.shutdown(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class ExceptionLeakingTask implements Runnable { @Override public void run() { throw new RuntimeException(); } } class ThreadExceptionHandler implements UncaughtExceptionHandler{ private String handlerName; public ThreadExceptionHandler(){ handlerName = &quot;This&quot;; } public ThreadExceptionHandler(String handlerName) { this.handlerName = handlerName; } @Override public void uncaughtException(Thread thread, Throwable e) { System.out.println(handlerName + &quot; caught Exception in Thread - &quot; + thread.getName() + &quot; =&gt; &quot; + e); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class ThreadFactoryWithExceptionHandlerAlternator extends NamedThreadsFactory { private static int count = 0; public Thread newThread(Runnable r) { Thread thread = super.newThread(r); if(count++ % 2 == 0) { thread.setUncaughtExceptionHandler(new ThreadExceptionHandler()); } return thread; } } 결과는 다음과 같다. [main] thread starts here... This caught Exception in Thread - MyThread-1 =&gt; java.lang.RuntimeException This caught Exception in Thread - MyThread-3 =&gt; java.lang.RuntimeException Default Handler caught Exception in Thread - MyThread-2 =&gt; java.lang.RuntimeException Default Handler caught Exception in Thread - MyThread-6 =&gt; java.lang.RuntimeException [main] thread ends here...",
    "url": "http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html",
    "relUrl": "/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html"
  },
  "54": {
    "id": "54",
    "title": "Java - (멀티쓰레딩 9) 쓰레드 Join하기",
    "content": "1 일반 쓰레드가 다른 쓰레드가 끝날때까지 대기하게 하기 1.1 이전에 살펴본 방식 쓰레드가 다른 쓰레드가 종료될 때까지 대기하는 방법은 이미 두 가지를 다루었다. (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기에서 다룬 Thread.isAlive()를 사용하여 계속 확인을 하는 것이다. (멀티쓰레딩 4) 쓰레드에서 값 반환에서 다룬 synchronized에서 wait()와 notify()를 사용하는 블록킹 방식이다. 첫번째 폴링하는 방법은 CPU의 낭비가 심하고 두번째 블록킹 방법은 제대로 구현하기 어렵다. 1.2 join()을 사용해서 다른 쓰레드 종료를 기다리기 세번째 방법이 Thread.join() 메소드를 사용하는 것이다. void Thread.join() 이 메소드는 wait()와 notify()처럼 동작을 하지만 사용하기가 상대적으로 편하다. 이미 대기하는 쓰레드가 종류한 경우에는 join()을 호출함과 동시에 리턴된다. 예제는 아래와 같다. thread1, 2, 3가 실행이 되는데 thread3이 가장 먼저 끝나고, thread1이 다음, 마지막으로 thread2가 종료되도록 되어 있다. 하지만, join()을 호출하는 순서가 thread1, 2, 3이므로 main thread는 thread1을 join한 뒤에야 thread2를 join하고 마지막으로 thread3를 join한다. import java.util.concurrent.TimeUnit; public class JoiningThreads { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); Thread thread1 = new Thread(new LoopTask(200), &quot;Thread-1&quot;); Thread thread2 = new Thread(new LoopTask(500), &quot;Thread-2&quot;); Thread thread3 = new Thread(new LoopTask(100), &quot;Thread-3&quot;); thread1.start(); thread2.start(); thread3.start(); thread1.join(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; joined &quot; + thread1.getName()); thread2.join(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; joined &quot; + thread2.getName()); thread3.join(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; joined &quot; + thread3.getName()); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private long sleepTime; private String taskId; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); for(int i = 0; i&lt;4; i++) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public LoopTask(long sleepTime) { this.id = ++count; this.taskId = &quot;Task-&quot; + id; this.sleepTime = sleepTime; } } 결과도 예상한 바와 마찬가지이다. thread내부에서 done이 출력한 순서는 3, 1, 2이지만, join이 출력된 순서는 1, 2, 3이다. [main] thread starts here... #### &lt;Thread-1,Task-1&gt; starting...#### &lt;Thread-1,Task-1&gt; TICK TICK #### &lt;Thread-3,Task-3&gt; starting...#### #### &lt;Thread-2,Task-2&gt; starting...#### &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-3,Task-3&gt; TICK TICK &lt;Thread-3,Task-3&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-3,Task-3&gt; TICK TICK &lt;Thread-3,Task-3&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK #### &lt;Thread-3,Task-3&gt; done...#### &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK #### &lt;Thread-1,Task-1&gt; done...#### [main] joined Thread-1 &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK #### &lt;Thread-2,Task-2&gt; done...#### [main] joined Thread-2 [main] joined Thread-3 [main] thread ends here... 1.3 join()을 사용해서 일반 쓰레드에서 값 반환하기 일반 쓰레드에서 값을 반환하는 방법은 이미 (멀티쓰레딩 4) 쓰레드에서 값 반환에서 다루었다. 그 글에서는 synchronized의 wait()와 notify()를 사용했다. 그런데 위에서 언급한 바와 같이 join()은 마치 wait()와 notify()처럼 동작한다. 이런 join()의 동작을 이용하여 일반 쓰레드에서 값을 반환하는 것을 구현해 보자. (멀티쓰레딩 4) 쓰레드에서 값 반환에서는 boolean 변수인 done과 synchronized {}를 사용했는데 join을 사용하면 그럴 필요가 없다. 단지, join()을 한 후에 get() 메소드를 이용해 결과값을 읽어오면 되는 것이다. 그것은 쓰레드는 종료되었지만, 태스크 객체는 남아있기 때문에 가능한 것이다. (멀티쓰레딩 4) 쓰레드에서 값 반환에서 사용한 예제를 수정한 예제는 다음과 같다. public class ReturningValueFromThreads { public static void main(String argc[]) throws InterruptedException { System.out.println(&quot;Main thread starts here...&quot;); MyThreadTask task1 = new MyThreadTask(); MyThreadTask task2 = new MyThreadTask(); MyThreadTask task3 = new MyThreadTask(); Thread thread1 = new Thread(task1,&quot;firstThread&quot;); Thread thread2 = new Thread(task2,&quot;secondThread&quot;); Thread thread3 = new Thread(task3,&quot;thirdThread&quot;); thread1.start(); thread2.start(); thread3.start(); thread1.join(); System.out.println(&quot;task1 result:&quot; + task1.getRandomSum()); thread2.join(); System.out.println(&quot;task2 result:&quot; + task2.getRandomSum()); thread3.join(); System.out.println(&quot;task3 result:&quot; + task3.getRandomSum()); System.out.println(&quot;Main thread ends here...&quot;); } } class MyThreadTask implements Runnable { private static int count = 0; private int id; private int randomSum = 0; @Override public void run(){ for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + id + &quot;&gt;TICK TICK &quot; + i); randomSum += Math.random()*1000; try { TimeUnit.MICROSECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } } } public int getRandomSum(){ return randomSum; } public MyThreadTask() { this.id = ++count; } } 결과도 예상한 바와 마찬가지이다. Main thread starts here... &lt;1&gt;TICK TICK 0 &lt;2&gt;TICK TICK 0 &lt;3&gt;TICK TICK 0 &lt;2&gt;TICK TICK 1 &lt;3&gt;TICK TICK 1 &lt;1&gt;TICK TICK 1 &lt;2&gt;TICK TICK 2 &lt;1&gt;TICK TICK 2 &lt;3&gt;TICK TICK 2 &lt;2&gt;TICK TICK 3 &lt;1&gt;TICK TICK 3 &lt;3&gt;TICK TICK 3 &lt;2&gt;TICK TICK 4 &lt;1&gt;TICK TICK 4 &lt;3&gt;TICK TICK 4 task1 result:3033 task2 result:2059 task3 result:3800 Main thread ends here... 2 Executor 태스크가 종료 될때까지 대기하기 다른 Executor 태스크가 끝날때까지 한 태스크를 정지해 놓는 방법을 알아보자. Java는 이를 위해 java.util.concurrent.CountDownLatch 클래스를 제공한다. 일반 쓰레드는 Thread.join()하나를 사용할 뿐이지만, Executor는 클래스를 사용해야 한다. CountDownLatch object는 종료할 태스크들과 그 태스크들이 종료하길 기다리는 태스크들이 모두 공유한다. 몇 개의 태스크들이 종료해야 하는 지를 0보다 큰 숫자로 정해놓고 하나씩 줄여나가면서 기다리는 방식이다. 대기하는 태스크: void await() 메소드를 호출하여 count가 0이 될때까지 블록되어 기다린다. 종료하는 태스크: void coutndown() 메소드를 실행이 끝난후에 호출한다. 이러면 count가 1 감소한다. count가 0이 되면 대기하던 태스크들은 모두 블록킹 상태에서 풀려나서 실행을 지속하게 된다. import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class JoiningExecutors { public static void main(String argc[]) { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService1 = Executors.newCachedThreadPool(new NamedThreadsFactory()); CountDownLatch doneSignal = new CountDownLatch(4); //set the initial count execService1.execute(new LoopTask(doneSignal)); execService1.execute(new LoopTask(doneSignal)); execService1.execute(new LoopTask(doneSignal)); execService1.execute(new LoopTask(doneSignal)); execService1.shutdown(); try { doneSignal.await(); //wait for the count = 0 System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; got the signal to continue...&quot;); } catch(InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; private CountDownLatch doneCountLatch; @Override public void run(){ String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); for(int i = 0; i&lt;5; i++) { System.out.println(&quot;&lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot; + i); try { TimeUnit.MILLISECONDS.sleep((long)Math.random()*1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; done...####&quot;); if(doneCountLatch != null) { doneCountLatch.countDown(); //count-- System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; LATCH COUNT =&quot; + doneCountLatch.getCount()); } } public LoopTask(CountDownLatch doneCountLatch) { this.id = ++count; this.taskId = &quot;LoopTask&quot; + id; this.doneCountLatch = doneCountLatch; } } 결과도 예상한 바와 마찬가지이다. COUNT가 0이 된다음에야 await()를 지나가서 got the signal to continue…를 출력한다. [main] thread starts here... #### &lt;MyThread-1,LoopTask1&gt; starting...#### #### &lt;MyThread-2,LoopTask2&gt; starting...#### &lt;MyThread-1,LoopTask1&gt; TICK TICK0 #### &lt;MyThread-3,LoopTask3&gt; starting...#### &lt;MyThread-2,LoopTask2&gt; TICK TICK0 &lt;MyThread-3,LoopTask3&gt; TICK TICK0 #### &lt;MyThread-4,LoopTask4&gt; starting...#### &lt;MyThread-4,LoopTask4&gt; TICK TICK0 &lt;MyThread-1,LoopTask1&gt; TICK TICK1 &lt;MyThread-1,LoopTask1&gt; TICK TICK2 &lt;MyThread-2,LoopTask2&gt; TICK TICK1 &lt;MyThread-3,LoopTask3&gt; TICK TICK1 &lt;MyThread-4,LoopTask4&gt; TICK TICK1 &lt;MyThread-3,LoopTask3&gt; TICK TICK2 &lt;MyThread-3,LoopTask3&gt; TICK TICK3 &lt;MyThread-3,LoopTask3&gt; TICK TICK4 &lt;MyThread-2,LoopTask2&gt; TICK TICK2 &lt;MyThread-1,LoopTask1&gt; TICK TICK3 &lt;MyThread-1,LoopTask1&gt; TICK TICK4 #### &lt;MyThread-1,LoopTask1&gt; done...#### &lt;MyThread-2,LoopTask2&gt; TICK TICK3 &lt;MyThread-2,LoopTask2&gt; TICK TICK4 #### &lt;MyThread-2,LoopTask2&gt; done...#### #### &lt;MyThread-3,LoopTask3&gt; done...#### #### &lt;MyThread-3,LoopTask3&gt; LATCH COUNT =1 &lt;MyThread-4,LoopTask4&gt; TICK TICK2 #### &lt;MyThread-2,LoopTask2&gt; LATCH COUNT =2 #### &lt;MyThread-1,LoopTask1&gt; LATCH COUNT =3 &lt;MyThread-4,LoopTask4&gt; TICK TICK3 &lt;MyThread-4,LoopTask4&gt; TICK TICK4 #### &lt;MyThread-4,LoopTask4&gt; done...#### #### &lt;MyThread-4,LoopTask4&gt; LATCH COUNT =0 [main] got the signal to continue... [main] thread ends here...",
    "url": "http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html",
    "relUrl": "/docs/java/2016-09-20-java-multithreading-thread-join.html"
  },
  "55": {
    "id": "55",
    "title": "Java - (멀티쓰레딩 10) 쓰레드 스케쥴링",
    "content": "1. 일반 쓰레드의 스케쥴링 1.1 개요 쓰레드 스케줄링을 위해 Java Thread는 두가지 API를 제공한다. java.util.Timer java.util.TimerTask 1.1.1 java.util.Timer 하나의 쓰레드를 생성하며, 그 하나의 쓰레드에서 모든 태스크를 실행한다. 스케쥴링 로직을 가지고 있어서 다음 태스크를 언제 실행할지 결정하는 API이다. - void schedule(TimerTask task, Date time) : 정해진 time에 한번 실행 - void schedule(TimerTask task, long delay) : 현재부터 delay millisec 이후 한번 실행 - void schedule(TimerTask task, Date firstTime, long period): firstTime에 처음 실행하고 period 간격으로 계속 실행 - void schedule(TimerTask task, long delay, long period): 현재부터 delay millisec 이후 처음 실행하고 period 간격으로 계속 실행 - void scheduleAtFixedRate(TimerTask task, Date firstTime, long period): firstTime에 처음 실행하고 period 간격으로 계속 고정 Rate으로 실행 - void scheduleAtFixedRate(TimerTask task, long delay, long period): 현재부터 delay millisec 이후 처음 실행하고 period 간격으로 계속 계속 고정 Rate으로 실행 - void cancel(): Timer를 terminate. **실행되고 있던 태스크는 계속 실행** 되며, 더이상 스케줄은 되지 않음 .TimerTask task: 실행될 태스크 .Date time: 실행 사작할 절대 시간 .long delay: 현재 시간으로부터의 delay offset. Milliseconds .long period: 태스크 실행시간 간의 고정 delay #### 1.1.2 java.util.TimerTask 스케줄링 대상이 되는 태스크 API이다. Runnable 인터페이스를 구현한 것이다. 반복된 실행을 위해 짧게 수행(short-lived)되어져야 한다. java long scheduleExecutionTime(): 동작하는 시간으로 가장 최신에 실행된 시간을 반환한다. boolean cancel(): 태스크를 취소한다. 만약 태스크가 구동중이면 구동은 지속되지만 다시 실행되지 않는다. 1.1.3 정리 Timer 객체당 한번에 하나의 태스크만 실행된다. Timer 태스크는 재빨리 종료되어야 한다. Application이 종료될 때 반드시 Timer.cancel()이 호출되어야 한다. 그렇지 않으면 leakage가 발생한다. Timer가 cancel되면 더이상 태스크는 스케줄되지 않는다. Timer 클래스는 thread-safe이다. Timer 클래스는 실시간성을 보장하지 않는다. 1.2 한번 실행되는 태스크 스케줄링하기 다음 두 메소드를 이용해서 태스크를 한번 스케줄링 할 수 있다. void schedule(TimerTask task, Date time) : 정해진 time에 한번 실행 void schedule(TimerTask task, long delay) : 현재부터 delay millisec 이후 한번 실행 예제는 다음과 같다. import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.TimeUnit; public class SchedulingTasksForOneTimeExecution { private static SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;Main thread starts here...&quot;); Timer timer = new Timer(&quot;Timer-thread&quot;, false); //false: user thread, true: daemon Date currentTime = new Date(); System.out.println(&quot;[&quot;+currentThreadName+&quot;] Current time&quot; + dateFormatter.format(currentTime)); Date scheduledTime = TimeUtils.getFutureTime(currentTime, 5000); ScheduledTask task0 = new ScheduledTask(100); timer.schedule(task0, scheduledTime); //schedule(TimerTask task, Date time) System.out.println(&quot;[&quot;+currentThreadName+&quot;] Task-0 is scheduled for running at &quot; + dateFormatter.format(currentTime)); long delayMillis = 10000; ScheduledTask task1 = new ScheduledTask(100); timer.schedule(task1, delayMillis); //schedule(TimerTask task, long delay) System.out.println(&quot;[&quot;+currentThreadName+&quot;] Task-1 is scheduled for running &quot;+ delayMillis/1000 + &quot; at &quot; + dateFormatter.format(currentTime)); ScheduledTask task2 = new ScheduledTask(100); timer.schedule(task2, delayMillis); //schedule(TimerTask task, long delay) System.out.println(&quot;[&quot;+currentThreadName+&quot;] Task-2 is scheduled for running &quot;+ delayMillis/1000 + &quot; at &quot; + dateFormatter.format(currentTime)); task1.cancel(); //task1 canceled TimeUnit.MILLISECONDS.sleep(12000); timer.cancel(); System.out.println(&quot;Main thread ends here...&quot;); } } class ScheduledTask extends TimerTask { private static int count = 0; private long sleepTime; private String taskId; private SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); @Override public void run(){ Date startTime = new Date(); Date SchdulingForRunningTime = new Date(super.scheduledExecutionTime()); String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot; &gt; Scheduled to run at &quot; + dateFormatter.format(SchdulingForRunningTime) + &quot;, Actually started at &quot; + dateFormatter.format(startTime) + &quot;####&quot;); for(int i = 0; i&lt;5; i++) { try { TimeUnit.MICROSECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot; &gt;Finished at &quot; + dateFormatter.format(new Date()) + &quot;####&quot;); } public ScheduledTask(long sleepTime) { this.sleepTime = sleepTime; this.taskId = &quot;ScheduledTask-&quot; + count++; } } /* Utility class to get the future time*/ class TimeUtils { private TimeUtils() { } public static Date getFutureTime(Date initialTime, long millisToAdd) { Calendar cal = GregorianCalendar.getInstance(); cal.setTimeInMillis(initialTime.getTime() + millisToAdd); return cal.getTime(); } } 결과는 다음과 같다. task0, 1, 2 모두 스케줄링을 한 후 task1을 취소했더니 task0와 task2만 실행되고 task1는 실행되지 않음을 알 수 있다. Main thread starts here... [main] Current time20-09-2016 23:49:32.518 [main] Task-0 is scheduled for running at 20-09-2016 23:49:32.518 [main] Task-1 is scheduled for running 10 at 20-09-2016 23:49:32.518 [main] Task-2 is scheduled for running 10 at 20-09-2016 23:49:32.518 #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 20-09-2016 23:49:37.518, Actually started at 20-09-2016 23:49:37.521#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 20-09-2016 23:49:37.518#### #### &lt;Timer-thread,ScheduledTask-2 &gt; Scheduled to run at 20-09-2016 23:49:42.519, Actually started at 20-09-2016 23:49:42.522#### #### &lt;Timer-thread,ScheduledTask-2 &gt;Finished at 20-09-2016 23:49:42.519#### Main thread ends here... 1.3 반복되는 태스크 스케줄링하기 아래 메소드를 이용하여 반복되는 태스크를 스케줄링한다. void schedule(TimerTask task, Date firstTime, long period): firstTime에 처음 실행하고 period 간격으로 계속 실행 void schedule(TimerTask task, long delay, long period): 현재부터 delay millisec 이후 처음 실행하고 period 간격으로 계속 실행 간격은 이전 태스크 시작부터 다음 태스크 시작까지이다. 만약 정한 간격보다 길어지면 시작 시간이 밀려서 시작하게 된다. package a1; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.TimeUnit; public class SchedulingTasksFixedDelayRepeatedExecution { private static SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;Main thread starts here...&quot;); Timer timer = new Timer(&quot;Timer-thread&quot;, false); //false: user thread, true: daemon Date currentTime = new Date(); System.out.println(&quot;[&quot;+currentThreadName+&quot;] Current time&quot; + dateFormatter.format(currentTime)); Date scheduledTime = TimeUtils.getFutureTime(currentTime, 1000); ScheduledTask task0 = new ScheduledTask(100); long periodMillis = 1000; timer.schedule(task0, scheduledTime, periodMillis); //schedule(TimerTask task, Date firstTime, long period) System.out.println(&quot;[&quot;+currentThreadName+&quot;] Task-0 is scheduled for running at &quot; + dateFormatter.format(currentTime)); long delayMillis = 5000; periodMillis = 5000; ScheduledTask task1 = new ScheduledTask(100); timer.schedule(task1, delayMillis, periodMillis); //schedule(TimerTask task, long delay, long period) System.out.println(&quot;[&quot;+currentThreadName+&quot;] Task-1 is scheduled for running &quot;+ delayMillis/1000 + &quot; at &quot; + dateFormatter.format(currentTime)); TimeUnit.MILLISECONDS.sleep(11000); timer.cancel(); System.out.println(&quot;Main thread ends here...&quot;); } } class ScheduledTask extends TimerTask { private static int count = 0; private long sleepTime; private String taskId; private SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); @Override public void run(){ Date startTime = new Date(); Date SchdulingForRunningTime = new Date(super.scheduledExecutionTime()); String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot; &gt; Scheduled to run at &quot; + dateFormatter.format(SchdulingForRunningTime) + &quot;, Actually started at &quot; + dateFormatter.format(startTime) + &quot;####&quot;); for(int i = 0; i&lt;5; i++) { try { TimeUnit.MICROSECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot; &gt;Finished at &quot; + dateFormatter.format(new Date()) + &quot;####&quot;); } public ScheduledTask(long sleepTime) { this.sleepTime = sleepTime; this.taskId = &quot;ScheduledTask-&quot; + count++; } } /* Utility class to get the future time*/ class TimeUtils { private TimeUtils() { } public static Date getFutureTime(Date initialTime, long millisToAdd) { Calendar cal = GregorianCalendar.getInstance(); cal.setTimeInMillis(initialTime.getTime() + millisToAdd); return cal.getTime(); } } 결과는 다음과 같다. task0은 1초간격으로 계속 실행되고, task1은 5초간격으로 실행되다가 timer.cancel()이 호출되면 종료된다. Main thread starts here... [main] Current time21-09-2016 00:02:31.106 [main] Task-0 is scheduled for running at 21-09-2016 00:02:31.106 [main] Task-1 is scheduled for running 5 at 21-09-2016 00:02:31.106 #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:32.109, Actually started at 21-09-2016 00:02:32.109#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:32.109#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:33.111, Actually started at 21-09-2016 00:02:33.111#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:33.111#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:34.115, Actually started at 21-09-2016 00:02:34.115#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:34.115#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:35.119, Actually started at 21-09-2016 00:02:35.119#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:35.119#### #### &lt;Timer-thread,ScheduledTask-1 &gt; Scheduled to run at 21-09-2016 00:02:36.109, Actually started at 21-09-2016 00:02:36.109#### #### &lt;Timer-thread,ScheduledTask-1 &gt;Finished at 21-09-2016 00:02:36.109#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:36.120, Actually started at 21-09-2016 00:02:36.120#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:36.120#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:37.122, Actually started at 21-09-2016 00:02:37.122#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:37.122#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:38.124, Actually started at 21-09-2016 00:02:38.124#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:38.124#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:39.128, Actually started at 21-09-2016 00:02:39.128#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:39.128#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:40.129, Actually started at 21-09-2016 00:02:40.129#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:40.129#### #### &lt;Timer-thread,ScheduledTask-1 &gt; Scheduled to run at 21-09-2016 00:02:41.113, Actually started at 21-09-2016 00:02:41.113#### #### &lt;Timer-thread,ScheduledTask-1 &gt;Finished at 21-09-2016 00:02:41.113#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:41.129, Actually started at 21-09-2016 00:02:41.129#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:41.129#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:42.131, Actually started at 21-09-2016 00:02:42.131#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:42.131#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:43.136, Actually started at 21-09-2016 00:02:43.136#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:43.136#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:44.139, Actually started at 21-09-2016 00:02:44.139#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:44.139#### #### &lt;Timer-thread,ScheduledTask-0 &gt; Scheduled to run at 21-09-2016 00:02:45.144, Actually started at 21-09-2016 00:02:45.144#### #### &lt;Timer-thread,ScheduledTask-0 &gt;Finished at 21-09-2016 00:02:45.144#### Main thread ends here... 1.4 FixedRate로 반복되는 태스크 스케줄링하기 아래 메소드를 이용하여 반복되는 태스크를 스케줄링한다. void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) void scheduleAtFixedRate(TimerTask task, long delay, long period) 시작하는 시점은 맨 처음 태스크 실행 시간을 기준으로 고정되어 계산 된다. FixedRate가 아닌 경우는 바로 이전의 시작을 기준으로 계산한다. 만약 정한 간격보다 길어지면 시작 시간이 밀려서 시작하는 것이 아니라 바로 그 시간에 시작한다. 그러므로 절대 시간에 관한 요구사항을 가진 경우 FixedRate을 사용한다. 컨셉을 이해한다면 이전 예와 동일하므로 에제를 가지고 실행하지 않는다. 2. Executor 태스크 스케줄링 2.1 개요 태스크 스케줄링을 위해 Executors는 다음 두개의 쓰레드 풀을 별도로 제공한다. Single-thread-scheduled-executor: 하나의 쓰레드로 여러 태스크의 스케줄링 Scheduled-thread-pool: 여러 쓰레드로 여러 태스크의 스케줄링 Executors 클래스를 사용해 생성하는 것은 다음과 같이 한다. static ScheduledExecutorService newSingleThreadScheduledExecutor() static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) ScheduledExecutorService 인터페이스는 ExecutorService 인터페이스를 확장한 것으로 다음과 같은 메소드를 정의하고 있다. ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable, long initialDelay, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; scheduleWithFixedRate(Runnable, long initialDelay, long delay, TimeUnit unit) 일반 쓰레드와 다른 점은 정확한 시간을 지정하여 구동하는 것이 없다는 것이다. ScheduledFuture 인터페이스는 Future 인터페이스와 Delayed 인터페이스를 상속한다. Delayed 인터페이스는 다음의 메소드만을 정의한다. 이것은 다음 실행 스케줄까지 얼마나 남았는지 반환한다. long getDelay(TimeUnit unit) 2.2 한번 실행되는 태스크 스케줄링하기 다음 두 메소드를 이용해서 태스크를 한번 스케줄링 할 수 있다. ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; schedule(Callable callable, long delay, TimeUnit unit) 실행은 Single-thread-scheduled-executor 또는 Scheduled-thread-pool 중 하나를 사용하여 스케줄될 수 있다. TimerTask는 필요없으며 Runnable 또는 Callable이면 된다. 예제는 다음과 같다. import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class SchedulingTasksFixedDelayRepeatedExecution { private static SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;Main thread starts here...&quot;); ScheduledExecutorService execService = Executors.newSingleThreadScheduledExecutor(new NamedThreadsFactory()); System.out.println(&quot;[&quot;+currentThreadName+&quot;] Current time&quot; + dateFormatter.format(new Date())); ScheduledFuture&lt;?&gt; schedFuture1 = execService.schedule(new ScheduledRunnableTask(0), 2, TimeUnit.SECONDS); ScheduledFuture&lt;Integer&gt; schedFuture2 = execService.schedule(new ScheduledCallableTask(0), 4, TimeUnit.SECONDS); execService.shutdown(); try { System.out.println(&quot;Task1 result = &quot; + schedFuture1.get()); System.out.println(&quot;Task2 result = &quot; + schedFuture2.get()); } catch (ExecutionException e) { e.printStackTrace(); } System.out.println(&quot;Main thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class ScheduledRunnableTask implements Runnable { private static int count = 0; private long sleepTime; private String taskId; private SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); @Override public void run(){ Date startTime = new Date(); String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot; &gt; Actually started at &quot; + dateFormatter.format(startTime) + &quot;####&quot;); for(int i = 0; i&lt;5; i++) { try { TimeUnit.MICROSECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot; &gt;Finished at &quot; + dateFormatter.format(new Date()) + &quot;####&quot;); } public ScheduledRunnableTask(long sleepTime) { this.sleepTime = sleepTime; this.taskId = &quot;ScheduledRunnableTask-&quot; + count++; } } class ScheduledCallableTask implements Callable&lt;Integer&gt; { private static int count = 0; private long sleepTime; private String taskId; private SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); @Override public Integer call() throws Exception { Date startTime = new Date(); String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot; &gt; Actually started at &quot; + dateFormatter.format(startTime) + &quot;####&quot;); for(int i = 0; i&lt;5; i++) { try { TimeUnit.MICROSECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot; &gt;Finished at &quot; + dateFormatter.format(new Date()) + &quot;####&quot;); return 10; //whatever } public ScheduledCallableTask(long sleepTime) { this.sleepTime = sleepTime; this.taskId = &quot;ScheduledCallableTask-&quot; + count++; } } 결과는 다음과 같다. Runnable 태스크가 2초, Callable이 4초후에 실행되었다. Main thread starts here... [main] Current time21-09-2016 00:42:41.359 #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:42:43.365#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:42:43.365#### Task1 result = null #### &lt;MyThread-1,ScheduledCallableTask-0 &gt; Actually started at 21-09-2016 00:42:45.362#### #### &lt;MyThread-1,ScheduledCallableTask-0 &gt;Finished at 21-09-2016 00:42:45.362#### Task2 result = 10 Main thread ends here... 2.3 반복 실행되는 태스크 스케줄링하기 반복 실행되는 태스크는 다음의 메소드를 이용한다. ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable, long initialDelay, long delay, TimeUnit unit) 주의할 점은 다음과 같다. 인터벌은 이전 태스크 실행이 언제 끝났느냐에 따라 달라진다. 일반 쓰레드가 시작을 기준으로 정하는 것과 구별된다. Callable 태스크의 반복은 지원하지 않는다. Runnable만 지원된다. 예제는 다음과 같다. 4초후에 태스크가 실행되고 매 2초마다 반복되는 것이다. import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public class SchedulingTasksFixedDelayRepeatedExecution { private static SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;Main thread starts here...&quot;); ScheduledExecutorService execService = Executors.newSingleThreadScheduledExecutor(new NamedThreadsFactory()); System.out.println(&quot;[&quot;+currentThreadName+&quot;] Current time&quot; + dateFormatter.format(new Date())); //ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable, long initialDelay, long delay, TimeUnit unit) ScheduledFuture&lt;?&gt; schedFuture = execService.scheduleWithFixedDelay(new ScheduledRunnableTask(0), 4, 2, TimeUnit.SECONDS); TimeUnit.MILLISECONDS.sleep(10000); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } class NamedThreadsFactory implements ThreadFactory { private static int count = 0; private static String Name = &quot;MyThread-&quot;; @Override public Thread newThread(Runnable r) { return new Thread(r, Name + ++count); } } class ScheduledRunnableTask implements Runnable { private static int count = 0; private long sleepTime; private String taskId; private SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); @Override public void run(){ Date startTime = new Date(); String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot; &gt; Actually started at &quot; + dateFormatter.format(startTime) + &quot;####&quot;); for(int i = 0; i&lt;5; i++) { try { TimeUnit.MICROSECONDS.sleep(sleepTime); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot; &gt;Finished at &quot; + dateFormatter.format(new Date()) + &quot;####&quot;); } public ScheduledRunnableTask(long sleepTime) { this.sleepTime = sleepTime; this.taskId = &quot;ScheduledRunnableTask-&quot; + count++; } } 결과는 다음과 같다. Main thread starts here... [main] Current time21-09-2016 00:50:15.020 #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:19.027#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:19.027#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:21.031#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:21.031#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:23.035#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:23.036#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:25.039#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:25.039#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:27.043#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:27.043#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:50:29.048#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:50:29.048#### Main thread ends here... 2.4 FixedRate로 반복 실행되는 태스크 스케줄링하기 반복 실행되는 태스크는 다음의 메소드를 이용한다. ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable, long initialDelay, long delay, TimeUnit unit) 주의할 점은 다음과 같다. 맨처음 태스크의 시작 시간을 기준으로 각각 실행이 스케줄 된다. 일반 쓰레드의 FixedRate와 동일한 점이다. Callable 태스크의 반복은 지원하지 않는다. Runnable만 지원된다. 예제는 다음과 같다. 4초후에 태스크가 실행되고 매 2초마다 반복되는 것으로 scheduleWithFixedDelay의 경우와 메소드 이름만 다를 뿐이다. public class SchedulingTasksFixedDelayRepeatedExecution { private static SimpleDateFormat dateFormatter = new SimpleDateFormat(&quot;dd-MM-yyyy HH:mm:ss.SSS&quot;); public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;Main thread starts here...&quot;); ScheduledExecutorService execService = Executors.newSingleThreadScheduledExecutor(new NamedThreadsFactory()); System.out.println(&quot;[&quot;+currentThreadName+&quot;] Current time&quot; + dateFormatter.format(new Date())); //ScheduledFuture&lt;?&gt; schedFuture = execService.scheduleWithFixedDelay(new ScheduledRunnableTask(0), 4, 2, TimeUnit.SECONDS); ScheduledFuture&lt;?&gt; schedFuture = execService.scheduleAtFixedRate(new ScheduledRunnableTask(0), 4, 2, TimeUnit.SECONDS); TimeUnit.MILLISECONDS.sleep(10000); execService.shutdown(); System.out.println(&quot;Main thread ends here...&quot;); } } 결과는 다음과 같다. Main thread starts here... [main] Current time21-09-2016 00:54:42.461 #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:54:46.467#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:54:46.468#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:54:48.464#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:54:48.464#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt; Actually started at 21-09-2016 00:54:50.466#### #### &lt;MyThread-1,ScheduledRunnableTask-0 &gt;Finished at 21-09-2016 00:54:50.466#### Main thread ends here...",
    "url": "http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html",
    "relUrl": "/docs/java/2016-09-20-java-multithreading-thread-scheduling.html"
  },
  "56": {
    "id": "56",
    "title": "Java - (멀티쓰레딩 7) 쓰레드 중지하기",
    "content": "쓰레드를 중지하는 방법을 살펴보자. 지금까지와 같이 일반 쓰레드를 중지하는 방법과 Executor를 중지하는 법을 각각 살펴보자. 그리고 Executor의 경우 한번에 모든 태스크를 중지하는 법도 살펴보자. 일반 쓰레드를 중지시키는 것과 Executor를 중지시키는 것의 차이는 다음과 같다. 일반 쓰레드: 쓰레드를 종료한다. Executor: 태스크를 종료한다. 모든 태스크가 종료되면 쓰레드는 자동으로 종료한다. 1. 일반 쓰레드에서 쓰레드 중지 시키기 일반 쓰레드를 종료하는 방법은 다음 3가지가 있다. 플래그 사용하여 쓰레드 중지 Non-blocking 태스크의 경우 인터럽트 발생 여부 확인하여 쓰레드 중지 Blocking 태스크의 경우 인터럽트를 catch하여 쓰레드 중지 1.1 플래그 사용하여 쓰레드 중지 일반적인 쓰레드에서 loop을 도는 태스크를 종료하는 대표적인 방법은 플래그를 사용하는 것이다. Loop을 돌면서 종료 플래그를 확인하여 true이면 종료하는 방법이다. 쓰레드간의 동기화를 위해 volatile 키워드를 이용해 플래그 변수를 선언하고 synchronized를 이용해 atomic하게 만든다. 예제는 다음과 같다. import java.util.concurrent.TimeUnit; public class TerminatingNormalThreadWithFlag { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); LoopTask task1 = new LoopTask(); LoopTask task2 = new LoopTask(); new Thread(task1, &quot;Thread-1&quot;).start(); new Thread(task2, &quot;Thread-2&quot;).start(); TimeUnit.MILLISECONDS.sleep(1000); task1.cancel(); task2.cancel(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; private volatile boolean shutdown = false; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(this) { if(shutdown) { break; } } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public void cancel() { System.out.println(&quot;... &lt;&quot; + Thread.currentThread().getName() +&quot;,&quot; + taskId + &quot;&gt; shutting down...&quot;); synchronized (this) { this.shutdown = true; } } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } 결과는 다음과 같다. [main] thread starts here... #### &lt;Thread-1,Task-1&gt; starting...#### #### &lt;Thread-2,Task-2&gt; starting...#### &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK ... &lt;main,Task-1&gt; shutting down... ... &lt;main,Task-2&gt; shutting down... [main] thread ends here... #### &lt;Thread-2,Task-2&gt; done...#### #### &lt;Thread-1,Task-1&gt; done...#### 1.2 Non-blocking 태스크의 경우 인터럽트 발생 여부 확인하여 쓰레드 중지 블록되지 않고 동작하는 쓰레드를 중지시키는 좋은 방법은 인터럽트를 사용하여 종료하는 것이다. 인터럽트를 제공하는 Thread API는 다음과 같다. void Thread.interrupt(): 쓰레드에 인터럽트를 호출 static boolean Thread.interrupted() : 쓰레드 내부에서 쓰레드가 인터럽트 되었는지 확인하기 위해 사용 boolean Thread.isInterrupted(): 다른 쓰레드에서 호출하여 쓰레드가 인터럽트 되었는지 확인 주의할 점은 blocking 함수(타이머 등)와 함께 사용하면 Exception이 발생한다는 것이다. 이는 컴파일 단계에서는 나타나지 않는다. 아래 예는 인터럽트를 사용해 쓰레드를 중지시키는 예제인데 타이머를 사용하지 않는 Loop을 만들기 위해 doSomeWork()를 만들었다. import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; import java.util.concurrent.TimeUnit; public class TerminatingNormalNonBlockingThreadWithInterrupt { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); LoopTask task1 = new LoopTask(); LoopTask task2 = new LoopTask(); Thread thread1 = new Thread(task1, &quot;Thread-1&quot;); Thread thread2 = new Thread(task2, &quot;Thread-2&quot;); thread1.start(); thread2.start(); TimeUnit.MILLISECONDS.sleep(500); thread1.interrupt(); thread2.interrupt(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; private final int DATA_SIZE = 100000; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); doSomeWork(); //Interrupt can not work with timer because the timer is a blocking function if(Thread.interrupted()){ //Thread.interrupted() break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } private void doSomeWork(){ for(int i = 0; i&lt;2 ; i++) { Collections.sort(generateDataSet()); } } private List&lt;Integer&gt; generateDataSet(){ List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Random randomGenerator = new Random(); for(int i = 0; i&lt;DATA_SIZE; i++) { intList.add(randomGenerator.nextInt(DATA_SIZE)); } return intList; } } 결과는 아래와 같이 잘 동작함을 알 수 있다. [main] thread starts here... #### &lt;Thread-1,Task-1&gt; starting...#### #### &lt;Thread-2,Task-2&gt; starting...#### &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK [main] thread ends here... #### &lt;Thread-1,Task-1&gt; done...#### #### &lt;Thread-2,Task-2&gt; done...#### 1.3 Blocking 태스크의 경우 인터럽트를 catch하여 쓰레드 중지 블록킹 쓰레드에서는 어떻게 종료를 시킬까? 그 방법은 위 방법을 응용하면 된다. 즉, 인터럽트를 이용해 중지를 시키면 된다. 인터럽트를 외부 쓰레드에서 발생시키면 Sleep과 같은 Blocking함수에서 Interrupted Exception이 발생하는데 이때 그 Exception catch 블록에서 loop을 중지시키는 것이다. import java.util.concurrent.TimeUnit; public class TerminatingNormalBlockingThreadWithInterrupt { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); LoopTask task1 = new LoopTask(); LoopTask task2 = new LoopTask(); Thread thread1 = new Thread(task1, &quot;Thread-1&quot;); Thread thread2 = new Thread(task2, &quot;Thread-2&quot;); thread1.start(); thread2.start(); TimeUnit.MILLISECONDS.sleep(500); thread1.interrupt(); thread2.interrupt(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; Sleep Interrupted. Cancelling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } 결과는 아래와 같이 Interrupted Exception에 의해 종료됨을 확인 할 수 있다. [main] thread starts here... #### &lt;Thread-1,Task-1&gt; starting...#### #### &lt;Thread-2,Task-2&gt; starting...#### &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-2,Task-2&gt; TICK TICK &lt;Thread-1,Task-1&gt; TICK TICK [main] thread ends here... &lt;Thread-1,Task-1&gt; Sleep Interrupted. Cancelling... #### &lt;Thread-1,Task-1&gt; done...#### &lt;Thread-2,Task-2&gt; Sleep Interrupted. Cancelling... #### &lt;Thread-2,Task-2&gt; done...#### 2. 개개의 Executor 태스크를 중지 시키기 Executor에서는 쓰레드를 중지하는 개념이 아니라 태스크를 중지시킨다. 그 외에는 일반 쓰레드에서의 중지 방법과 대부분 유사하다. 플래그 사용하여 태스크 중지 Non-blocking 태스크의 경우 인터럽트 발생 여부 확인하여 중지 Blocking 태스크의 경우 인터럽트를 catch하여 중지 2.1 플래그 사용하여 태스크 중지 일반적인 쓰레드에서 loop을 도는 태스크를 종료하는 대표적인 방법은 플래그를 사용하는 것이다. Loop을 돌면서 종료 플래그를 확인하여 true이면 종료하는 방법이다. 쓰레드간의 동기화를 위해 volatile 키워드를 이용해 플래그 변수를 선언하고 synchronized를 이용해 atomic하게 만든다. 예제는 다음과 같다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class TerminatingExecutorWithFlag { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool(); LoopTask task1 = new LoopTask(); execService.execute(task1); execService.shutdown(); TimeUnit.MILLISECONDS.sleep(1000); task1.cancel(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; private volatile boolean shutdown = false; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(this) { if(shutdown) { break; } } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public void cancel() { System.out.println(&quot;... &lt;&quot; + Thread.currentThread().getName() +&quot;,&quot; + taskId + &quot;&gt; shutting down...&quot;); synchronized (this) { this.shutdown = true; } } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } 결과는 다음과 같다. [main] thread starts here... #### &lt;pool-1-thread-1,Task-1&gt; starting...#### &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK ... &lt;main,Task-1&gt; shutting down... [main] thread ends here... #### &lt;pool-1-thread-1,Task-1&gt; done...#### 2.2 Non-blocking 태스크의 경우 인터럽트 발생 여부 확인하여 중지 Executor에서 블록되지 않고 동작하는 태스크를 중지시키는 좋은 방법은 인터럽트를 사용하여 종료하는 것이다. Executor에서 인터럽트를 제공하는 Thread API는 다음과 같다. boolean Future.cancel(boolean mayInterruptIfRunning): Executor의 태스크 멈추기. 만약 태스크가 이미 다른 이유로 cancel되었다면 false를 반환. 일반 쓰레드에서의 Thread.interrupt()와 유사한 역할 static boolean Thread.interrupted() : 태스크가 인터럽트 되었는지 확인하기 위해 사용. 일반 쓰레드와 동일 boolean Future.isCanceled(): 다른 쓰레드에서 호출. boolean Thread.isInterrupted()와 유사 중요한 것은 위의 API는 쓰레드가 아닌 태스크를 중지시키는 것이라는 것이다. 아래 예를 보면 하나의 쓰레드만 동작하면서 순차적으로 태스크를 종료시키는 예이다. 쓰레드를 점유한 첫번째 태스크를 종료시키면 두번째 태스크가 동작하고 두번째 태스크를 종료시키면 더이상 태스크가 없으므로 쓰레드가 멈추게 된다. import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; public class TerminatingNonBlockingExecutorWithInterrupt { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newSingleThreadExecutor(); LoopTask task1 = new LoopTask(); LoopTask task2 = new LoopTask(); Future&lt;?&gt; future1 = execService.submit(task1); Future&lt;?&gt; future2 = execService.submit(task2); execService.shutdown(); TimeUnit.MILLISECONDS.sleep(200); future1.cancel(true); TimeUnit.MILLISECONDS.sleep(100); future2.cancel(true); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; private final int DATA_SIZE = 100000; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); doSomeWork(); if(Thread.interrupted()){ System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; got an interrupt! ..canceling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } private void doSomeWork(){ for(int i = 0; i&lt;2 ; i++) { Collections.sort(generateDataSet()); } } private List&lt;Integer&gt; generateDataSet(){ List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Random randomGenerator = new Random(); for(int i = 0; i&lt;DATA_SIZE; i++) { intList.add(randomGenerator.nextInt(DATA_SIZE)); } return intList; } } 결과는 아래와 같이 첫번째 태스크가 멈춘 후 같은 쓰레드에서 두번째 쓰레드가 동작한다. [main] thread starts here... [main] thread starts here... #### &lt;pool-1-thread-1,Task-1&gt; starting...#### &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; got an interrupt! ..canceling... #### &lt;pool-1-thread-1,Task-1&gt; done...#### #### &lt;pool-1-thread-1,Task-2&gt; starting...#### &lt;pool-1-thread-1,Task-2&gt; TICK TICK &lt;pool-1-thread-1,Task-2&gt; TICK TICK &lt;pool-1-thread-1,Task-2&gt; TICK TICK [main] thread ends here... &lt;pool-1-thread-1,Task-2&gt; got an interrupt! ..canceling... #### &lt;pool-1-thread-1,Task-2&gt; done...#### 2.3 Blocking 태스크의 경우 인터럽트를 catch하여 중지 블록킹 태스크를 중지시키는 것도 일반 쓰레드의 경우와 동일하다. 외부 쓰레드에서 cancel()을 호추하면 Sleep과 같은 Blocking함수에서 Interrupted Exception이 발생하는데 이때 그 Exception catch 블록에서 loop을 중지시키는 것이다. 아래의 예도 하나의 쓰레드에서 두개의 태스크를 submit한 경우로 InterruptedException을 이용해 순차적으로 중지시킨다. import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; public class TerminatingBlockingExecutorWithInterrupt { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newSingleThreadExecutor(); LoopTask task1 = new LoopTask(); LoopTask task2 = new LoopTask(); Future&lt;?&gt; future1 = execService.submit(task1); Future&lt;?&gt; future2 = execService.submit(task2); execService.shutdown(); TimeUnit.MILLISECONDS.sleep(200); future1.cancel(true); TimeUnit.MILLISECONDS.sleep(100); future2.cancel(true); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class LoopTask implements Runnable { private static int count = 0; private int id; private String taskId; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; Sleep Interrupted. Cancelling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public LoopTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } 결과는 아래와 같이 Interrupted Exception에 의해 종료됨을 확인 할 수 있다. [main] thread starts here... [main] thread starts here... #### &lt;pool-1-thread-1,Task-1&gt; starting...#### &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; Sleep Interrupted. Cancelling... #### &lt;pool-1-thread-1,Task-1&gt; done...#### #### &lt;pool-1-thread-1,Task-2&gt; starting...#### &lt;pool-1-thread-1,Task-2&gt; TICK TICK &lt;pool-1-thread-1,Task-2&gt; TICK TICK [main] thread ends here... &lt;pool-1-thread-1,Task-2&gt; Sleep Interrupted. Cancelling... #### &lt;pool-1-thread-1,Task-2&gt; done...#### 3. 모든 Executor를 한번에 중지시키기 ExecutorService는 모든 태스크를 한번에 중지시키는 shutdownNow() 메소드를 제공하고 있다. List ExecutorService.shutdownNow() 내부적으로는 위에서 살펴본 인터럽트를 사용하는 방식이다. 반환되는 List는 아직 종료되지 않은 태스크들의 목록이다. 만약 모든 태스크들이 종료가 되었다면 ExecutorService도 종료한다. Non-blocking 태스크는 물론이고 Blocking 태스크 또한 종료 시키는데 위에서 살펴본 인터럽트를 사용하는 방식이므로 Exception을 정확히 다루어야 한다. 만약 아직 실행이 시작되지 않은 태스크가 있다면 종료된 것으로 처리한다. shutdownNow()를 호출후에 태스크가 완전히 종료 될 때까지 기다리기 위해서는 awaitTermiation() 메소드를 사용한다. boolean ExecService.awaitTermination(long timeout, TimeUnit unit) shutdown 이후 일정시간동안 block된다. timeout과 unit을 이용해 blocking되는 시간을 지정한다. shutdown 이후 모든 태스크가 종료될때 까지 block된다. 외부에서 실행되는 쓰레드에 인터럽트를 걸때까지 block된다. 위의 3가지 경우 중 가장 빨리 조건에 해제되는 시점까지 block되며 이때 모든 태스크가 종료되었으면 true를 반환한다. 예제는 다음과 같다. Blocking, Non-Blocking, Callable 태스크 모두를 한번에 종료하는 예제이다. 각각 모두 인터럽트를 잘 처리해야 한다. non-Blocking은 인터럽트 여부를 확인해야 하고, Blocking은 InterruptedException을 catch해야 한다. import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.TimeUnit; public class TerminatingAllExecutors { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newCachedThreadPool(); BlockingTask blockingTask = new BlockingTask(); NonBlockingTask nonBlockingTask = new NonBlockingTask(); CallableTask callableTask = new CallableTask(); //Runnable execService.execute(blockingTask); execService.execute(nonBlockingTask); //Callable execService.submit(callableTask); TimeUnit.MILLISECONDS.sleep(1000); execService.shutdownNow(); //shutDownNow System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; shutdownNow() invoked &quot;); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; All threads terminated: &quot; + execService.awaitTermination(500, TimeUnit.MILLISECONDS)); //awaitTermination System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } class BlockingTask implements Runnable { private static int count = 0; private int id; private String taskId; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; Sleep Interrupted. Cancelling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public BlockingTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } class NonBlockingTask implements Runnable { private static int count = 0; private int id; private String taskId; private final int DATA_SIZE = 100000; @Override public void run() { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); doSomeWork(); if(Thread.interrupted()){ System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; Thread.interrupted() is true: Cancelling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); } public NonBlockingTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } private void doSomeWork(){ for(int i = 0; i&lt;2 ; i++) { Collections.sort(generateDataSet()); } } private List&lt;Integer&gt; generateDataSet(){ List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); Random randomGenerator = new Random(); for(int i = 0; i&lt;DATA_SIZE; i++) { intList.add(randomGenerator.nextInt(DATA_SIZE)); } return intList; } } class CallableTask implements Callable&lt;Integer&gt; { private static int count = 0; private int id; private String taskId; private int randomSum = 0; @Override public Integer call() throws Exception { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;#### &lt;&quot; + currentThreadName +&quot;,&quot; + taskId + &quot;&gt; starting...####&quot;); while(true) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; TICK TICK&quot;); randomSum += Math.random()*1000; try { TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { System.out.println(&quot;&lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; Sleep Interrupted. Cancelling...&quot;); break; } } System.out.println(&quot;#### &lt;&quot; + currentThreadName + &quot;,&quot; + taskId + &quot;&gt; done...####&quot;); return randomSum; } public CallableTask() { this.id = ++count; this.taskId = &quot;Task-&quot; + id; } } 결과는 아래와 같다. shutdownNow()이 호출된 후 각각 태스크는 종료된다. [main] thread starts here... #### &lt;pool-1-thread-1,Task-1&gt; starting...#### #### &lt;pool-1-thread-2,Task-1&gt; starting...#### &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-2,Task-1&gt; TICK TICK #### &lt;pool-1-thread-3,Task-1&gt; starting...#### &lt;pool-1-thread-3,Task-1&gt; TICK TICK &lt;pool-1-thread-2,Task-1&gt; TICK TICK &lt;pool-1-thread-3,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-2,Task-1&gt; TICK TICK &lt;pool-1-thread-2,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-3,Task-1&gt; TICK TICK [main] shutdownNow() invoked &lt;pool-1-thread-1,Task-1&gt; Sleep Interrupted. Cancelling... &lt;pool-1-thread-3,Task-1&gt; Sleep Interrupted. Cancelling... #### &lt;pool-1-thread-3,Task-1&gt; done...#### #### &lt;pool-1-thread-1,Task-1&gt; done...#### &lt;pool-1-thread-2,Task-1&gt; Thread.interrupted() is true: Cancelling... #### &lt;pool-1-thread-2,Task-1&gt; done...#### [main] All threads terminated: true [main] thread ends here... 다음과 같이 TerminatingAllExecutors 클래스를 수정해서 의도적으로 실행되지 않는 태스크를 만들어보자. public class TerminatingAllExecutors { public static void main(String argc[]) throws InterruptedException { String currentThreadName = Thread.currentThread().getName(); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread starts here...&quot;); ExecutorService execService = Executors.newSingleThreadExecutor(); BlockingTask blockingTask = new BlockingTask(); NonBlockingTask nonBlockingTask = new NonBlockingTask(); CallableTask callableTask = new CallableTask(); //Runnable execService.execute(blockingTask); execService.execute(nonBlockingTask); //Callable execService.submit(callableTask); TimeUnit.MILLISECONDS.sleep(200); execService.shutdownNow(); //shutDownNow System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; shutdownNow() invoked &quot;); System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; All threads terminated: &quot; + execService.awaitTermination(500, TimeUnit.MILLISECONDS)); //awaitTermination System.out.println(&quot;[&quot;+ currentThreadName + &quot;]&quot; + &quot; thread ends here...&quot;); } } 아래 결과와 같이 실행되지 않은 태스크는 더이상 실행되지 않는다. [main] thread starts here... #### &lt;pool-1-thread-1,Task-1&gt; starting...#### &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK &lt;pool-1-thread-1,Task-1&gt; TICK TICK [main] shutdownNow() invoked &lt;pool-1-thread-1,Task-1&gt; Sleep Interrupted. Cancelling... #### &lt;pool-1-thread-1,Task-1&gt; done...#### [main] All threads terminated: true [main] thread ends here...",
    "url": "http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html",
    "relUrl": "/docs/java/2016-09-20-java-multithreading-thread-termination.html"
  },
  "57": {
    "id": "57",
    "title": "Java - 네이밍",
    "content": "코딩에서 네이밍은 항상 힘들다. Java 네이밍 관련 글 중 좋은 글이 있어 간단히 정리해 보자. 여기서 설명하는 내용은 사실 Java만이 아니라 많은 언어에 사용 가능하다. 자세한 내용은 항상 그렇듯 원문을 참고하자. Java 네이밍 베스트 프랙티스 1. 무의미한 이름을 피해라 abc, temp, data와 같은 개발자의 의도를 담고 있지 않은 이름은 프로페셔널 프로젝트에서는 사용되어서는 안된다. 단지 자신만이 사용하는 테스트용 프로그램에서만 사용해라. 2. 의미있는 이름을 부여하라 public과 private 모두 개발자의 의도를 전달하는 의미있는 이름을 사용하라. getPD()보다는 getPayDate()가 훨씬 개발자의 의도를 잘 전달한다. 3. 의도가 드러난다면 되도록 짧은 이름을 선호하라 의도가 드러나는 경우엔 되도록 짧은 이름이 긴 이름보다 좋다. 예를 들어 getPayDate()가 retreivePaymentDate()보다 좋다. 4. 비슷한 이름들을 피해라 유사한 이름만큼 나쁜 건 없다. 예를 들어 변수 이름이 employee와 employees는 모두 같으며 마지막만 다르다. 이런 유사성은 미묘한 버그를 이끌고 코드 리뷰를 어렵게 한다. 만약 컬렉션을 표현하고자 한다면 listOfEmployees가 employees보다 더 명확하다. 이 때 주의할 점은 list는 모두 알다 시피 ordered 컬렉션이므로 자연스럽게 저 이름을 사용하면 ordered라고 인식하게 된다는 것이다. 5. 축약형 보다 서술형이 더 좋다 getLiquidityIndicator()가 getLInd()보다 좋다. 축약형을 선택하는 경우는 축약형으로도 개발자의 의도가 명백히 전달되는 경우 만이다. 긴 이름을 사용하게 되는 이유 중 하나는 한 메소드에서 여러 일을 하려 하기 때문이다. 이런 경우 메소드를 분할 하는 것을 고려해라. 예를 들어, loadAndUpdateAllInstrumentRecords()는 loadInstruments()와 updateInstruments()로 분할 될 수 있다. 6. Java 코딩 컨벤션을 따르라 다음의 Java 코딩 컨벤션들은 아주 일반적인 것들이다. 클래스 이름은 대문자로 시작: Employee, Student, Thread 메소드 이름은 소문자로 시작하며 camelCase: getEmployee(), getPayDate() 변수 이름은 역시 소문자로 시작하며 camelCase: price, quantity, totalAmount constant는 모두 대문자: MAX_QUANTITY, MAX_PRICE 7. 일관적인 네이밍을 사용하고 동의어는 피하라 같은 동작을 하는 메소드들은 일관적인 이름을 사용하라. 예를 들어 각기 다른 모듈에서 destroy(), kill(), finish()를 사용하는 것은 좋지 않다. 그 보다는 그 중 하나를 택해서 사용하는 것이 더 좋다. 8. 전통적인 프로그래밍 컨벤션을 따르라 무의미한 이름을 피하라고 했지만, 예외가 있다. loop에서 i와 j는 매우 전통적인 변수명으로 모든 프로그래머들에게 익숙하다. for(int i=0; i&lt;10; i++){ // your code } 9. 클래스 이름은 명사여야 한다. 잘 알다시피 다음은 아주 일반적인 Java에서의 네이밍 규칙이다. 클래스 이름은 명사: Employee, Thread, String 메소드 이름은 동사로 시작: get, set, do, invoke 인터페이스 이름은 어떤 능력이나 CAN DO(Runnable)을 나타냄: Runnable, Callable 패키지 이름은 회사와 프로젝트 구조(com.company.project.module)를 반영: org.apache.commons.beanutils.BasicDynaBean 10. , m, o_와 같은 prefix를 붙이지 말라 개발자들 중 일부는 , mㅡ, o 등을 이용해 로컬 멤버임을 나타내는 것 등을 하고자 한다. 하지만, 이런 것 보다는 의미있는 이름을 사용하는 것이 더 좋다. 프로젝트에 이미 m_ 네이밍 컨벤션을 사용 중이라면 재 작성하거나 모든 프로젝트를 바꾸기 보다 유지하는 것이 더 좋다. 또한 일부 개발자들은 bExit으로 boolean을 표시하거나 iMax로 integer임을 표시하는 헝가리안 표기법을 사용한다. 이건 legacy 코드로 작업할 때 심각하게 나쁜 것은 아니지만 처음부터 개발할 때는 되도록 사용하지 말자. 11. ASCII 문자가 아니거나 로컬 언어로부터의 단어는 피하자. 쉽게 말하면 영어가 아닌 것을 피하자. 프로그래밍 세계에서는 영어가 공용어이다. 12. is, has, can, do와 같은 일반적인 동사를 적절히 사용하자 is, has, can를 적절히 이용하면 코드 가독성을 높일 수 있다. 예를 들어 isAlive(), hasNext(), canExecute()와 같은 메소드는 이해가 쉽고 가독성이 좋다. 조건문에 사용되는 변수명에도 동일하게 사용하여 가독성을 높일 수 있다. if(isRaining){ bringUmbrella(); }",
    "url": "http://localhost:4000/docs/java/2016-10-02-java-naming.html",
    "relUrl": "/docs/java/2016-10-02-java-naming.html"
  },
  "58": {
    "id": "58",
    "title": "Git - pull request",
    "content": "아직은 헷갈리는 git pull request에 대해 살펴보자. pull request는 git 자체가 제공하는 것이 아니라 github와 같은 git기반 서비스 업체가 제공하는 기능이다. pull request 순서 1단계(fork): git 서비스가 제공하는 UI를 이용해 프로젝트 저장소를 fork하여 자신의 원격 저장소를 만든다. https://project-repository/repo.git를 fork하여 https://user-repository/repo.git가 생겼다고 가정하자. 2단계(clone): 자신 계정의 원격 저장소를 clone을 해서 로컬 저장소를 만든다. 이렇게 하면 자신의 원격 저장소가 origin이라는 alias를 가지게 되고 로컬은 master 브랜치가 된다. 그리고 현재 작업 공간은 master 브랜치를 가리키게 된다. $ git clone https://user-repository/repo.git $ git remote -v// origin이 보여야 함 3단계(remote add): 로컬 저장소에 원본 프로젝트 저장소를 추가한다. 이때 이 원본 프로젝트 저장소의 alias를 부여해 origin과 구분한다. $ git remote add parent https://project-repository/repo.git $ git remote -v //확인 - origin과 parent가 보여야 함 4단계(feature branch): 로컬에서 master 브랜치는 동기화 용으로 사용하고 작업하는 feature별로 브랜치를 만들어 checkout하여 작업 공간의 브랜치를 전환한다. $ git checkout -B hotfix 5단계(implementation): feature를 구현한다. $ git add new_file.txt $ git commit -a -m &quot;Fix typo in README file&quot; 6단계(remote fetch): git fetch 이름 명령을 이용해서 원 프로젝트의 변경 내용을 가져온다. $ git fetch parent 7단계(remote merge): git merge parent/master를 해서 현재 hotfix 브랜치와 원래 프로젝트의 master branch를 머지한다. $ git merge parent/master 7-1단계(conflict handling - optional): 충돌해결 만약 conflict이 났다는 메시지가 보이면 git status 명령을 이용해서 확인한다. 충돌이 일어난 파일은 unmerged로 표시다 되며, 이는 수동으로 수정한다. git mergetool 명령을 이용해 툴을 호출할 수 있다. 이때 mac의 경우는 opendiff가 실행된다. 수정이 완료가 되면 git add 명령을 이용해 반영한다. 그 뒤 git commit을 이용해 반영한다. 즉 충돌이 일어난 경우 다음 순서를 따른다. $ git status //문제 확인 $ git mergetool //수정 $ git add $ git commit $ git status //해결 되었음이 보여야 함 8단계(verification): 문제가 없이 머지가 되었고, 부작용도 없음을 확인한다. 9단계(push): git push :으로 원격저장소에 새로운 브랜치를 생성하면서 푸시한다. $ git push origin hotfix/hotfix $ git branch -r //origin/hotfix가 보여야 한다. 10단계(branch clear): 로컬의 branch를 제거한다. $ git branch -d hotfix 11단계(pull request): 수정된 내용으로 pull request한다. github와 같은 서비스가 제공하는 UI를 이용한다. 12단계(code review): Pull request에 대해 review를 한다. github와 같은 서비스가 제공하는 UI를 이용한다. 13단계(push): Pull request가 원본 프로젝트에 merge되면 내 원격 repository에 올린다. 참고할 만한 git 명령 branch 모두 확인 $ git branch -r 원격 저장소 변경 내용 확인 $ git remote show [이름] 원격 저장소 alias 제거하기 $ git remote rm 이름 원격 저장소 alias 변경하기 $ git remote rename [old_name] [new_name]",
    "url": "http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html",
    "relUrl": "/docs/tool/2016-10-04-git-pull-request.html"
  },
  "59": {
    "id": "59",
    "title": "Git - 수정한 것 되돌리기",
    "content": "Git을 사용하다보면 수정한 내용을 되돌리고 싶을 경우가 간혹있다. GUI가 있는 Git 클라이언트의 경우엔 discard를 하면 되지만 command line interface에서는 어떻게 해야 할지 잘 모를때가 많다. 각 상황별로 수정 내역을 되돌리는 법을 알아보자. 1. git add 명령을 하기 이전(stage에 올리지 않은 경우) 1.1 repository 내 모든 수정 되돌리기 $ cd {repository_root_dir} $ git checkout . 1.2 특정 폴더 아래의 모든 수정 되돌리기 $ git checkout {dir} 1.3 특정 파일의 수정 되돌리기 $ git checkout {file_name} 2. git add 명령으로 stage에 올린 경우 $ git reset 3. git commit을 한 경우 3.1 commit 내용을 없애고 이전 상태로 원복 master 브랜치의 마지막 커밋을 가리키던 HEAD를 그 이전으로 이동시켜서 commit 내용을 없앰 $ git reset --hard HEAD^ 3.2 commit은 취소하고 commit 했던 내용은 남기고 unstaged 상태로 만들기 $ git reset HEAD^ 3.3 commit은 취소하고 commit 했던 내용은 남기고 staged 상태로 만들기 $ git reset --soft HEAD^ 4. 모든 untracked 파일들을 지우기 git clean -fdx 5. git push를 한 경우 remote repository도 이전으로 되돌리기 $ git reset HEAD^ #local repository에서 commit을 하나 되돌림 $ git commit -m &quot;...&quot; #되돌린 것으로 commit $ git push origin +master #remote repository를 강제로 revert",
    "url": "http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html",
    "relUrl": "/docs/tool/2016-10-05-git-revert-changes.html"
  },
  "60": {
    "id": "60",
    "title": "Java - final 키워드",
    "content": "Java의 final 키워드에 대해 살펴보자. 1. 클래스의 final 멤버 변수 1.1 선언과 함께 정의한 경우 상수이다. 주로 변수명은 모두 대문자로 구성되어야 한다. 아래와 같이 다시 값을 대입하려고 하면 컴파일 에러가 발생한다. public class Solution { final int LIMIT = 10; void foo(){ LIMIT = 11; //Error: cannot assign a value to final variable LIMIT } } 1.2 선언만 하고 정의하지 않은 경우 반드시 constructor내에서 값이 초기화 되어야 한다. public class Solution { final int limit; public Solution(final int limit) { this.limit = limit; //OK } ... } constructor외의 메소드에서 값을 초기화하는 것은 안된다. public class Solution { final int limit; public Solution(final int limit) { setLimit(limit); } public void setLimit(final int limit) { this.limit = limit; //Error: cannot assign a value to final variable LIMIT } ... } 2. static final 변수 2.1 선언과 함께 정의한 경우 상수이다. 주로 변수명은 모두 대문자로 구성되어야 한다. public class Solution { final static int LIMIT = 10; public static void main(String[] args) { System.out.println(Solution.LIMIT); } } 아래와 같이 다시 값을 대입하려고 하면 컴파일 에러가 발생한다. public class Solution { final static int LIMIT = 10; public static void main(String[] args) { System.out.println(Solution.LIMIT); Solution.LIMIT = 11; //Error: cannot assign a value to final variable LIMIT } } 2.2 선언만하고 정의하지 않은 경우 반드시 static block에서 초기화 되어야 햔다. public class Solution { final static int LIMIT; static { LIMIT = 10; } public static void main(String[] args) { System.out.println(Solution.LIMIT); } } 3. 메소드의 final 파라미터 const와 같은 의미이다. 값을 대입할 수 없다. public class Solution { void tryToChagne(final int count, int length) { count = 10; //Error: cannot assign a value to final variable count length = 10; //OK } } 4. final Collection 변수 Collection instance를 다시 정의 할 수는 없다. import java.util.ArrayList; import java.util.LinkedList; import java.util.List; public class Solution { public static void main(String[] args) { final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list = new LinkedList&lt;&gt;(); //Error: cannot assign a value to final variable list } } 하지만, 삽입이나 삭제는 가능하다. import java.util.ArrayList; import java.util.List; public class Solution { public static void main(String[] args) { final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.remove(0); } } 5. final 메소드 5.1 일반 final 메소드는 오버라이드를 할 수 없다는 의미이다. class Parent { final void thisIsFinal() { } void thisIsNotFinal() { } } public class Solution extends Parent { @Override void thisIsFinal() { //Error: thisIsFinal() in Solution cannot override thisIsFinal() in Parent overridden method is final } @Override void thisIsNotFinal() { //OK } } 5.2 final constructor constructor는 final일수 없다!!! public class Solution { final public Solution() { //Error: modifier final not allowed here } } 6. final 클래스 final class는 상속할 수 없다. final class Parent { } public class Solution extends Parent { //Error: cannot inherit from final Parent } 7. interface 7.1 final로 선언되지 않은 변수들 interface의 변수의 값을 바꾸려 하면 아래와 같이 final 변수를 바꾸려는 시도이기 때문에 안된다고 한다. 즉, interface의 멤버 변수들은 모두 final이다. interface Solvable { int LIMIT = 10; } public class Solution implements Solvable { void tryToChange(){ LIMIT = 1; //Error: cannot assign a value to final variable LIMIT } } 7.2 final로 선언된 메소드 선언 interface의 메소드 선언은 final을 허용하지 않는다. interface Solvable { public final void hey(); //Error: modifier final not allowed here } public class Solution implements Solvable { public void hey() { } }",
    "url": "http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html",
    "relUrl": "/docs/java/2016-10-12-java-final-keyword.html"
  },
  "61": {
    "id": "61",
    "title": "Java - Lombok",
    "content": "Lombok은 아주 유용한 Java annotation 라이브러리이다. 이것은 지저분한 boilerplate 코드를 줄이고 이에 따라 코딩을 더 빠르고 실수없이 할 수 있도록 도와준다. Lombok은 getter, setter, toString, constructor, equals, hashCode 메소드들을 자동적으로 생성한다. 개발자는 단지 클래스를 만들고 필드를 추가하면 된다. 1. Lombok 소개 자세한 내용은 여기를 참조하고 annotation이 어떤 것을 지원하는지 간단히 알아보자 1.1 val lombok.val을 임포트하면 final 키워드를 추가하지 않아도 필요한 변수에는 final을 추가한다. import lombok.val; 1.2 @NonNull Null이여서는 안되는 메소드 parameter에 @NoneNull 키워드를 붙여주면 Null인 경우 NullPointerException을 throw한다. public Shape(@NonNull Person person) { ... } 1.3 @Cleanup InputStream이나 OutputStream 선언시 @Cleanup 키워드를 붙여 주면 자동으로 close()를 호출해서 리소스를 반환해 준다. @Cleanup InputStream in = new FileInputStream(args[0]); 1.4 @Getter / @Setter 클래스의 필드에 키워드를 추가하면 자동으로 setter와 getter를 만들어 준다. 접근 레벨도 설정할 수 있다. @Getter @Setter private int age = 10; @Setter(AccessLevel.PROTECTED) private String name; 1.5 @ToString 클래스의 toString() 메소드를 만들어준다. 이때 어떤 필드를 추가할 지 설정할 수 있다. @ToString(exclude=&quot;id&quot;) public class Shape { private String name; private double score; private String[] tags; private int id; ... } @ToString(callSuper=true, includeFieldNames=true) public static class Square extends Shape { ... } 1.6 @EqualsAndHashCode 클래스의 필드를 기반으로 자동으로 hashCode()와 equals() 메소드를 만들어준다. @EqualsAndHashCode(exclude={&quot;id&quot;}) public class Shape { private String name; private double score; private String[] tags; private int id; ... } @EqualsAndHashCode(callSuper=true) public static class Square extends Shape { .... } 1.7 @NoArgsConstructor, @RequiredArgsConstructor 그리고 @AllArgsConstructor Constructor를 자동으로 만든다. @RequiredArgsConstructor(staticName = &quot;of&quot;) @AllArgsConstructor(access = AccessLevel.PROTECTED) public class Shape { ... } 1.8 @Data @ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor를 한번에!!! @Data public class Shape { ... } 1.9 @Value Immutable 클래스를 쉽게 만든다. 이건 자세한 내용을 참조하자. 1.10 @Builder builder 패턴을 쉽게 만든다. 이건 자세한 내용을 참조하자. 1.11 @SneakyThrows Throws를 제대로! 이건 자세한 내용을 참조하자. 1.12 @Synchronized synchronized를 제대로! 이건 자세한 내용을 참조하자. 1.13 @Getter(lazy=true) 성능을 잡아먹는 cache이슈를 피해서 lazy getter를 구현한다. 이건 자세한 내용을 참조하자. 1.14 @Log 주저리 주저리 긴 log선언을 깔끔하게 처리한다. 이건 자세한 내용을 참조하자. 2. IntelliJ에서 Lombok 사용하기 2.1 Plugin 설치 Lombok plugin을 설치한다. Preferences &gt; Plugins &gt; Browse repositories..에서 lombok 검색 후 설치 2.2 Annotation Processor enable Preferences &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processor에서 Enable Annotation Processing을 체크 2.3 라이브러리 설정 Maven project로 만든 후 pom.xml에 dependency 추가 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;",
    "url": "http://localhost:4000/docs/java/2016-10-14-java-lombok.html",
    "relUrl": "/docs/java/2016-10-14-java-lombok.html"
  },
  "62": {
    "id": "62",
    "title": "shell - 폴더에서 파일 내용 검색하기",
    "content": "하위 폴더를 포함해서 파일 내용 검색해서 표시하는 것은 가끔 필요하기 하지만, 아주 절실할 때가 많다. 그 방법을 알아보자 1 테스트 환경 1.1 폴더 구조 간단히 다음과 같은 폴더 구조를 생각해보자. project - txt - AAA.txt - java - BBB.java project폴더 아래 txt, java 폴더가 각각 있고 각 폴더아래 aaa.txt 파일과 bbb.java파일이 있는 것이다. 1.2 텍스트 파일 내용 AAA.txt파일의 내용은 다음과 같다. This file is a text file. 1. The first line is for class. 2. The second line is for interface. 3. The third line is for dummies. 1.3 자바 파일 내용 public class BBB { void BBB() { //dummies } } 2 명령어 살펴보기 검색 시간을 줄이기 위해서는 파일 확장자를 제한하는 것이 필요하다. 쓸데없는 파일까지 뒤져서 출력하면 결과를 확인하기도 어려우니 말이다. 그것을 감안하고 다음 사용 방법을 살펴보자. 2.1 키워드를 포함하는 파일 찾기 find . -type f -name *.파일확장자 -print0 | xargs -0 grep -l 검색키워드 project 폴더에서 다음과 같은 사용 예를 보자. $ find . -type f -name *.java -print0 | xargs -0 grep -l dummies ./java/BBB.java BBB라는 패턴과 가진 파일 중 java 확장자를 가진 BBB.java 파일 명을 보여준다. 2.2 확장자 확장하기 확장자를 늘리기 위해서는 ‘f ( -name *.확장자1 -o -name *.확장자2 -o -name *.확장자3 )’ 이런 식의 약간 복잡한 패턴을 사용해야 한다. find . -type f ( -name *.확장자1 -o -name *.확장자2 -o -name *.확장자3 ) -print0 | xargs -0 grep -l 검색키워드 project 폴더에서 다음과 같은 사용 예를 보자. $ find . -type f ( -name *.java -o -name *.txt ) - -print0 | xargs -0 grep -l dummies ./java/BBB.java ./txt/AAA.txt 이제 원하는 패턴을 가진 모든 파일을 보여준다. 2.3 키워드 확장하기 키워드가 공백을 포함한 문자열인 경우는 어떨까? 간단히 검색 키워드의 시작과 끝은 ‘‘로 감싸면 된다. 예를 들어 dummies를 찾는데 //dummies를 빼고 싶다면 앞에 여백이 하나 있는 것을 찾으면 된다. find . -type f ( -name *.확장자1 -o -name *.확장자2 -o -name *.확장자3 ) -print0 | xargs -0 grep -l &#39;검색 키워드&#39; project 폴더에서 다음과 같은 사용 예를 보자. $ find . -type f ( -name *.java -o -name *.txt ) - -print0 | xargs -0 grep -l &#39; dummies&#39; ./txt/AAA.txt //dummies는 검색에서 제외한다. 2.4 파일 내용 보여주기 일치하는 내용을 가진 줄을 결과로 보고 싶다면 어떻게 할까? ‘grep -l’ 명령대신 ‘grep -H’를 넣으면 되고, 색깔을 이용해 패턴을 강조하고 싶다면 ‘–color’ 플래그를 추가한다. find . -type f ( -name *.확장자1 -o -name *.확장자2 -o -name *.확장자3 ) -print0 | xargs -0 grep -H --color &#39;검색 키워드&#39; project 폴더에서 다음과 같은 사용 예를 보자. $ find . -type f ( -name *.java -o -name *.txt ) -print0 | xargs -0 grep -H --color &#39;BBB&#39; ./java/BBB.java:public class BBB { ./java/BBB.java: void BBB() { 파일 내용 만이 아니라 그 내용까지 알아 볼 수 있다! 3 정리 최종적으로 다음과 같은 명령을 사용하면 된다는 것을 알 수 있을 것이다. find . -type f ( -name *.확장자1 -o -name *.확장자2 -o -name *.확장자3 ) -print0 | xargs -0 grep -H --color &#39;검색 키워드&#39; 이것을 .bashrc 등에 등록해 놓고 간단하게 사용하는 방법도 있을 것이다.",
    "url": "http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html",
    "relUrl": "/docs/tool/2016-11-03-bash-find-pattern-in-directories.html"
  },
  "63": {
    "id": "63",
    "title": "Git - diff  사용하기",
    "content": "git의 diff하는 법을 알아보자. diff를 잘 알면 이를 이용해 patch를 만들 수 있다. patch를 만들면 beyond compare와 같은 GUI툴을 이용해서 하나씩 비교하면서 천천히 살펴볼 수 있다. 1. diff하기 1.1. 로컬의 Branch간 비교 git diff &lt;branch명&gt; &lt;다른 branch명&gt; 1.2. 로컬과 리모트의 내용 비교 git diff &lt;branch명&gt; origin/&lt;branch명&gt; 1.3. Commit 간 비교 git diff &lt;commit hash&gt; &lt;commit hash&gt; 1.4. pull request 내용과 비교 checkout remote branch 이름을 먼저 확인한 뒤 git diff &lt;현재 브랜치&gt; &lt;checkout remote branch&gt; 1.5. 특정 커밋과 pull request 비교 checkout remote branch 이름을 먼저 확인한 뒤 git diff &lt;commit hash&gt; &lt;checkout remote branch&gt; 1.6. 마지막 커밋과 그 이전 커밋 비교 git diff HEAD HEAD^ 1.7. 마지막 커밋과 현재 수정사항 확인 아래 stage된 것과 아닌 것을 모두 확인하는 법이다. 주의 할 점은 untracking 파일은 비교에서 제외된다는 것이다. git diff HEAD 1.7.1 현재 staged 된 수정사항 만 따로 확인 git diff --cached 또는 git diff --staged 1.7.2 현재 unstaged 된 수정사항만 확인 git diff 2. 확인하기 BeyondCompare를 이용하는 경우이다. ’&gt;’를 이용해 diff파일을 만든다. beyondcompare &gt; tool &gt; view patch 만들었던 diff파일 선택!!",
    "url": "http://localhost:4000/docs/tool/2016-11-07-git-diff.html",
    "relUrl": "/docs/tool/2016-11-07-git-diff.html"
  },
  "64": {
    "id": "64",
    "title": "Tool - patch하기",
    "content": "patch를 만들고 적용하는 것을 살피보자. 1. patch 만들기 diff -Naur ./Old ./New &gt; files.patch 2. 적용 이제 적용을 하려면 일단 먼저 files.patch를 열어본다. 그러면 어느 디렉토리의 구조가 맨 처음에 보일 것이다. iff -Naur ./OLD/AAA/bye.c ./NEW/AAA/bye.c ./Old 안에서 files.patch를 적용하려면 ./Old밖에서 만든 patch이므로 디렉토리 하나를 생략해야 한다. 즉, ./OLD가 아닌 AAA부터 시작되어야 현재 디렉토리 구조와 동일할 것이다. 이때 사용하는 것이 -p 플래그이다. 만약 절대 경로를 사용했다면 여러 개의 디렉토리를 생략해야 할 것이다. p는 슬래쉬의 숫자를 지정하는 것인데 위의 경우 ./OLD/를 제외하면 되므로 -p2으로 하면 된다. 슬래쉬 숫자이므로 반드시 patch파일을 확인해서 현재 디렉토리 구조와 확인해 봐야 한다. 그래서 ./Old안으로 files.patch를 복사한 후 다음 명령을 실행한다. patch -p2 &lt; files.patch 3. 백업 만약 백업이 필요할 경우 -b 플래그를 추가하면 이전 파일이 .orig 확장자로 남게 된다. patch -p2 -b &lt; files.patch를 실행하면 된다. 4. 패치한 것 되돌리기! patch -p2 -R &lt; files.patch 그런데 백업을 해 놓은 경우 .orig파일들은 그냥 남아있게 된다. –&gt; find . -name *.orig -type f -delete 를 해서 깨끗이 지운다.",
    "url": "http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html",
    "relUrl": "/docs/tool/2016-11-08-how-to-patch.html"
  },
  "65": {
    "id": "65",
    "title": "Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키",
    "content": "중요 알림 아래 글을 지극히 개인적인 선호에 따라 설정한 IntelliJ 키맵입니다. 개인적으로 정리하기 위한 글이오니 되도록 참고하지 말아주세요. 시작 IntelliJ IDEA를 본격적으로 사용하기 위해 vi와 eclipse 단축키에 익숙한 나 자신만을 위해 IntelliJ 키맵 설정을 해본다. 되도록 나의 eclipse keymap과 유사하고 vi mode에 최적화된 keymap을 설정하고자 한다. 기본 설정 IntelliJ IDEA &gt; Preferences &gt; Keymap으로 가서 Keymaps를 Mac OS X 10.5+로 한 후 copy를 하여 새로운 이름의 keymap으로 정한다. 참고로 Preferences 단축키는 command + ,이다. 키보드 설정 추가 이제 키보드 설정을 추가한다. 중간에 다른 키보드 설정을 제거한다는 경고가 뜨면 이전 설정을 지우는 것으로 하고 그냥 진행한다. Split Vertically: option + v Expression Type: command + shift + p Class in Navigate: command + shift + t File structure : control + m Back : control + h Forward: control + l Declaration: control + b Implementation: control + p Show Intention Actions: control + , Optimize Imports: command + shift + o Rename: command + shift + r Method in Extract: command + shift + m Find Usages: control + i Call Hierarchy: command + shift + i Reformat Code: command + shift + f Inspect Code: control + u Switcher: control + ‘ Preferences에서 Other Settigs &gt; Vim Emulation으로 이동한다. 모두 IDE로 바꾼다. 자주 사용하는 단축키 위의 변경내용이 반영된 자주 사용하는 단축키는 다음과 같다. 이동 및 선택 관련 코드 편집창으로 포커스 옮기기: esc (Caplock에 esc를 맵핑하고 있다면 Caplock) 파일간 switch: control + ‘ (한번 누르면 바로 이전 파일, 여러 번 누르면 열린 파일중 선택) 코드 창을 세로로 분할: option + v 코드 편집창으로 세로로 분할해 놓은 경우, 포커스 이동하기: option + tab 현재 클래스의 필드, 메서드 등을 보여주는 창이 떠서 선택하여 이동: control + m 이전 위치: control + h 다음 위치: control + l 선언으로 이동: control + b 구현으로 이동: control + p 현재 메소드의 수퍼 메소드로 이동: command + u 다음 method : control + down 이전 metod : control + up 검색 및 참조 모든 것 찾기: Shift, Shift 빠른 Javadoc 문서 참조: control + . 현재 호출하고 있는 메소드의 파라미터 확인하기: command + p 현재 호출하고 있는 메소드의 반환 타입 확인하기: command + shift + p 문자열 검색하기: shift + command + F 클래스 찾기(단어사이 대문자로 조회): command + shift + T Find Usage: control + i Call Hierarchy: control + shift + i 코드 수정 기본 자동 완성: control + space 스마트 자동 완성: control + shift + space 오류 해결 솔루션 제시: control + , 코드 생성: command + n 선택된 코드를 위, 아래로 이동. 선택을 안 했으면 한 줄이 default: command + shift + up/down: 자동 import 관리: command + shift + o 주석 토글: command + / 블록 주석 토글: shift + command + / Rename: command + shift + r 메소드 추출: command + shift + m auto-formatting: command + shift + f Inspect code: control + u 관련 수정 테마 모두 블랙을 좋아하지만 기본 테마가 좀 더 깔끔 폰트 Preferences &gt; Editor &gt; Colors &amp; Fonts &gt; Font 폰트는 monaco로 사이즈를 11로 한다. Preferences &gt; Editor &gt; Colors &amp; Fonts &gt; Java Class Fields: Constant, Static은 파란색, bold만 유지한 채 2907B4, Instance field와 Instance final은 색깔은 같고 bold해제 Comments: Javadoc에서 User Inherited attributes를 해제하고 Effects를 모두 끄고 Bold와 Italic도 해체. Markup의 배경색을 삭제. Keyword는 자주색(802509) Bold 설정, italic해제 Number는 빨간색 (FF1C3A) Parameters의 Parameter, Reassigned 모두 연한 갈색(AB534B) String은 빨간색(FF1C3A) (background는 노랑(FFFE19)) Variable: Local, Reassigned 모두 연한 파란색 (6F86CC) 색깔 Preferences &gt; Editor &gt; Colors &amp; Fonts &gt; Java에서 Comments &gt; Javadoc으로 가서 Block comment, Line commment, Markup, Tag, Tagvalue, Text의 색깔을 모두 Forground를 41470B로 바꾼다. 이때 바꾸기위해서는 Use Inherited attributes를 해제한다. 자동 폴딩 Preferences &gt; Editor &gt; General &gt; Code Folding에 가서 모두 해제한다. import에 * 생성 해제 Preferences &gt; Editor &gt; Code Style &gt; Java로 이동하여 Imports tab에서 ‘Class count to use import with *‘와 ‘Names count to use static imports with *‘의 값을 999로 변경 이때 Scheme은 새로운 것으로 저장.",
    "url": "http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html",
    "relUrl": "/docs/java/2016-11-27-java-intellij-shortcut.html"
  },
  "66": {
    "id": "66",
    "title": "grep 명령 - 빈 줄이나 특정 줄 제거하기",
    "content": "grep 기능을 이용해 로그 분석 중 불필요한 줄을 제거하는 것은 아주 자주 사용하는 명령이다. 이를 좀 더 알아보자. 예제 예제로할 .bash_profile의 내용이 다음과 같다고 가정하자. Hochului-MacBook-Pro:~ hochulshin$ cat .bash_profile export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=&quot;/usr/local/Cellar/node/6.3.1/bin:$PATH&quot; [[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; # Load RVM into a shell session *as a function* # Setting PATH for Python 3.5 # The orginal version is saved in .bash_profile.pysave PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot; export PATH ## # Your previous /Users/hochulshin/.bash_profile file was backed up as /Users/hochulshin/.bash_profile.macports-saved_2016-07-06_at_21:09:39 ## # MacPorts Installer addition on 2016-07-06_at_21:09:39: adding an appropriate PATH variable for use with MacPorts. export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; # Finished adapting your PATH environment variable for use with MacPorts. alias mysql=&#39;/usr/local/mysql/bin/mysql&#39; alias mysqladmin=&#39;/usr/local/mysql/bin/mysqladmin&#39; grep의 -v 옵션과 -e 옵션 grep의 -v 옵션은 패턴이 일치하는 경우 그 줄을 표시하지 않는 것이다. -e 옵션은 regex를 사용한다는 것이다. 이를 조합하여 다음과 같은 명령을 실행할 수 있다. 빈 줄 제거 빈 줄을 제거하는 옵션은 다음과 같다. grep -v -e &#39;^$&#39; 파일명 위의 예제에 적용한 것은 다음과 같다. Hochului-MacBook-Pro:~ hochulshin$ cat .bash_profile | grep -v -e &#39;^$&#39; export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=&quot;/usr/local/Cellar/node/6.3.1/bin:$PATH&quot; [[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; # Load RVM into a shell session *as a function* # Setting PATH for Python 3.5 # The orginal version is saved in .bash_profile.pysave PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot; export PATH ## # Your previous /Users/hochulshin/.bash_profile file was backed up as /Users/hochulshin/.bash_profile.macports-saved_2016-07-06_at_21:09:39 ## # MacPorts Installer addition on 2016-07-06_at_21:09:39: adding an appropriate PATH variable for use with MacPorts. export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; # Finished adapting your PATH environment variable for use with MacPorts. alias mysql=&#39;/usr/local/mysql/bin/mysql&#39; alias mysqladmin=&#39;/usr/local/mysql/bin/mysqladmin&#39; 위에서 공백 줄이 있는 것은 스페이스로만 구성된 줄이 있다는 것이다. 스페이스로 구성된 줄도 함께 제거 위의 예제의 스페이스로만 구성된 줄도 함께 제거하자. grep -v -e &#39;^ s*$&#39; 파일명 공백이 0번이상 반복되어 있는 것도 제거한다는 것이다. 위의 예제에 적용한 것은 다음과 같다. Hochului-MacBook-Pro:~ hochulshin$ cat .bash_profile | grep -v -e &#39;^ s*$&#39; export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=&quot;/usr/local/Cellar/node/6.3.1/bin:$PATH&quot; [[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; # Load RVM into a shell session *as a function* # Setting PATH for Python 3.5 # The orginal version is saved in .bash_profile.pysave PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot; export PATH ## # Your previous /Users/hochulshin/.bash_profile file was backed up as /Users/hochulshin/.bash_profile.macports-saved_2016-07-06_at_21:09:39 ## # MacPorts Installer addition on 2016-07-06_at_21:09:39: adding an appropriate PATH variable for use with MacPorts. export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; # Finished adapting your PATH environment variable for use with MacPorts. alias mysql=&#39;/usr/local/mysql/bin/mysql&#39; alias mysqladmin=&#39;/usr/local/mysql/bin/mysqladmin&#39; 특정 패턴으로 시작하는 줄 제거 패턴이 #이라고 한다면 아래와 같이하면 #으로 시작하는 줄이 제거된다. grep -v -e &#39;^#&#39; 파일명 위의 예제에 적용한 것은 다음과 같다. Hochului-MacBook-Pro:~ hochulshin$ cat .bash_profile | grep -v -e &#39;^#&#39; export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=&quot;/usr/local/Cellar/node/6.3.1/bin:$PATH&quot; [[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; # Load RVM into a shell session *as a function* PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot; export PATH export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; alias mysql=&#39;/usr/local/mysql/bin/mysql&#39; alias mysqladmin=&#39;/usr/local/mysql/bin/mysqladmin&#39; 공백과 특정 패턴으로 시작하는 것을 모두 제거 이건 쉽다. 위의 두개를 스트림으로 연결하는 것이다. 위의 예제에 적용한 것은 다음과 같다. Hochului-MacBook-Pro:~ hochulshin$ cat .bash_profile | grep -v -e &#39;^ s*$&#39; | grep -v -e &#39;^#&#39; export ANDROID_HOME=/usr/local/opt/android-sdk export PATH=&quot;/usr/local/Cellar/node/6.3.1/bin:$PATH&quot; [[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; source &quot;$HOME/.rvm/scripts/rvm&quot; # Load RVM into a shell session *as a function* PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot; export PATH export PATH=&quot;/opt/local/bin:/opt/local/sbin:$PATH&quot; alias mysql=&#39;/usr/local/mysql/bin/mysql&#39; alias mysqladmin=&#39;/usr/local/mysql/bin/mysqladmin&#39;",
    "url": "http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html",
    "relUrl": "/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html"
  },
  "67": {
    "id": "67",
    "title": "sed 명령 - 특정 문자열을 변경하기",
    "content": "로그를 분석하다보면 call stack이 한 줄에 쭉 나와있는 경우가 있다. 이를 보기 편하게 만들기 위해서는 call stack의 API call 사이의 |를 줄바꿈 문자로 변경해야 한다. 이를 포함해 빠르게 문자열을 바꾸는 방법을 알아보자. 예제 예제로할 파일 aaa.txt의 내용이 다음과 같다고 가정하자. Hochului-MacBook-Pro:~ hochulshin$ cat sample.txt 1234|5678|90123 ABCD|EFG abcd|efg sed sed는 다른 리눅스 명령과 결합하여 문자열을 빠르게 변경할 수 있는 도구이다. s/a/b/g 옵션 기본 명령은 다음과 같다. sed -e ‘s/패턴A/패턴B/g’ 파일이름 Hochului-MacBook-Pro:~ hochulshin$ cat sample.txt | sed -e &#39;s/ABCD/XXX/g&#39; 1234|5678|90123 XXX|EFG abcd|efg regex 패턴은 regex를 이용해서도 가능하다. Hochului-MacBook-Pro:~ hochulshin$ cat sample.txt | sed -e &#39;s/[Aa]..[Dd]/XXX/g&#39; 1234|5678|90123 XXX|EFG XXX|efg 범위 지정 sed의 적용 범위를 줄 번호로 지정할 수 있다. 1번째 줄과 두번째 줄만 적용하는 경우 다음과 같이 할 수 있다. Hochului-MacBook-Pro:~ hochulshin$ cat sample.txt | sed -e &#39;1,2 s/[Aa]..[Dd]/XXX/g&#39; 1234|5678|90123 XXX|EFG abcd|efg 특수문자 처리 sed에서 ‘&#39;와 같은 문자를 처리하기 위해서는 다음과 같이 $를 넣어야 한다. sed -e $’s/패턴A/패턴B/g’ 파일이름 참고로 줄바꿈은 ‘ n’이다. Hochului-MacBook-Pro:~ hochulshin$ cat sample.txt | sed -e $&#39;s/|/ n/g&#39; 1234 5678 90123 ABCD EFG abcd efg",
    "url": "http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html",
    "relUrl": "/docs/tool/2016-12-30-tool-sed-replace-string.html"
  },
  "68": {
    "id": "68",
    "title": "sort 명령 - 크기 역순으로 정렬하기",
    "content": "로그를 분석하다보면 크기나 갯수 순으로 정렬해야 하는 경우가 많다. 이때 사용되는 sort 명령을 알아보자. 예제 예제는 특정 폴더의 목록으로 하자. Hochului-MacBook-Pro:Applications hochulshin$ ls -al total 16 drwx 8 hochulshin staff 272 Dec 30 23:53 . drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwxr-xr-x 3 hochulshin staff 102 Mar 19 2016 Ubuntu Linux 14.04 Desktop Applications.app drwxr-xr-x 3 hochulshin staff 102 Jul 30 19:33 Ubuntu Linux Applications.app sort sort는 기본적으로 줄의 맨 앞 글자를 알파벳 순으로 오름 정렬한다. 아래와 같이 특수 문자가 알파벳보다 우선되어 정렬됨을 알 수 있다. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store drwx 8 hochulshin staff 272 Dec 30 23:53 . drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwxr-xr-x 3 hochulshin staff 102 Jul 30 19:33 Ubuntu Linux Applications.app drwxr-xr-x 3 hochulshin staff 102 Mar 19 2016 Ubuntu Linux 14.04 Desktop Applications.app drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. total 16 -r 옵션 -r은 내림차순 정렬이다. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -r total 16 drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. drwxr-xr-x 3 hochulshin staff 102 Mar 19 2016 Ubuntu Linux 14.04 Desktop Applications.app drwxr-xr-x 3 hochulshin staff 102 Jul 30 19:33 Ubuntu Linux Applications.app drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwx 8 hochulshin staff 272 Dec 30 23:53 . -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized -k숫자 옵션 -k는 줄의 맨 앞 문자가 아닌 공백을 기준으로 n번째 문자를 기준으로 정렬하는 것이다. 예제에서 9번째가 파일 이름이므로 파일이름으로 오름차순으로 정렬하려면 -k9옵션을 주면 된다. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -k9 total 16 drwx 8 hochulshin staff 272 Dec 30 23:53 . drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwxr-xr-x 3 hochulshin staff 102 Mar 19 2016 Ubuntu Linux 14.04 Desktop Applications.app drwxr-xr-x 3 hochulshin staff 102 Jul 30 19:33 Ubuntu Linux Applications.app -g 옵션 -g은 알파벳 순이 아닌 숫자 크기 순으로 정렬하는 것이다. -k와 결합하여 적용해서 크기순으로 정렬해보자. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -k5 -g total 16 -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwxr-xr-x 3 hochulshin staff 102 Jul 30 19:33 Ubuntu Linux Applications.app drwxr-xr-x 3 hochulshin staff 102 Mar 19 2016 Ubuntu Linux 14.04 Desktop Applications.app drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwx 8 hochulshin staff 272 Dec 30 23:53 . drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store -u 옵션 비교하는 값이 동일할 경우 제거하는 옵션이다. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -k5 -g -u total 16 -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwx 8 hochulshin staff 272 Dec 30 23:53 . drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store 크기 역순으로 정렬하기 이제 위에서 다룬 모든 옵션을 사용하여 크기 역순으로 중복을 제거하면서 파일을 정렬해보자. Hochului-MacBook-Pro:Applications hochulshin$ ls -al | sort -k5 -g -u -r -rw-r--r--@ 1 hochulshin staff 6148 Aug 11 2015 .DS_Store drwxr-xr-x+ 68 hochulshin staff 2312 Dec 30 23:53 .. drwx 8 hochulshin staff 272 Dec 30 23:53 . drwx@ 6 hochulshin staff 204 Dec 15 22:41 Chrome Apps.localized drwxr-xr-x 3 hochulshin staff 102 Dec 6 21:45 SourceTree.app -rw-r--@ 1 hochulshin staff 0 Aug 6 2015 .localized total 16",
    "url": "http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html",
    "relUrl": "/docs/tool/2016-12-30-tool-sort-reverse-order.html"
  },
  "69": {
    "id": "69",
    "title": "유용한 bash 명령들",
    "content": "로그를 분석시 유용한 명령 조합을 살펴보자. 압축 파일들이 있는 폴더에서 크기 역순으로 정렬해서 가장 큰 파일 열기 ls -al | sort -k 5 -nr | head -1 | cut -d &quot; &quot; -f 10 | xargs zmore ls -al: 폴더 파일들 목록 출력 sort -k 5 -nr: 5번째 컬럼(여기서는 파일 크기)을 역순으로 정렬 head -1 : 첫번째 아이템 만 cut -d “ “ -f 10: 10번째 컬럼만 잘라내기 (여기서는 파일 이름) xargs zmore: 앞의 파이프 입력을 아큐먼트로 zmore 실행 파일을 크기 역순으로 정렬해서 가장 큰 파일에서 getConnection이라는 단어가 몇번 등장하는지 카운트 하기 ls -al | sort -k 5 -nr | head -1 | cut -d &quot; &quot; -f 10 | xargs zgrep getConnection | wc -l ls -al: 폴더 파일들 목록 출력 sort -k 5 -nr: 5번째 컬럼(여기서는 파일 크기)을 역순으로 정렬 head -1 : 첫번째 아이템 만 cut -d “ “ -f 10: 10번째 컬럼만 잘라내기 (여기서는 파일 이름) xargs zgrep getConnection: 앞의 파이프 입력을 아큐먼트로 getConnection을 검색하여 일치하면 줄마다 출력 wc -l: 라인 수 출력 파일의 각 줄의 마지막 단어 삭제하고 다른 파일로 저장하기 less AAA.txt | awk &#39;{$NF=&quot;&quot;;sub(/[ t]+$/,&quot;&quot;)}1&#39; &gt; BBB.txt less AAA.txt : AAA.txt 읽기 awk ‘{$NF=”“;sub(/[ t]+$/,””)}1’: 각 줄의 마지막 단어 삭제 BBB.txt: BBB.txt로 저장 error 종류별로 발생한 숫자 카운트 하기(관련 아이디가 줄 끝에 위치) 한 폴더 안에 여러 gz파일이 있고, 각 gz파일안에 ERROR, WARN, INFO 등으로 마킹된 로그가 연속으로 나타나는데 에러의 경우 ‘Caused by. 에러 종류: 아이디’의 형태로 출력된다고 가정하자. 에러 종류별로 빈번한 것부터 빈번하지 않은 것까지를 정렬하고자 한다. 이를 위해서는 아이디를 제거하고 중복인 것의 갯수를 카운트해서 횟수 역순으로 정렬하자. 그리고 에러가 표시된 줄에 ‘batch’라는 단어가 들어가 있는 것은 무시해야 한다고 가정하자. zgrep &quot;Caused&quot; *gz | grep -v batch | sed -e $&#39;s/ |/ n/g&#39; | awk &#39;{$NF=&quot;&quot;;sub(/[ t]+$/,&quot;&quot;)}1&#39; | sort | uniq -c | sort -nr &gt; errors.txt zgrep “Caused” *gz : 폴더에서 gz로 끝나는 파일들에서 “Caused” 패턴을 찾아서 일치하는 줄을 출력 grep -v batch : batch라는 단어가 있으면 무시 sed -e $’s/|/ n/g’ : 줄안에 표시가 있으면 줄바꿈 awk ‘{$NF=”“;sub(/[ t]+$/,””)}1’: 마지막 단어 제거 sort : 정렬 uniq -c : 중복되는 것은 하나만 남기고 제거하며 맨 앞에 숫자 표시 sort -nr : 빈도 역순으로 정렬 errors.txt : 결과를 파일에 저장",
    "url": "http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html",
    "relUrl": "/docs/tool/2017-01-07-linux-useful-bash-commands.html"
  },
  "70": {
    "id": "70",
    "title": "uml - plantuml",
    "content": "예전에 uml 툴 소개 글을 쓴 적이 있는데, 온라인 UML 툴인 websequencediagrams을 써보고 Sequence diagram만은 websequencediagrams이 최고이고 그 이유는 마크다운스러운 접근법과 직관적인 사용법이 그 이유라고 했다. 그런데 오늘 plantuml을 사용해 보고 이게 제일 좋은 툴이라 생각했다. 왜냐하면 websequencediagrams인데 다운로드해서 로컬에서 사용가능하고, intelliJ에 plugin으로 사용가능하고, sequence diagram만이 아니라 자주 사용되는 다이어그램을 대부분 지원하고 있기 때문이다. 단점이라면 component의 위치지정(placement)이 맘대로 안된다는 것이다. 그냥 text 순으로 배치하면 좋겠는데 뒤죽박죽이 되게 배치해 버린다. (특히 유즈케이스 다이어그램) 그러함에도 그 장점이 너무 뛰어나기에 당분간 이 툴만 사용할 것 같다. plantuml 설치는 homebrew를 이용해 하면 되고, intelliJ 플러그인은 설치하면 에러가 뜨는데 모두 구글링을 하면 쉽게 해결되는 것들이라서 지겨운 설명은 생략한다.",
    "url": "http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html",
    "relUrl": "/docs/tool/2017-03-13-uml-plantuml.html"
  },
  "71": {
    "id": "71",
    "title": "Javascript - deep copy가 필요할 때 무얼 사용해야 할까?",
    "content": "Javascript가 지원하는 다양한 Object copy 방식 중 deepcopy를 지원하는 것은 무엇인지 확인해보자. Deepcopy를 지원할 것 같은 javascript Object copy 방법들 Object.assign() MDN에서는 다음과 같이 설명한다. 마치 deep copy가 가능한 듯한 설명이다. The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object. 간단히 아래와 같이 copy하면서 특정 프로퍼티 값을 업데이트 할 수 있다. const object1 = { a: 1, b: 2, }; const object2 = Object.assign({}, object1, {a: 100}); console.log(object2.a); //100 console.log(object2.b); //2 Spread syntax(…) object나 array를 …를 이용해 프로퍼티들을 뽑아내고 object literal({})이나 array literal([])로 다시 object나 array를 구성하는 방식이다. 복사를 하면서 특정 프로퍼티의 값만 바꿀때 유용하다. const object1 = { a: 1, b: 2, }; const object2 = {...object1, a: 100} console.log(object2.a); //100 console.log(object2.b); //2 const array1 = [1, 2, 3, 4]; const array2 = [...array1]; console.log(array2);//[1, 2, 3, 4] lodash의 deepClone() 위의 두가지 방식과는 달리 lodash 라이브러리를 이용하는 방식으로 lodash는 shallow copy를 지원하는 clone()과 deep copy를 지원하는 cloneDeep()이 있는데 여기서는 cloneDeep()만 살펴본다. import * as _ from &#39;lodash&#39;; const object1 = { a: 1, b: 2 }; const object2 = _.cloneDeep(object1); object2.a = 100; console.log(object2.a); //100 console.log(object2.b); //2 진짜 deep copy를 지원하는지 테스트 테스트 방식 위의 3가지 방식이 deep copy를 지원하는지 테스트를 해보자. 방식은 다음과 같다. 다음과 같이 2단계 깊이의 object를 copy를 하고, 복사본의 프로퍼티의 값을 변경했을 때 원본의 값도 변경되었는지 보는 것이다. reference가 복사되어 원본의 값도 변한 경우 deep copy가 되지 않은 것이다. const original = { a : {b : 2}}; Object.assign() 아래와 같이 deep copy가 되지 못하여 original의 값도 변경되었다. const original = { a : {b : 2}}; let copy = Object.assign({}, original); copy.a.b = 100; console.log(original.a.b); //expected: 2 but actual: 100 spread (…) 역시 아래와 같이 deep copy가 되지 못하여 original의 값도 변경되었다. const original = { a : {b : 2}}; let copy = {...original}; copy.a.b = 100; console.log(original.a.b); //expected: 2 but actual: 100 _.cloneDeep deep copy가 되어 original의 값은 변경되지 않았다. const original = { a : {b : 2}}; let copy = _.cloneDeep(original); copy.a.b = 100; console.log(original.a.b); //2 결론 deep copy가 필요한 경우 Object.assign()이나 spread(…) 를 사용하지 말고, lodash의 cloneDeep()을 사용하자.",
    "url": "http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html",
    "relUrl": "/docs/javascript/2018-02-22-javascript-best-deepcopy.html"
  },
  "72": {
    "id": "72",
    "title": "Algorithm - sliding window algorithm",
    "content": "Leetcode에서 Find All Anagrams in a String 문제(Find All Anagrams in a String)를 풀다가 막혀서 discuss를 봤는데 Sliding Window Algorithm으로 풀이한 것이 있었다. 나중에 다시 볼 때 이해를 용이하게 하기 위해 간단히 그 방법을 남겨둔다. 접근법 알고리즘의 기본적인 접근법은 다음과 같다. String에서 anagram의 조건은 다음과 같다. anagram으로 주어진 character들의 사용 빈도와 일치해야 한다. anagram이 ‘aab’라면 2개의 ‘a’와 하나의 ‘b’를 찾아야 한다. ‘aba’, ‘aab’, ‘baa’가 가능할 것이다. 비교한 String의 길이가 pattern으로 주어진 anagram의 길이와 같아야 한다. 예를 들어 anagram이 ‘aab’라면 ‘aacb’와 비교했을때 빈도가 ‘a’와 ‘b’의 빈도가 일치하지만 중간에 c가 껴있어 그 길이가 다르다. 이 알고리즘에서는 anagram에 존재하지 않는 character가 나타났는지를 확인하는 방식을 사용하지 않는다. 1번 조건은 HashMap과 counter를 이용하여 조건을 달성했는지 확인한다. Map에 character와 frequency를 넣고, 이것이 0에 도달하면 counter(초기값은 Map의 size(), 즉, anagram에 사용된 character 갯수)를 하나 줄여서 counter가 0에 도달하면 그 조건에 달성한 것으로 본다. 이때 주의할 점은 frequency는 negative값이 될 수 있다는 것이다. 예를 들어 anagram이 ‘aab’이고 입력 string이 ‘aaaaa’라면 ‘a’ entry의 값의 초기값은 2 이지만 마지막에 도달했을때는 -3이 되어 있을 것이다. 물론 counter는 0이 되어 있어 anagram에 사용된 횟수만큼의 ‘a’가 출현했음을 표시한다. 2번 조건은 start와 end의 길이를 anagram길이와 비교함으로써 달성한다. 예를 들어 비교하고자하는 string이 ‘aaab’이고 anagram이 ‘aab’이면 첫번째 a에서는 길이가 anagram의 길이보다 하나 더 길기 때문에 조건에 달성안되지만, start가 두번째 ‘a’인 경우에는 길이가 일치하게 된다. 알고리즘 위의 접근법을 이용한 알고리즘은 다음과 같다. 입력 anagram을 이용해서 Map과 counter를 초기화 한다. start와 end index를 0으로 초기화 한다. start가 먼저 출발해서 index를 하나씩 증가시키면서 1번 조건이 달성되었는지 확인한다. 달성이 안되면 전체 입력 string에 걸쳐 필요한 character들이 모두 출현하지 않은 것이다. 만약 counter가 0이 되면, (즉, 필요한 character들을 모두 찾으면) end를 증가시키면서 두 번째 조건인 길리조건이 만족하는지 확인한다. start-end가 anagram과 길이가 같으면 anagram을 찾은 것이 된다. 그리고 counter가 0인 경우 다시 anagram에서 사용된 character를 다시 찾아서, 찾는 경우 이번에는 반대로 Map의 entry의 값을 1 증가 시킨다. 다음 예를 보자. 입력 anagram이 ‘aab’인데 counter가 0이 된 시점에 ‘cccaacaacab’라고 생각해보자. ‘c’를 만나면 그냥 계속 end를 앞으로 진행시키다가 ‘a’를 만나면 위에서 말한바와 같이 길이를 비교한다. 3보다 길기 때문에 일치하지 않는 것으로 판단한다. 그리고 map의 ‘a’ 값을 1 증가시킨다. 하지만 처음 두개의 ‘a’가 계속 나와도 아직 그 값이 0보다 커지진 않았다. 왜냐하면 처음 start를 진행시킬때 이것이 negative값이 되어 있기 때문이다. 마지막에서 두번째 ‘a’를 만다면 ‘a’의 값이 ‘1’보다 커져서 counter를 1증가 시킨다. 이때가 바로 ‘acab’인 시점이다. 이때 길이 조건을 확인했는데 anagram길이보다 길기 때문에 아닌 것으로 판단하고, ‘a’의 값을 1 증가시키면, 값이 0보가 커지게 되어 counter의 값도 0이 아닌 1이 된다. counter의 값이 0이 아니게 되면 end의 증가를 멈추가 start가 증가하게 된다. 위의 경우는 ‘cab’의 ‘c’가 end가 멈춘부분이고 ‘b’가 start가 멈추어 있던 부분이다. 이제 ‘cab’뒤에 ‘a’가 하나 더 있어 ‘cabaa’라고 생각해보자. counter는 1이고 ‘a’의 값은 1, ‘b’의 값은 0이 시점이다. start를 하나 더 증가한 뒤 ‘b’바로 뒤의 ‘a’를 map에서 확인해서 값을 하나 줄여 0이 되었기에 counter가 다시 0이 된다. 그러면 end가 다시 시작하는데 ‘c’는 무시하고 지나가고 ‘a’를 만나서 길이를 비교한다. start - end가 3이기에 anagram을 찾은 것이 된다. 다시 ‘a’의 값을 1 증가시켜서 counter가 1이 되고, start가 다시 증가해서 이번에는 역시 ‘a’를 만나 값을 다시 줄이고 counter도 줄여서 0이 되어 다시 end가 움직여 anagram을 또 찾았음을 확인하게 된다. code public class Solution { public List&lt;Integer&gt; findAnagrams(String s, String t) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if(t.length()&gt; s.length()) return result; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c : t.toCharArray()){ map.put(c, map.getOrDefault(c, 0) + 1); } int counter = map.size(); int begin = 0, end = 0; int head = 0; int len = Integer.MAX_VALUE; while(end &lt; s.length()){ char c = s.charAt(end); if( map.containsKey(c) ){ map.put(c, map.get(c)-1); if(map.get(c) == 0) counter--; } end++; while(counter == 0){ char tempc = s.charAt(begin); if(map.containsKey(tempc)){ map.put(tempc, map.get(tempc) + 1); if(map.get(tempc) &gt; 0){ counter++; } } if(end-begin == t.length()){ result.add(begin); } begin++; } } return result; } }",
    "url": "http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html",
    "relUrl": "/docs/codingInterview/2018-07-28-algorithm-sliding-window.html"
  },
  "73": {
    "id": "73",
    "title": "Tool - Quick directory alias",
    "content": "mac이나 linux의 터미널에서 directory 이동을 편리하게 해주는 quick-directory-alias에 몇가지 기능을 추가해서 사용하고 있다. 나름 만족해서 사용하고 있어서 블로그를 통해 공유한다. 기존 기능 기존의 quick-directory-alias는 directory의 alias의 추가, 삭제, 확인이 가능하고, 무엇보다 그 alias로 바로 jump하는데 유용하다. alias의 자동완성 또한 지원한다. 강화된 기능 기존 스크립트로도 사실 잘 사용하고 있지만, 자주 사용하다보니 아쉬운 기능이 있어 다음과 같은 기능을 추가했다. alias에 설명 추가: 리스트를 설명과 함께 확인할 수 있어서 선택을 용이하게 한다. alias list clear: 리스트를 완전히 지우고 다시 만들기 쉽게 했다. embedded command 실행: 내가 자주 사용하는 intellij IDEA, sourcetree, finder(mac)을 alias상에서 즉시 실행할 수 있도록 했다. custom command 실행: 기타 어떤 명령이라도 해당 alias사에서 실행 할 수 있도록 했다. 자세한 내용은 아래 설명을 참조하자. git respository https://github.com/dakoo/shell-directory-management/blob/master/README.md Installation Download the script Source the script into your current shell (add this to your shell startup script to always have the command available) Done Quick setup commands Note: Before running the following, change RC_FILE to match your preferred shell’s rc file, or any other file that you source when a new shell/terminal is created. RC_FILE=~/.bashrc SCRIPT_DIRECTORY=~/scripts mkdir -p $SCRIPT_DIRECTORY wget -O $SCRIPT_DIRECTORY/quick-directory-aliases.sh https://raw.githubusercontent.com/mcwoodle/shell-directory-management/master/quick-directory-aliases.sh printf &quot; n. $SCRIPT_DIRECTORY/quick-directory-aliases.sh n&quot; &gt;&gt; $RC_FILE . $RC_FILE The default name for the command is “d”. Edit the quick-directory-aliases.sh script and change the function name d() to a name of your choosing. Usage Add an alias % cd /any/really/long/or/short/directory/path/thats/hardoreasy/to/remember % d + shortAliasName Note: changes take effect immediately across terminals/shells. Also you can add a tag to the alias. % cd /any/really/long/or/short/directory/path/thats/hardoreasy/to/remember % d + shortAliasName &quot;some tag or comment&quot; Navigate to an alias % d shortAliasName % pwd /any/really/long/or/short/directory/path/thats/hardoreasy/to/remember Remove an alias % d - shortAliasName See all aliases % d workspace = /home/mcwoodle/workspaces/someWorkspaceDirectory -&gt; workspace bin = /usr/bin -&gt; bin folder nhl = /home/mcwoodle/go/leafs/go -&gt; . Clear all aliases % d c all Help % d ? Execute a command in the alias Run intellij idea in the folder % d e workspace ij Run sourcetree in the folder % d e workspace st Run finder in the folder(mac) % d e workspace op Custom Command in the folder % d e workspace pwd If the command consists of multiple words, wrap it with double quotes. % d e workspace &quot;ls -al&quot; Customize the embedded commands You could modify the following block of the script. if $_d_excuteCommand; then _d_cmd=`printf &quot;$_d_aliasRow&quot; | sed -e &quot;s,.* = (.* ) -&gt; .*, 1,&quot;` printf &quot;cd $_d_cmd n&quot; case &quot;$2&quot; in ij) /usr/local/bin/idea $_d_cmd;; st) stree $_d_cmd;; op) open $_d_cmd;; *) &quot;$2&quot; $_d_cmd;; esac return 1 fi Autocomplete Autocomplete is currently only supported using bash and zsh (or any script supporting complete compgen or compctl built-ins). Installation is automatic and works like any other bash/zsh tab based autocomplete.",
    "url": "http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html",
    "relUrl": "/docs/tool/2018-11-12-quick-directory-alias.html"
  },
  "74": {
    "id": "74",
    "title": "Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기",
    "content": "mac iterm2에서 작업을 실행할 경우 새로 탭을 열어서 그 폴더로 이동해서 작업을 실행해야 하는 경우가 종종 있다. 이를 한번에 하도록 하자. 목표 mac iterm2에서 현재 폴더에서 명령을 실행시킬 때 현재 탭이 아닌 다른 탭을 열어서 실행되도록 하자. 이때 되도록 알맞은 profile을 선택해서 실행하자. osa script 작성 ~/scripts folder 아래에 newtab.scpt를 만들고 아래 내용을 붙여 넣는다. #!/usr/bin/osascript on run argv tell application &quot;iTerm 2&quot; to activate tell application &quot;iTerm 2&quot; to tell current window to create tab with profile &quot;iTerm_Profile_name&quot; #tell application &quot;iTerm 2&quot; to create window with profile &quot;iTerm_Profile_name&quot; tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to keystroke item 1 of argv tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to key code 52 tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to keystroke item 2 of argv tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to key code 52 end run 만약 새로운 탭이 아닌 새로운 윈도우 창을 열어서 실행시키고 싶은 경우 위의 주석처리한 줄의 주석 마크(#)를 지우고, 그 바로 위의 줄을 주석처리한다. 그리고 미리 iterm에 profile을 만들어서 연결해주거나 또는 프로파일 관련 부분을 삭제한다. shell script 작성 ~/scripts folder 아래에 newtab.sh 파일을 만들고 다음 내용을 붙여 넣는다. function run { _d_curDir=`pwd` osascript /Users/hochshin/scripts/newtab.scpt &quot;cd $_d_curDir&quot; &quot;$1&quot; } RC 파일에 추가 .bashrc 또는 .zshrc 파일에 다음을 추가해서 터미널이 실행시 function이 등록되도록 한다. #Custom Scripts . ~/scripts/newtab.sh 터미널을 재시작하거나 또는 아래 명령을 통해 alias를 등록한다. % source .bashrc or % source .zshrc 실행 다음과 같이 사용한다. % run some_long_running_command or argument가 있거나 여러 명령을 함께 수행하는 경우 % run &quot;some_long_running_command arguments &amp;&amp; noti&quot; 이렇게 하면 새로운 탭이 열리며 some_long_running_command가 현재 명령이 실행하는 폴더에서 실행되게 된다.",
    "url": "http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html",
    "relUrl": "/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html"
  },
  "75": {
    "id": "75",
    "title": "Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기",
    "content": "mac iterm2에서 ssh로 다른 host에 접속할 경우 새로 탭을 열어서 원하는 profile과 함께 연결되도록 하자. 목표 mac iterm2에서 현재 폴더에서 gossh명령을 실행시키면 현재 탭이 아닌 다른 탭을 열어서 ssh로 정해진 host로 접속되도록 하자. 이때 되도록 알맞은 profile을 선택해서 실행하자. osa script 작성 ~/scripts folder 아래에 remote.scpt를 만들고 아래 내용을 붙여 넣는다. #!/usr/bin/osascript tell application &quot;iTerm 2&quot; to activate tell application &quot;iTerm 2&quot; to tell current window to create tab with profile &quot;iterm_profile_name&quot; tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to keystroke &quot;ssh ssh_address&quot; tell application &quot;System Events&quot; to tell process &quot;iTerm 2&quot; to key code 52 위에서 ssh_address대신 실제 접속할 host의 address를 붙여넣는다. 그리고, 미리 iterm에 profile을 만들어서 연결해주거나 또는 프로파일 관련 부분을 삭제한다. shell script 작성 ~/scripts folder 아래에 remote.sh 파일을 만들고 다음 내용을 붙여 넣는다. function gossh { osascript /Users/hochshin/scripts/remote.scpt } RC 파일에 추가 .bashrc 또는 .zshrc 파일에 다음을 추가해서 터미널이 실행시 function이 등록되도록 한다. #Custom Scripts . ~/scripts/remote.sh 터미널을 재시작하거나 또는 아래 명령을 통해 alias를 등록한다. % source .bashrc or % source .zshrc 실행 다음과 같이 사용한다. % gossh 이렇게 하면 새로운 탭이 원하는 profile과 함께 열리며 자동으로 ssh_address에 접속하게 된다.",
    "url": "http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html",
    "relUrl": "/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html"
  },
  "76": {
    "id": "76",
    "title": "Tool - Mac에서 터미널 작업 실행후 notification",
    "content": "mac 터미널에서 오래 걸리는 작업을 실행할 경우 작업의 종료를 알기 위해서는 터미널의 해당 탭으로 가서 작업 상황을 확인해야 하는 번거로움이 있다. 이를 해결해보자. 목표 터미널에서 수행한 작업이 끝나면 소리와 pop-up 창으로 작업 종료를 알 수 있게 만들자. script 작성 ~/scripts folder 아래에 notification.sh 파일을 만들고 다음 내용을 붙여 넣는다. alias noti=&quot;say &#39;task complete &#39;;osascript -e &#39;display notification &quot;task complete &quot; with title &quot;terminal &quot;&#39;&quot; RC 파일에 추가 .bashrc 또는 .zshrc 파일에 다음을 추가해서 터미널이 실행시 alias가 등록되도록 한다. #Custom Scripts . ~/scripts/notification.sh 터미널을 재시작하거나 또는 아래 명령을 통해 alias를 등록한다. % source .bashrc or % source .zshrc 실행 다음과 같이 사용한다. % some_long_running_command &amp;&amp; noti 이렇게 하면 some_long_running_command가 종료거나 중간에 에러가 발생해서 더이상 진행되지 못할 경우 소리와 pop-up window를 통해 그 상황을 바로 알 수 있다.",
    "url": "http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html",
    "relUrl": "/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html"
  },
  "77": {
    "id": "77",
    "title": "",
    "content": "404 Page not found :( The requested page could not be found.",
    "url": "http://localhost:4000/404.html",
    "relUrl": "/404.html"
  },
  "78": {
    "id": "78",
    "title": "Coding Interview",
    "content": "",
    "url": "http://localhost:4000/docs/codingInterview",
    "relUrl": "/docs/codingInterview"
  },
  "79": {
    "id": "79",
    "title": "",
    "content": "",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "80": {
    "id": "80",
    "title": "Java",
    "content": "",
    "url": "http://localhost:4000/docs/java",
    "relUrl": "/docs/java"
  },
  "81": {
    "id": "81",
    "title": "Javascript",
    "content": "",
    "url": "http://localhost:4000/docs/javascript",
    "relUrl": "/docs/javascript"
  },
  "82": {
    "id": "82",
    "title": "System Design Interview",
    "content": "",
    "url": "http://localhost:4000/docs/systemDesignInterview",
    "relUrl": "/docs/systemDesignInterview"
  },
  "83": {
    "id": "83",
    "title": "Tool",
    "content": "",
    "url": "http://localhost:4000/docs/tool",
    "relUrl": "/docs/tool"
  }
  
}
