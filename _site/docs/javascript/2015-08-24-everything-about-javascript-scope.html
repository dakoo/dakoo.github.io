<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Javascript - scope에 대해 알고자 했던 모든 것 - Clean Code</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Javascript - scope에 대해 알고자 했던 모든 것 | Clean Code</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Javascript - scope에 대해 알고자 했던 모든 것" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Clean Code" /> <meta property="og:description" content="Clean Code" /> <link rel="canonical" href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" /> <meta property="og:url" content="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" /> <meta property="og:site_name" content="Clean Code" /> <script type="application/ld+json"> {"description":"Clean Code","@type":"WebPage","url":"http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html","headline":"Javascript - scope에 대해 알고자 했던 모든 것","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Clean Code</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/codingInterview" class="navigation-list-link">Coding Interview</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html" class="navigation-list-link">Algorithm - sliding window algorithm</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html" class="navigation-list-link">Algorithm - Dijkstra's shortest path</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html" class="navigation-list-link">Data Structure - disjoints-set</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html" class="navigation-list-link">Data Structure - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html" class="navigation-list-link">Algorithm - Minimum Spanning Tree - Kruskal</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html" class="navigation-list-link">Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html" class="navigation-list-link">Algorithm - 부분 문자열의 사전순 정렬</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html" class="navigation-list-link">Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html" class="navigation-list-link">Algorithm - Floyd-Warshall</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html" class="navigation-list-link">Algorithm - 확률에 대한 간단 정리</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html" class="navigation-list-link">Algorithm - 0-1 Knapsack 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html" class="navigation-list-link">Algorithm - LCS(Longest Common Subsequence) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html" class="navigation-list-link">Algorithm - 순열과 조합</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html" class="navigation-list-link">Algorithm - Travelling Salesman Problem(TSP)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html" class="navigation-list-link">Algorithm - 독립 시행 확률</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html" class="navigation-list-link">Algorithm - combination</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html" class="navigation-list-link">Algorithm - quick sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html" class="navigation-list-link">Algorithm - 이분 탐색</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" class="navigation-list-link">Algorithm - Longest Increasing Subsequence</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html" class="navigation-list-link">Algorithm - maximum sum subarray</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html" class="navigation-list-link">Data Structure - hash table</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" class="navigation-list-link">Data Structure - binary search tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" class="navigation-list-link">Algorithm - binary tree 및 binary search tree 문제들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html" class="navigation-list-link">Algorithm - k번째 큰(작은) 아이템 찾기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html" class="navigation-list-link">Algorithm - merge sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html" class="navigation-list-link">Algorithm - Topological Sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html" class="navigation-list-link">Data Structure - LRU(Least Recently Used)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html" class="navigation-list-link">Algorithm - 2D Matrix 회전</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" class="navigation-list-link">Data Structure - B-tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html" class="navigation-list-link">Algorithm - DFS와 BFS</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/java" class="navigation-list-link">Java</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html" class="navigation-list-link">Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-collections-api.html" class="navigation-list-link">Java - Collections API</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html" class="navigation-list-link">Java - Comparable과 Comparator</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-lambda.html" class="navigation-list-link">Java - Lambda</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html" class="navigation-list-link">Java - Collection Framework</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-30-java-collection-list.html" class="navigation-list-link">Java - List 인터페이스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-arraylist.html" class="navigation-list-link">Java - ArrayList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html" class="navigation-list-link">Java - LinkedList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-04-java-stream.html" class="navigation-list-link">Java - Stream</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html" class="navigation-list-link">Java - StringBuilder</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html" class="navigation-list-link">Java - Comparator Interface 사용</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-generic-function.html" class="navigation-list-link">Java - Generic function</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-bitset.html" class="navigation-list-link">Java - BitSet class 예제</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html" class="navigation-list-link">Java - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html" class="navigation-list-link">Java - (멀티쓰레딩 1) Thread 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html" class="navigation-list-link">Java - (멀티쓰레딩 2) Executor 기본</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html" class="navigation-list-link">Java - vararg을 stream으로 변환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-annotation.html" class="navigation-list-link">Java - Annotation</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-name-threads.html" class="navigation-list-link">Java - (멀티쓰레딩 3) 쓰레드 이름 설정</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html" class="navigation-list-link">Java - (멀티쓰레딩 5) 데몬 쓰레드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html" class="navigation-list-link">Java - (멀티쓰레딩 4) 쓰레드에서 값 반환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html" class="navigation-list-link">Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html" class="navigation-list-link">Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html" class="navigation-list-link">Java - (멀티쓰레딩 9) 쓰레드 Join하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html" class="navigation-list-link">Java - (멀티쓰레딩 10) 쓰레드 스케쥴링</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html" class="navigation-list-link">Java - (멀티쓰레딩 7) 쓰레드 중지하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-02-java-naming.html" class="navigation-list-link">Java - 네이밍</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html" class="navigation-list-link">Java - final 키워드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-14-java-lombok.html" class="navigation-list-link">Java - Lombok</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-22-java-big-number.html" class="navigation-list-link">Java - Big Number(BigInteger와 BigDecimal)</a></li></ul></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/javascript" class="navigation-list-link">Javascript</a><ul class="navigation-list-child-list "><li class="navigation-list-item active"><a href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" class="navigation-list-link active">Javascript - scope에 대해 알고자 했던 모든 것</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html" class="navigation-list-link">Javascript - deep copy가 필요할 때 무얼 사용해야 할까?</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/systemDesignInterview" class="navigation-list-link">System Design Interview</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/tool" class="navigation-list-link">Tool</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html" class="navigation-list-link">Tool - Mac에서 터미널 작업 실행후 notification</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html" class="navigation-list-link">Git - pull request</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html" class="navigation-list-link">Git - 수정한 것 되돌리기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html" class="navigation-list-link">shell - 폴더에서 파일 내용 검색하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-07-git-diff.html" class="navigation-list-link">Git - diff 사용하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html" class="navigation-list-link">Tool - patch하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html" class="navigation-list-link">grep 명령 - 빈 줄이나 특정 줄 제거하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html" class="navigation-list-link">sed 명령 - 특정 문자열을 변경하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html" class="navigation-list-link">sort 명령 - 크기 역순으로 정렬하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html" class="navigation-list-link">유용한 bash 명령들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html" class="navigation-list-link">uml - plantuml</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html" class="navigation-list-link">Tool - Quick directory alias</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2015-07-21-uml-tools.html" class="navigation-list-link">Design - 좋은 UML 툴 추천</a></li></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Clean Code" aria-label="Search Clean Code" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/javascript">Javascript</a></li> <li class="breadcrumb-nav-list-item"><span>Javascript - scope에 대해 알고자 했던 모든 것</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <p>이 글은 javascript 전문가인 Todd Motto의 <a href="http://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/">Everything you wanted to know about Javascript Scope</a>라는 글을 Tood Motto의 동의를 받아 번역한 것이다. 사실 제대로 번역을 했다기 보다는 나의 관점에서 이해하기 용이한 수준으로 정리한 것이라 고백한다. 영문을 국문으로 번역하기 까다롭거나, 이해에 문제가 없는 부분은 건너 뛰거나 간략히 설명하였다. 그러므로, 내용에 대해 정확한 이해를 원한다면 Todd Motto의 원문을 참조하는 것을 권한다.</p> <h2 id="글의-목적"> <a href="#글의-목적" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 글의 목적 </h2> <p>Javascript는 <strong>scope</strong>이라는 낯선 개념을 가지고 있는데, 이것은 초보 Javascript 개발자 만이 아니라 경험이 많은 개발자도 이해하기 쉽지 않다. 이 글은 scope, closure, this, namespace, function scope, global scope, lexical scope, public/private scope 등과 같은 Javascript의 어려운 부분에 대한 이해를 높이는 것을 목적으로 한다.</p> <p>이 글을 통해 다음의 질문들에 대한 답을 얻기를 바란다.</p> <ul> <li>scope이란 무엇인가?</li> <li>global/local scope이란?</li> <li>namespace란 무엇이며, scope과 어떻게 다른가?</li> <li>this 키워드는 무엇이며, scope에 어떻게 영향을 미치는가?</li> <li>function/lexical scope이란 무엇인가?</li> <li>closure란?</li> <li>public/private scope이란 무엇인가?</li> <li>어떻게 위의 모든 개념을 이해하고, 만들고, 사용할 수 있는가?</li> </ul> <h2 id="scope이란-무엇인가"> <a href="#scope이란-무엇인가" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Scope이란 무엇인가? </h2> <p>Javascript에서 scope은 작성된 코드를 둘러싼 환경을 말한다. scope은 전역(global) 또는 지역적(local)으로 정의될 수 있다. 제대로된 코드를 작성하고, 더 나은 개발자가 되기 위해서는 Javacript scope에 대해 제대로 이해해야 한다. 이 글을 통해 변수나 function들을 사용할 수 있는 영역이 어디까지 인지를 이해하고, 코드를 둘러싼 scope을 변경할 수 있고, 더 빠르면서도 쉽게 유지 보수 할 수 있는 작성하게 될 것이다.</p> <p>scope의 개념은 쉽게 생각해 다음과 같은 것이다. scope A와 scope B 중 어디 안에 우리가 있는 것인지 파악하는 것이다.</p> <h2 id="global-scope이란"> <a href="#global-scope이란" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Global scope이란? </h2> <p>어떤 Javascript code를 작성하기 전에는 우리는 global scope이라 불리는 곳에 있다. 만약 우리가 하나의 변수를 선언한다면 이것은 global로(전역으로) 정의된다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global scope</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div> <p>global scope은 가장 친한 친구이자 끔찍한 악몽과도 같다. 배우기 쉽고 문제도 거의 없다. 사람들은 global scope이 나쁘다고 하지만, 사실 그 이유를 설명하지는 못한다. global scope은 사실 나쁘지 않으며, 다양한 scope에서 접근하는 모듈이나 API를 만들기 위해서는 global scope을 사용해야 한다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">jQuery</span><span class="p">(</span><span class="dl">'</span><span class="s1">.myClass</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div> <p>global scope에서 jQuery에 접근하는 위의 코드는 <em>namespace</em>로써 이 접근을 설명할 수 있다. namespace는 때때로 scope과 혼동되어 사용 되지만, 일반적으로는 가장 높은 수준의 scope을 설명하는 것이다. 위의 경우에 <em>jQuery</em>는 global scope안에 있으며, 또한 namespace안에 있는 것이다. jQuery namespace는 global scope안에서 정의되며, 그 안의 모든 jQuery library를 위한 namespace로서 동작한다.</p> <h2 id="local-scope이란-무엇인가"> <a href="#local-scope이란-무엇인가" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Local scope이란 무엇인가? </h2> <p>local scope은 global scope외의 scope을 의미한다. 일반적으로 하나의 global scope이 있고, 정의된 각각의 function은 그 자신의 local scope을 가지고 있다. 다른 function 내에 정의된 function은 바깥의 function에 연결된 local scope을 가지고 있다.</p> <p>만약 하나의 function과 그 안의 여러 변수들을 정의한다면 각각의 변수들의 scope은 그 함수로 제한된다. 다음의 예를 살펴보자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//scope A: 여기가 global scope</span>
<span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//scope B: local scope은 여기</span>
<span class="p">};</span>
</code></pre></div></div> <p>local scope으로 제한된 모든 item들은 global scope에 노출되지 않는다면, global scope에서 접근할 수 없다(not visible). 간단한 예는 다음과 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//Todd</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//Uncaught ReferenceError: name is not defined</span>
</code></pre></div></div> <p>변수 <em>name</em>의 scope은 local로 제한되고, 부모 scope(여기서는 global scope)에 노출되지 않기 때문에 undefined가 된다.</p> <h2 id="function-scope"> <a href="#function-scope" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Function scope </h2> <p>Javascript내의 모든 scope들은 Function scope과 함께 만들어진다. (global scope은 만들어지는 것이 아니라 기본적으로 존재하는 것이다.) <em>for</em> 또는 <em>while</em>과 같은 loop이나 <em>if</em> 또는 <em>switch</em>와 같은 구문을 통해 만들어지지 않는다. <strong>새로운 function = 새로운 scope</strong> - 이것이 규칙이다. 이 scope 생성의 예는 다음과 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//scope A</span>
<span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//scope B</span>
    <span class="kd">var</span> <span class="nx">myOtherFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//scope C</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>새로운 scope과 새로운 변수, function, object를 생성하는 것은 쉽다.</p> <h2 id="lexical-scope"> <a href="#lexical-scope" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Lexical scope </h2> <p>하나의 function내에 다른 function이 있다면, 내부의 function은 외부의 function의 scope에 접근할 수 있다. 이것을 우리는 <strong>Lexical Scope</strong> 또는 <strong>Closure</strong>라 부르며, 또는 <strong>Static Scope</strong>아라 하기도 한다. 간단한 예는 아래와 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//scope A</span>
<span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//scope B</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// scope B에서 정의</span>
    <span class="kd">var</span> <span class="nx">myOtherFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="c1">//scope C: 'name' 변수에 접근할 수 있다.</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>myOtherfunction이 myFunction내에서 <strong>정의된</strong> 것일 뿐 항상 myFunction내에서만 호출되지 않을 수 있다는 것을 기억하자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">myOtherFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">My name is </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">myOtherFunction</span><span class="p">();</span> <span class="c1">// myOtherFunction 호출</span>
<span class="p">};</span>
<span class="nx">myFunction</span><span class="p">();</span> <span class="c1">// myFunction 호출</span>
</code></pre></div></div> <p>위의 코드를 실행하면 아래와 같은 결과를 얻을 수 있다.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Todd
My name is Todd 
</code></pre></div></div> <p>Lexical scope은 부모 scope안에 정의된 어떠한 변수, object, function과도 쉽게 연동된다. 그것들은 scope chain안에서 접근 가능하다. 예를 들어 다음과 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">scope1</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// name 은 여기서 접근 가능하다. </span>
  <span class="kd">var</span> <span class="nx">scope2</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">//  name 은 여기서도 접근 가능하다. </span>
    <span class="kd">var</span> <span class="nx">scope3</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="c1">//  name 은 여기서도 역시 접근 가능하다. </span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>Lexical scope은 반대방향으로는 동작하지 않는다는 것은 기억해야 한다. 다음의 경우가 그렇다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// name = undefined</span>
<span class="n">var</span> <span class="n">scope1</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// name = undefined</span>
  <span class="n">var</span> <span class="n">scope2</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// name = undefined</span>
    <span class="n">var</span> <span class="n">scope3</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="n">var</span> <span class="n">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">Todd</span><span class="err">'</span><span class="p">;</span> <span class="c1">// local scope</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>우리는 변수 name의 참조를 return할 수는 있지만, 결코 그 변수 자체를 return할 수는 없다.</p> <h2 id="scope-chain"> <a href="#scope-chain" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Scope Chain </h2> <p>알고있는 바와 같이, 정의된 function 각각은 자신만의 중첩된 scope을 가지고 있다. 다른 function 안에 정의된 local scope을 가진 내부 function은 바깥 function과 <strong>연결</strong>되어 있다. 그 연결을 우리는 scope chain이라고 부른다. 코드 안에 어디에 위치하느냐가 scope chain에서의 scope을 결정한다. function내의 변수를 ‘resolve’(번역을 어떻게 해야할 지 모르겠다)할 때, Javascript는 변수를 찾을 때까지 그 scope - scope chain의 가장 내부 scope - 에서 시작해서 scope chain을 따라 바깥쪽 scope 방향으로 검색을 한다.</p> <h2 id="closure"> <a href="#closure" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Closure </h2> <p>Closure는 Lexical scope과 강하게 연결되어 있다. 어떻게 closure가 동작하는지 이해하기 위한 좋은 예는 <em>function reference</em>를 반환하는 경우이다. 한 function의 scope 내에서 parent scope의 변수를 사용하는 것을 생각해보자. 그리고 그 function reference를 반환하면 parent scope의 변수는 어떻게 될까?</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello, </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p><em>sayHello</em> 안에 closure 개념의 function을 정의해 외부에서 접근할 수 없는 scope을 만들었다. sayHello function을 호출하는 것만으로는 어떠한 일도 생기지 않는다. 어떤 출력도 없으며 단지 하나의 function이 반환될 뿐이다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sayHello</span><span class="p">(</span><span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 어떠한 일도 발생하지 않는다.</span>
</code></pre></div></div> <p>function을 반환하는 function을 사용하기 위해서는 할당 후 호출해야 한다는 의미이다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">helloTodd</span> <span class="o">=</span> <span class="nx">sayHello</span><span class="p">(</span><span class="dl">'</span><span class="s1">Todd</span><span class="dl">'</span><span class="p">);</span> 
<span class="nx">helloTodd</span><span class="p">();</span> <span class="c1">//이것은 closure를 호출하여 'Hello, Todd'를 출력한다. </span>
</code></pre></div></div> <p>사실, closure를 사용하기 위해 ‘할당 후 호출’이 필요하다는 것은 거짓말이다. 다음과 같이 사용할 수도 있다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sayHello2</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span><span class="p">)();</span> <span class="c1">// 반환된 함수를 할당없이 바로 호출</span>
</code></pre></div></div> <h3 id="angularjs에서의-closure-사용예"> <a href="#angularjs에서의-closure-사용예" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> AngularJS에서의 Closure 사용예 </h3> <p>AngularJS는 위와 같은 테크닉을 <em>$compile</em> 메소드를 위해 사용하고 있다. 이것은 현재 scope reference를 closure의 인수로 사용한다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$compile</span><span class="p">(</span><span class="nx">template</span><span class="p">)(</span><span class="nx">scope</span><span class="p">);</span>
</code></pre></div></div> <p>우리는 위의 코드가 실제 다음과 같이 구현되어 있을 것이라 추측할 수 있다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">$compile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">template</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">scope</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//'template'과 'scope' 에 접근해서 무언가 한다. </span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>function을 반환하는 function을 closure라고 부르지 않는다. 그보다는 간단히 말해, closure는 <strong>바깥의 scope의 변수를 사용하는 immediate lexical scope</strong>이라 할 수 있다.</p> <h2 id="scope과-this-키워드"> <a href="#scope과-this-키워드" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Scope과 ‘this’ 키워드 </h2> <p>각 scope은 어떻게 그 function이 호출되느냐에 따라 달라지는 <em>this</em>의 값을 바인드 하고 있다. <em>this</em> 키워드를 다들 사용하고 있지만, 많은 사람들은 호출될 때에 따라 어떻게 그 것이 달라지는지 정확히 이해하지 못하고 있다.</p> <p>default로 <em>this</em>는 가장 바깥의 global object인 <em>window</em>를 가리킨다. function을 호출하는 방식을 달리하는 것으로 <em>this</em>의 값을 다르게 바인드 할 수 있다. 그 예는 다음과 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this = global, [object Window]</span>
<span class="p">};</span>
<span class="nx">myFunction</span><span class="p">();</span>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">myObject</span><span class="p">.</span><span class="nx">myMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this = Object { myObject }</span>
<span class="p">};</span>
</code></pre></div></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nav</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.nav</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// &lt;nav class="nav"&gt;</span>
<span class="kd">var</span> <span class="nx">toggleNav</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this = &lt;nav&gt; element</span>
<span class="p">};</span>
<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <h3 id="this-값의-변화"> <a href="#this-값의-변화" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> this 값의 변화 </h3> <p><em>this</em>와 관련된 문제도 있다. 예를 들어 같은 function내에서도 scope이 변화 될 수 있고, 이때 또한 <em>this</em>의 값도 변화될 수 있다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nav</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.nav</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// &lt;nav class="nav"&gt;</span>
<span class="kd">var</span> <span class="nx">toggleNav</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// &lt;nav&gt; element</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// [object Window]</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>무슨 일이 생긴 걸까? 이벤트 핸들러로부터 호출되지 않은 새로운 scope이 생성되었고, 그래서 default인 <em>window</em> object가 <em>this</em>의 값이 된 것이다. 새로운 scope에 영향받지 않는 <em>this</em> 값을 얻기 위해서는 어떻게 해야 할까? 그렇게 하기 위해서 <em>this</em>의 값을 저장할 새로운 변수 - 여기서는 <em>that</em> - 를 사용한 lexical 바인딩을 한다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">nav</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.nav</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// &lt;nav class="nav"&gt;</span>
<span class="kd">var</span> <span class="nx">toggleNav</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">//this의 값을 저장</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span> <span class="c1">// &lt;nav&gt; element</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span> <span class="c1">// &lt;nav&gt; element</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>이것이 새롭게 생성된 scope에서도 원하는 <em>this</em> 값을 참조할 수 있는 방법이다.</p> <h2 id="call-apply-bind를-이용하여-scope-변경하기"> <a href="#call-apply-bind를-이용하여-scope-변경하기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> .call(), .apply(), .bind()를 이용하여 scope 변경하기 </h2> <p>때때로 Javascript의 scope을 조작할 필요가 있다. 반복문 내에서 scope이 어떻게 변경되는지에 대 설명하기 위한 간단한 샘플 코드는 아래와 같다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">nav li</span><span class="dl">'</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// [object Window]</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드에서 <em>this</em>의 값은 어떤 element도 가리키지 않으며, 우리는 어떤 것도 호출하거나 scope을 변경하기 위한 무엇도 하지 않았다. 이제, 우리가 어떻게 scope을 바꿀 수 있는지 살펴보자. (사실, scope을 변경하는 것처럼 보이지만, 실제 우리가 하는 것은 function이 호출되는 환경을 변경하는 것이다.)</p> <h3 id="call과-apply"> <a href="#call과-apply" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> .call()과 .apply() </h3> <p><em>.call()</em>과 <em>apply()</em> 메소드는 정말 엄청나다! 그 메소드들을 통해 올바른 <em>this</em> 값을 바인드하고 있는 function의 scope안으로 들어갈 수 있다. 위의 샘플 코드를 변경하여 배열 내의 각 element을 <em>this</em> 값으로 하는 경우를 살펴 보자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">nav li</span><span class="dl">'</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 <em>this</em>의 값이 반복되는 element를 가리키도록 function의 scope을 <em>links[i]</em>로 변경했다.</p> <h3 id="call과-apply의-차이"> <a href="#call과-apply의-차이" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> .call()과 .apply()의 차이 </h3> <p><em>.call()</em>이나 <em>.apply()</em>를 이용해 scope을 변화시킬 수 있는데 그 둘 사이에는 약간의 차이가 있다. <em>.call()(scope, arg1, arg2, arg3)</em>은 쉼표를 이용해 각 각의 인수를 구분하는 반면, <em>.apply(scope, [arg1, agr2])</em>는 하나의 배열을 이용해 인수를 넘겨준다.</p> <p><em>.call()</em> 또는 <em>.apply()</em>를 하더라도 실제 function을 호출한다는 점에서는 동일하다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myFunction</span><span class="p">();</span> <span class="c1">//myFunction 호출</span>
</code></pre></div></div> <p><em>.call()</em>을 사용해서 function을 호출 해보자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myFunction</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span> <span class="c1">//.call()을 이용해 myFunction 호출</span>
</code></pre></div></div> <h3 id="bind"> <a href="#bind" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> .bind() </h3> <p><em>.bind()</em>는 function을 호출하지 않는다. 대신 function을 호출하기 전에 그 값들과 단지 바인드 할 뿐이다. <em>.bind()</em>는 ECMASCript5에서 소개되었는데, 소개된 초기만큼 좋은 평가를 받지는 못하고 있다.</p> <p>function reference를 자신의 인수와 함께 다른 function의 인수로 사용할 수 있는지 살펴보자. 물론, 우리는 function reference에 인수를 넣어 다른 function의 인수로 사용할 수 없다는 것을 알고 있다. 예를 들어 다음을 보자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// toggleNav가 addEventListener의 인수로 동작한다.  </span>
<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>

<span class="c1">// toggleNav(arg1, arg2)가 addEventListener의 인수로 동작하지 않고, 바로 실행된다. </span>
<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>위의 경우를 다음과 같이 바꿀 수 있다. function을 새로 정의해 그 function을 다른 function의 인수로 사용하는 것이다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">toggleNav</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>하지만, toggleNav는 한 function의 내부 function으로 바뀌었기 때문에 scope이 바꾸어진 것이고 이것은 우리가 원하는 바가 아니다.</p> <p><em>.bind()</em>는 이런 문제를 해결해 준다. function이 호출되지 않은 채 다른 function의 인수로 사용될 수 있게 한다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="nx">toggleNav</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div> <p>toggleNav는 호출되지 않고, 또한 scope이 변화되지 않은채로(필요하다면 변화시킬 수 있다.) 그 인수들과 함께 다른 function의 인수로 사용되어 졌다.</p> <h2 id="private-및-public-scope"> <a href="#private-및-public-scope" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Private 및 Public Scope </h2> <p>많은 프로그래밍 언어에는 public과 private scope이 있다. - Java와 C++에는 public/private 키워드가 존재한다. 하지만, Javascript에는 그런 것들이 없다. 대신 <em>Closure</em>를 통해 비슷한 개념을 만들어 낼 수 있다.</p> <p>Javascript 디자인 패턴을 이용하면, 예를 들어 <strong>module 패턴</strong>을 이용하면, 우리는 public/private scope을 만들수 있다.</p> <h3 id="private-scope을-만드는-간단한-방법"> <a href="#private-scope을-만드는-간단한-방법" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> private scope을 만드는 간단한 방법 </h3> <p>private scope을 만드는 간단한 방법은 function들을 하나의 function으로 감싸는 것이다. 우리가 배운 바와 같이 function은 scope을 만들기 때문에 global scope이 아닌 다른 scope으로 function들을 이동시키는 것이다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 여기는 private scope</span>
<span class="p">})();</span>
</code></pre></div></div> <p>그리고, function 내에서 사용하기 위해 몇 개의 function을 추가할 수 있다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 여기서 필요한 작업을 한다. </span>
  <span class="p">};</span>
<span class="p">})();</span>
</code></pre></div></div> <p>우리가 정의한 내부의 function을 외부에서 호출하면 에러가 발생한다. 즉, 우리는 private scope을 만드는 것을 성공한 것이다!</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">};</span>
<span class="p">})();</span>

<span class="nx">myFunction</span><span class="p">();</span> <span class="c1">// Uncaught ReferenceError: myFunction is not defined</span>
</code></pre></div></div> <h3 id="module-패턴"> <a href="#module-패턴" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> module 패턴 </h3> <p>만약 그 내부 function을 public으로 만들기 원한다면? <strong>module 패턴</strong> (그리고 <strong>revealing module 패턴</strong>)이라 불리는 훌륭한 패턴을 이용하면 우리의 function의 scope을 올바르게 정할 수 있다.</p> <h4 id="function-반환을-통한-module-패턴-구현"> <a href="#function-반환을-통한-module-패턴-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> function 반환을 통한 module 패턴 구현 </h4> <p>관련된 모든 코드를 포함하고 있는 ‘Module’이라 불리는 global namespace를 살펴보자.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// module 정의</span>
<span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">myMethod</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">myMethod has been called.</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>

<span class="c1">// module + 메소드의 호출</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">();</span>
</code></pre></div></div> <p>위에서 <em>return</em> 구문은 <em>public</em> 메소드를 반환한다. 그 메소드는 global scope(namespace)에서 접근 가능하다. 위의 Module은 다음과 같이 확장 가능하다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// module 정의</span>
<span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">myMethod</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="p">},</span>
    <span class="na">someOtherMethod</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>

<span class="c1">// module + 메소드의 호출</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">();</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">someOtherMethod</span><span class="p">();</span>
</code></pre></div></div> <p>private 메소드는 어떨까? 많은 개발자들이 global scope안에 모든 function들을 마구 정의하기 때문에 global namespace가 더럽혀진다. 굳이 외부에 공개될 필요가 없는 function들은 global scope에 있을 필요가 없고, 단지 API만이 global scope에 있으면 된다. 다음 코드는 return되지 않는 function들을 이용해 private scope을 만들어 낼수 있다는 것을 보여준다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">publicMethod</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>
</code></pre></div></div> <p><em>publicMethod</em>는 외부에서 호출되어질 수 있는 반면 <em>privateMethod</em>는 그렇지 않다. 즉, <em>privateMethod</em>는 private scope에 있는 것이다. 이런 private scope안에 헬퍼, addClass, removeClass, Ajax/XHR 호출, 배열, 객체 등이 위치할 수 있다.</p> <p>다음의 예는 <em>public</em> 메소드가 반환된 이후에도 global scope에서는 접근할 수 없는 <em>private</em> 메소드에 접근할 수 있다는 것을 보여준다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">publicMethod</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="c1">// prvateMethod()를 호출할 수 있다. </span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>
</code></pre></div></div> <p>이것은 코드 보안성과 더불어 아주 강력한 수준의 상호 연동성을 제공한다. Javascript의 가장 중요한 부분 중 하나는 보안을 유지하는 것이다. 그것이 바로 우리가 모든 function들을 global scope에 정의해서 아무 곳에서나 접근하도록 하지 않는 이유이다.</p> <h4 id="object-반환을-통한-module-패턴-구현"> <a href="#object-반환을-통한-module-패턴-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Object 반환을 통한 module 패턴 구현 </h4> <p>public/private 메소드를 사용하기 위해 Object를 반환하는 예이다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">var</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="nx">myModule</span><span class="p">.</span><span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="nx">myModule</span><span class="p">.</span><span class="nx">anotherPublicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">myModule</span><span class="p">;</span> <span class="c1">// public 메소드들과 함께 Object 반환</span>
<span class="p">})();</span>

<span class="c1">// 사용</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">publicMethod</span><span class="p">();</span>
</code></pre></div></div> <p>네임 컨벤션 중 하나는 밑줄과 함께 <em>private</em> 메소드를 시작하는 것이다. 이것은 시각적으로 public과 private을 구분할 수 있게 도와준다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
<span class="p">})();</span>
</code></pre></div></div> <h4 id="object-스타일로-정의된-object-반환을-통한-module-패턴-구현"> <a href="#object-스타일로-정의된-object-반환을-통한-module-패턴-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Object 스타일로 정의된 Object 반환을 통한 module 패턴 구현 </h4> <p>익명의 <em>Object</em>를 반환할 때 간단히 function reference를 지정하는 <em>Object</em> 스타일로도 module 패턴을 만들수 있다.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">publicMethod</span><span class="p">:</span> <span class="nx">publicMethod</span><span class="p">,</span>
    <span class="na">anotherPublicMethod</span><span class="p">:</span> <span class="nx">anotherPublicMethod</span>
  <span class="p">}</span>
<span class="p">})();</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
