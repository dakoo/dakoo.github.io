<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Algorithm - Longest Increasing Subsequence - Clean Code</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Algorithm - Longest Increasing Subsequence | Clean Code</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Algorithm - Longest Increasing Subsequence" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Clean Code" /> <meta property="og:description" content="Clean Code" /> <link rel="canonical" href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" /> <meta property="og:url" content="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" /> <meta property="og:site_name" content="Clean Code" /> <script type="application/ld+json"> {"description":"Clean Code","@type":"WebPage","url":"http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html","headline":"Algorithm - Longest Increasing Subsequence","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Clean Code</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview" class="navigation-list-link">Coding Interview</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html" class="navigation-list-link">Algorithm - sliding window algorithm</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html" class="navigation-list-link">Algorithm - Dijkstra's shortest path</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html" class="navigation-list-link">Data Structure - disjoints-set</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html" class="navigation-list-link">Data Structure - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html" class="navigation-list-link">Algorithm - Minimum Spanning Tree - Kruskal</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html" class="navigation-list-link">Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html" class="navigation-list-link">Algorithm - 부분 문자열의 사전순 정렬</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html" class="navigation-list-link">Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html" class="navigation-list-link">Algorithm - Floyd-Warshall</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html" class="navigation-list-link">Algorithm - 확률에 대한 간단 정리</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html" class="navigation-list-link">Algorithm - 0-1 Knapsack 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html" class="navigation-list-link">Algorithm - LCS(Longest Common Subsequence) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html" class="navigation-list-link">Algorithm - 순열과 조합</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html" class="navigation-list-link">Algorithm - Travelling Salesman Problem(TSP)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html" class="navigation-list-link">Algorithm - 독립 시행 확률</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html" class="navigation-list-link">Algorithm - combination</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html" class="navigation-list-link">Algorithm - quick sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html" class="navigation-list-link">Algorithm - 이분 탐색</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" class="navigation-list-link active">Algorithm - Longest Increasing Subsequence</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html" class="navigation-list-link">Algorithm - maximum sum subarray</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html" class="navigation-list-link">Data Structure - hash table</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" class="navigation-list-link">Data Structure - binary search tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" class="navigation-list-link">Algorithm - binary tree 및 binary search tree 문제들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html" class="navigation-list-link">Algorithm - k번째 큰(작은) 아이템 찾기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html" class="navigation-list-link">Algorithm - merge sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html" class="navigation-list-link">Algorithm - Topological Sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html" class="navigation-list-link">Data Structure - LRU(Least Recently Used)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html" class="navigation-list-link">Algorithm - 2D Matrix 회전</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" class="navigation-list-link">Data Structure - B-tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html" class="navigation-list-link">Algorithm - DFS와 BFS</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/java" class="navigation-list-link">Java</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html" class="navigation-list-link">Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-collections-api.html" class="navigation-list-link">Java - Collections API</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html" class="navigation-list-link">Java - Comparable과 Comparator</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-lambda.html" class="navigation-list-link">Java - Lambda</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html" class="navigation-list-link">Java - Collection Framework</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-30-java-collection-list.html" class="navigation-list-link">Java - List 인터페이스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-arraylist.html" class="navigation-list-link">Java - ArrayList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html" class="navigation-list-link">Java - LinkedList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-04-java-stream.html" class="navigation-list-link">Java - Stream</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html" class="navigation-list-link">Java - StringBuilder</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html" class="navigation-list-link">Java - Comparator Interface 사용</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-generic-function.html" class="navigation-list-link">Java - Generic function</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-bitset.html" class="navigation-list-link">Java - BitSet class 예제</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html" class="navigation-list-link">Java - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html" class="navigation-list-link">Java - (멀티쓰레딩 1) Thread 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html" class="navigation-list-link">Java - (멀티쓰레딩 2) Executor 기본</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html" class="navigation-list-link">Java - vararg을 stream으로 변환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-annotation.html" class="navigation-list-link">Java - Annotation</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-name-threads.html" class="navigation-list-link">Java - (멀티쓰레딩 3) 쓰레드 이름 설정</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html" class="navigation-list-link">Java - (멀티쓰레딩 5) 데몬 쓰레드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html" class="navigation-list-link">Java - (멀티쓰레딩 4) 쓰레드에서 값 반환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html" class="navigation-list-link">Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html" class="navigation-list-link">Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html" class="navigation-list-link">Java - (멀티쓰레딩 9) 쓰레드 Join하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html" class="navigation-list-link">Java - (멀티쓰레딩 10) 쓰레드 스케쥴링</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html" class="navigation-list-link">Java - (멀티쓰레딩 7) 쓰레드 중지하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-02-java-naming.html" class="navigation-list-link">Java - 네이밍</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html" class="navigation-list-link">Java - final 키워드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-14-java-lombok.html" class="navigation-list-link">Java - Lombok</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-22-java-big-number.html" class="navigation-list-link">Java - Big Number(BigInteger와 BigDecimal)</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/javascript" class="navigation-list-link">Javascript</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" class="navigation-list-link">Javascript - scope에 대해 알고자 했던 모든 것</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html" class="navigation-list-link">Javascript - deep copy가 필요할 때 무얼 사용해야 할까?</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/systemDesignInterview" class="navigation-list-link">System Design Interview</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/tool" class="navigation-list-link">Tool</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html" class="navigation-list-link">Tool - Mac에서 터미널 작업 실행후 notification</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html" class="navigation-list-link">Git - pull request</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html" class="navigation-list-link">Git - 수정한 것 되돌리기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html" class="navigation-list-link">shell - 폴더에서 파일 내용 검색하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-07-git-diff.html" class="navigation-list-link">Git - diff 사용하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html" class="navigation-list-link">Tool - patch하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html" class="navigation-list-link">grep 명령 - 빈 줄이나 특정 줄 제거하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html" class="navigation-list-link">sed 명령 - 특정 문자열을 변경하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html" class="navigation-list-link">sort 명령 - 크기 역순으로 정렬하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html" class="navigation-list-link">유용한 bash 명령들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html" class="navigation-list-link">uml - plantuml</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html" class="navigation-list-link">Tool - Quick directory alias</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2015-07-21-uml-tools.html" class="navigation-list-link">Design - 좋은 UML 툴 추천</a></li></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Clean Code" aria-label="Search Clean Code" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/codingInterview">Coding Interview</a></li> <li class="breadcrumb-nav-list-item"><span>Algorithm - Longest Increasing Subsequence</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <p>Longest Increasing Sequence는 “순서” 또는 “아이템들을 연속해서 조합할 때의 최대” 등을 구할 때 매우 많이 사용되는 방법이다. 그런데 이때 보통 i번째 아이템에 대해 0부터 i-1까지의 아이템을 비교해서 최대값을 갱신하는 <a href="http://hochulshin.com/Longest-Increasing-Subsequence/">O(n*n) 알고리즘</a>이 흔히 사용된다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
    <span class="no">T</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="no">T</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>그런데 이런 식으로 하면 n이 100000이 넘어가면 계산이 너무 오래 걸린다. 그러므로 O(NlogN)알고리즘을 사용할 수 있어야 한다. 입력이 10000이하이면 구현이 용이한 O(n*n) 알고리즘을, 그 이상이면 O(NlogN) 알고리즘을 사용하는 것을 추천한다.</p> <h3 id="logn-lis"> <a href="#logn-lis" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> logN LIS </h3> <h4 id="필요한-자료구조"> <a href="#필요한-자료구조" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 필요한 자료구조 </h4> <ul> <li>입력 저장: int In[]</li> <li>계산 중의 LIS 저장: int T[], 초기값 T[0] = 0</li> <li>각 입력값 별 LIS시 이전 아이템 저장: int R[], 초기값 -1</li> <li>현재의 LIS 길이 저장: int lastIdx, 초기값 0</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">T</span><span class="o">(</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">R</span><span class="o">(</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</code></pre></div></div> <h4 id="계산"> <a href="#계산" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 계산 </h4> <p>항상 가장 작은 값으로 구성된 T를 유지함으로써 LIS를 찾아낼 수 있도록 In[1]부터 마지막 아이템까지 진행하면서 다음을 수행한다.</p> <ul> <li>In[T[lastIdx]] &lt; In[i]이면, (마지막 아이템과 비교해서 더 크면): R[i] = T[lastIdx], lastIdx++, T[lastIdx] = i</li> <li>In[T[lastIdx]] &lt; In[i]가 아니고, In[T[0]] &gt; In[T[i]]이면 (가장 작은 아이템과 비교해서 더 작으면): T[0] = i</li> <li>위의 조건에 만족하지 않으면 T[1]부터 T[lastIdx]중의 하나에 i값을 넣는다. 그 기준은 “In[i]의 같거나 큰 값 중 가장 작은 값”에 넣는 것이다. 이를 통해 마지막 위치(lastIdx)도 갱신될 수 있다. 항상 T[0]부터 T[lastIdx]이 가리키는 In[]값은 정렬되어 있으므로 logN탐색을 위해 <a href="http://hochulshin.com/algorithm-bisectional-search/">이분 탐색</a>을 이용한다. 그렇게 T[j]가 찾아지면: R[i] = T[j-1], T[j] = i</li> </ul> <p>위의 내용을 코드로 표현하면 다음과 같다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]]</span> <span class="o">&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">R</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">];</span>
            <span class="no">T</span><span class="o">[++</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">&gt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">findBigorSame</span><span class="o">(</span><span class="nc">In</span><span class="o">,</span> <span class="no">T</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastIdx</span><span class="o">,</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="no">R</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span>  <span class="no">T</span><span class="o">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="no">T</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div> <p>그런데, R[]은 계산이 끝나고 최대 값을 구성하는 아이템이 무엇인지 추적하기 위한 자료구조이고, T[]에 값이 아닌 index를 넣는 이유는 R[]을 쉽게 갱신하기 위한 것이다. 그러므로, 만약 풀고자 하는 문제가 단순한 최대 값이라면 R[]을 사용하지 않아도 되며, 또한 T[]도 인덱스가 아닌 값을 저장하면 된다. 그 코드의 예는 다음과 같다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">T</span><span class="o">[++</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">findBigorSame</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastIdx</span><span class="o">,</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">//T를 이분탐색 </span>
            <span class="no">T</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div> <h4 id="결과-처리"> <a href="#결과-처리" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 결과 처리 </h4> <p>마지막 아이템까지 진행이 끝났을 때 lastIdx + 1가 LIS의 길이가 되며, R[]은 각 index보다 앞의 것을 가리키게 된다. 그래서 순서를 구할 때는 R을 이용해서 역순으로 찾는다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">Out</span><span class="o">(</span><span class="n">lastIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>  <span class="c1">//In의 index를 저장한다. </span>
    <span class="kt">int</span> <span class="n">oIdx</span> <span class="o">=</span> <span class="n">lastIdx</span><span class="o">;</span>
    <span class="nc">Out</span><span class="o">[</span><span class="n">oIdx</span><span class="o">--]</span> <span class="o">=</span> <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">prvIdx</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]];</span>
    <span class="k">while</span><span class="o">(</span><span class="n">prvIdx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
        <span class="nc">Out</span><span class="o">[</span><span class="n">oIdx</span><span class="o">--]</span> <span class="o">=</span> <span class="n">prvIdx</span><span class="o">;</span>
        <span class="n">prvIdx</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">prvIdx</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="nc">Out</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="nc">Out</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div> <h3 id="code"> <a href="#code" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Code </h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="o">;</span>

<span class="kt">int</span> <span class="nf">findBigorSame</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">In</span><span class="o">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="no">T</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tar_val</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">middle</span><span class="o">]]</span> <span class="o">&gt;=</span> <span class="n">tar_val</span><span class="o">){</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">middle</span><span class="o">;</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">logNLIS</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">In</span><span class="o">){</span>
    <span class="c1">//초기화</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">T</span><span class="o">(</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">R</span><span class="o">(</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//계산</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]]</span> <span class="o">&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">R</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">];</span>
            <span class="no">T</span><span class="o">[++</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">&gt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">findBigorSame</span><span class="o">(</span><span class="nc">In</span><span class="o">,</span> <span class="no">T</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastIdx</span><span class="o">,</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="no">R</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span>  <span class="no">T</span><span class="o">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="no">T</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//LIS를 첫순서부터 저장</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">Out</span><span class="o">(</span><span class="n">lastIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">oIdx</span> <span class="o">=</span> <span class="n">lastIdx</span><span class="o">;</span>
    <span class="nc">Out</span><span class="o">[</span><span class="n">oIdx</span><span class="o">--]</span> <span class="o">=</span> <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">prvIdx</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]];</span>
    <span class="k">while</span><span class="o">(</span><span class="n">prvIdx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
        <span class="nc">Out</span><span class="o">[</span><span class="n">oIdx</span><span class="o">--]</span> <span class="o">=</span> <span class="n">prvIdx</span><span class="o">;</span>
        <span class="n">prvIdx</span> <span class="o">=</span> <span class="no">R</span><span class="o">[</span><span class="n">prvIdx</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nc">Out</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="o">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nc">In</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span> <span class="o">};</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nc">Out</span> <span class="o">=</span> <span class="n">logNLIS</span><span class="o">(</span><span class="nc">In</span><span class="o">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"SIZE : "</span> <span class="o">&lt;&lt;</span> <span class="nc">Out</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span> <span class="c1">//must be 6</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"SEQUENCE : "</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="nc">Out</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="nc">Out</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="o">;</span> <span class="c1">//must be -1 2 3 7 9 10</span>
    <span class="o">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h3 id="reference"> <a href="#reference" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Reference </h3> <p><a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/array/LongestIncreasingSubSequenceOlogNMethod.java">Javacode</a>와 <a href="https://www.youtube.com/watch?v=S9oUiVYEq7E">동영상 강의</a>를 참고하자.</p> <h3 id="실전-문제"> <a href="#실전-문제" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 실전 문제 </h3> <h4 id="쉬운-문제들"> <a href="#쉬운-문제들" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 쉬운 문제들 </h4> <h5 id="꼬인-전깃줄-문제"> <a href="#꼬인-전깃줄-문제" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <a href="https://www.acmicpc.net/problem/1365">꼬인 전깃줄</a> 문제 </h5> <ul> <li><strong>최대 100000개의 입력</strong>이 들어오므로 O(n*n)으로 하면 timeout이 나므로 nlogn알고리즘을 이용해야 한다.</li> <li>LIS의 구성을 묻지 않고 단순히 잘라야할 전기줄의 수를 묻는 문제이므로 R[]을 저장하지 않고 T[]만 이용해서 계산한다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lis</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nc">In</span><span class="o">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">T</span><span class="o">(</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">In</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]]</span> <span class="o">&lt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span> <span class="c1">//In[T의 마지막]보다 더 크면 하나 증가</span>
            <span class="n">lastIdx</span><span class="o">++;</span>
            <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="nc">In</span><span class="o">[</span><span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">&gt;</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span> <span class="c1">//In[T[0]]보다 작으면 T[0] 갱신</span>
            <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// In[T[0]]~In[T[lastIdx]] 중 In[i]보다 같거나 큰 최초의 수를 갱신</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">findSameorBig</span><span class="o">(</span><span class="nc">In</span><span class="o">,</span> <span class="no">T</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastIdx</span><span class="o">,</span> <span class="nc">In</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="no">T</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">lastIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> <h5 id="반도체-설계-문제"> <a href="#반도체-설계-문제" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> <a href="https://www.acmicpc.net/problem/2352">반도체 설계</a> 문제 </h5> <ul> <li><a href="https://www.acmicpc.net/problem/1365">꼬인 전깃줄</a>과 동일한 방식으로 풀면 되는 문제이다.</li> <li><strong>최대 40000개의 입력</strong>이며, LIS의 구성을 묻지 않고 단순히 갯수를 묻는 문제이다.</li> <li><em>*입력을 저장하지 않고 바로 처리하도록 풀었으며 이로 인해 T[]는 *index를 저장하는 것이 아니라 값을 직접 저장</em>하도록 수정했다.</li> </ul> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findSameorBig</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="no">T</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="n">m</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">){</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="o">(){</span>
    <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="no">N</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="o">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="nf">T</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">lastIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="o">;</span>
    <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">){</span>
            <span class="n">lastIdx</span><span class="o">++;</span>
            <span class="no">T</span><span class="o">[</span><span class="n">lastIdx</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">){</span>
            <span class="no">T</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">findSameorBig</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastIdx</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="no">T</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">lastIdx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
