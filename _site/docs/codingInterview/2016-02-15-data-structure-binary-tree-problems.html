<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Algorithm - binary tree 및 binary search tree 문제들 - Clean Code</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Algorithm - binary tree 및 binary search tree 문제들 | Clean Code</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Algorithm - binary tree 및 binary search tree 문제들" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Clean Code" /> <meta property="og:description" content="Clean Code" /> <link rel="canonical" href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" /> <meta property="og:url" content="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" /> <meta property="og:site_name" content="Clean Code" /> <script type="application/ld+json"> {"description":"Clean Code","@type":"WebPage","url":"http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html","headline":"Algorithm - binary tree 및 binary search tree 문제들","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Clean Code</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview" class="navigation-list-link">Coding Interview</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html" class="navigation-list-link">Algorithm - sliding window algorithm</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html" class="navigation-list-link">Algorithm - Dijkstra's shortest path</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html" class="navigation-list-link">Data Structure - disjoints-set</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html" class="navigation-list-link">Data Structure - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html" class="navigation-list-link">Algorithm - Minimum Spanning Tree - Kruskal</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html" class="navigation-list-link">Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html" class="navigation-list-link">Algorithm - 부분 문자열의 사전순 정렬</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html" class="navigation-list-link">Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html" class="navigation-list-link">Algorithm - Floyd-Warshall</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html" class="navigation-list-link">Algorithm - 확률에 대한 간단 정리</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html" class="navigation-list-link">Algorithm - 0-1 Knapsack 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html" class="navigation-list-link">Algorithm - LCS(Longest Common Subsequence) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html" class="navigation-list-link">Algorithm - 순열과 조합</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html" class="navigation-list-link">Algorithm - Travelling Salesman Problem(TSP)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html" class="navigation-list-link">Algorithm - 독립 시행 확률</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html" class="navigation-list-link">Algorithm - combination</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html" class="navigation-list-link">Algorithm - quick sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html" class="navigation-list-link">Algorithm - 이분 탐색</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" class="navigation-list-link">Algorithm - Longest Increasing Subsequence</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html" class="navigation-list-link">Algorithm - maximum sum subarray</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html" class="navigation-list-link">Data Structure - hash table</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" class="navigation-list-link">Data Structure - binary search tree</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" class="navigation-list-link active">Algorithm - binary tree 및 binary search tree 문제들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html" class="navigation-list-link">Algorithm - k번째 큰(작은) 아이템 찾기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html" class="navigation-list-link">Algorithm - merge sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html" class="navigation-list-link">Algorithm - Topological Sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html" class="navigation-list-link">Data Structure - LRU(Least Recently Used)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html" class="navigation-list-link">Algorithm - 2D Matrix 회전</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" class="navigation-list-link">Data Structure - B-tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html" class="navigation-list-link">Algorithm - DFS와 BFS</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/java" class="navigation-list-link">Java</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html" class="navigation-list-link">Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-collections-api.html" class="navigation-list-link">Java - Collections API</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html" class="navigation-list-link">Java - Comparable과 Comparator</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-lambda.html" class="navigation-list-link">Java - Lambda</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html" class="navigation-list-link">Java - Collection Framework</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-30-java-collection-list.html" class="navigation-list-link">Java - List 인터페이스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-arraylist.html" class="navigation-list-link">Java - ArrayList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html" class="navigation-list-link">Java - LinkedList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-04-java-stream.html" class="navigation-list-link">Java - Stream</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html" class="navigation-list-link">Java - StringBuilder</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html" class="navigation-list-link">Java - Comparator Interface 사용</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-generic-function.html" class="navigation-list-link">Java - Generic function</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-bitset.html" class="navigation-list-link">Java - BitSet class 예제</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html" class="navigation-list-link">Java - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html" class="navigation-list-link">Java - (멀티쓰레딩 1) Thread 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html" class="navigation-list-link">Java - (멀티쓰레딩 2) Executor 기본</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html" class="navigation-list-link">Java - vararg을 stream으로 변환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-annotation.html" class="navigation-list-link">Java - Annotation</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-name-threads.html" class="navigation-list-link">Java - (멀티쓰레딩 3) 쓰레드 이름 설정</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html" class="navigation-list-link">Java - (멀티쓰레딩 5) 데몬 쓰레드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html" class="navigation-list-link">Java - (멀티쓰레딩 4) 쓰레드에서 값 반환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html" class="navigation-list-link">Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html" class="navigation-list-link">Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html" class="navigation-list-link">Java - (멀티쓰레딩 9) 쓰레드 Join하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html" class="navigation-list-link">Java - (멀티쓰레딩 10) 쓰레드 스케쥴링</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html" class="navigation-list-link">Java - (멀티쓰레딩 7) 쓰레드 중지하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-02-java-naming.html" class="navigation-list-link">Java - 네이밍</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html" class="navigation-list-link">Java - final 키워드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-14-java-lombok.html" class="navigation-list-link">Java - Lombok</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-22-java-big-number.html" class="navigation-list-link">Java - Big Number(BigInteger와 BigDecimal)</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/javascript" class="navigation-list-link">Javascript</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" class="navigation-list-link">Javascript - scope에 대해 알고자 했던 모든 것</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html" class="navigation-list-link">Javascript - deep copy가 필요할 때 무얼 사용해야 할까?</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/systemDesignInterview" class="navigation-list-link">System Design Interview</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/tool" class="navigation-list-link">Tool</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html" class="navigation-list-link">Tool - Mac에서 터미널 작업 실행후 notification</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html" class="navigation-list-link">Git - pull request</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html" class="navigation-list-link">Git - 수정한 것 되돌리기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html" class="navigation-list-link">shell - 폴더에서 파일 내용 검색하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-07-git-diff.html" class="navigation-list-link">Git - diff 사용하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html" class="navigation-list-link">Tool - patch하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html" class="navigation-list-link">grep 명령 - 빈 줄이나 특정 줄 제거하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html" class="navigation-list-link">sed 명령 - 특정 문자열을 변경하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html" class="navigation-list-link">sort 명령 - 크기 역순으로 정렬하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html" class="navigation-list-link">유용한 bash 명령들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html" class="navigation-list-link">uml - plantuml</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html" class="navigation-list-link">Tool - Quick directory alias</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2015-07-21-uml-tools.html" class="navigation-list-link">Design - 좋은 UML 툴 추천</a></li></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Clean Code" aria-label="Search Clean Code" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/codingInterview">Coding Interview</a></li> <li class="breadcrumb-nav-list-item"><span>Algorithm - binary tree 및 binary search tree 문제들</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <p>Binary Tree와 <a href="http://hochulshin.com/data-structure-binary-search-tree/">Binary Search Tree</a>에 관한 문제들은 recursion에 대한 이해가 있어야만 풀 수 있다. 그 문제들, 접근법, 해법을 간단히 살펴본다.</p> <h3 id="binary-tree-문제와-해법들"> <a href="#binary-tree-문제와-해법들" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree 문제와 해법들 </h3> <h4 id="binary-tree의-크기-구하기"> <a href="#binary-tree의-크기-구하기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree의 크기 구하기 </h4> <p>Binary tree의 크기는 구성하는 노드의 숫자를 말한다. 간단히 Node의 왼쪽 자식이 구성하는 트리의 노드 숫자와 오른쪽 자식이 구성하는 노드 숫자, 그리고 자기 자신을 더해서 반환하면 된다. 물론 NULL check를 잊으면 안된다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h4 id="binary-tree-최대-깊이-구하기"> <a href="#binary-tree-최대-깊이-구하기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree 최대 깊이 구하기 </h4> <p>Binary tree의 최대 depth는 자신이 NULL이면 0, 아니면 왼쪽 자식 트리의 최대 depth와 오른쪽 자식 트리의 최대 depth중 큰 것을 택하고 거기에 자신의 깊이 1을 더한 것이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">r_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">l_depth</span><span class="p">,</span> <span class="n">r_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h4 id="binary-tree의-최대-직경-구하기"> <a href="#binary-tree의-최대-직경-구하기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree의 최대 직경 구하기 </h4> <p>Binary tree의 최대 직경은 가장 멀리 떨어져 있는 노드의 거리(edge 수)를 말한다. 주의할 것은 root 노드가 포함되지 않는 최대 직경도 가능하다는 것이다. 하지만 높이는 관련이 깊다. 한 노드에서 자신의 왼쪽 자식 트리의 최대 깊이와 오른쪽 자식 트리의 최대 깊이를 더한 것이 그 노드가 구성하는 트리의 직경이 된다. 각 노드 마다 직경을 구해서 그것 중 가장 큰 것을 택하면 트리의 최대 직경이 된다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">int</span> <span class="n">m_dia</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">maxDiameter</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l_depth</span> <span class="o">=</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span> <span class="c1">//max depth of l_child tree</span>
        <span class="kt">int</span> <span class="n">r_depth</span> <span class="o">=</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span> <span class="c1">//max depth of r_child tree</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m_dia</span> <span class="o">&lt;</span> <span class="n">l_depth</span> <span class="o">+</span> <span class="n">r_depth</span><span class="p">)</span> <span class="c1">//l_depth + r_depth : diameter of this node</span>
            <span class="n">m_dia</span> <span class="o">=</span> <span class="n">l_depth</span> <span class="o">+</span> <span class="n">r_depth</span><span class="p">;</span> <span class="c1">//update the max diameter</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">l_depth</span><span class="p">,</span> <span class="n">r_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//max depth at this node</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    	<span class="n">m_dia</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="kt">int</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_dia</span><span class="p">;</span> <span class="c1">//최대 직경 </span>
    	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h4 id="binary-tree의-root부터-모든-leaf-노드까지의-경로-출력하기"> <a href="#binary-tree의-root부터-모든-leaf-노드까지의-경로-출력하기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree의 root부터 모든 leaf 노드까지의 경로 출력하기 </h4> <p>함수의 파라미터로 vector와 depth를 넘겨주고 leaf 노드에 도달하면 0부터 depth까지 출력하게 한다.<br /> leaf 노드는 왼쪽 오른쪽 자식이 없고 NULL이 아닌 노드이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">printPath</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
        <span class="n">T</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">printPath</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">printPath</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">};</span>
</code></pre></div></div> <h4 id="binary-tree의-모든-노드-제거"> <a href="#binary-tree의-모든-노드-제거" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Tree의 모든 노드 제거 </h4> <p>마치 post order 순회처럼 하면 된다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">removeTree</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="binary-search-tree의-문제와-해법"> <a href="#binary-search-tree의-문제와-해법" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Search Tree의 문제와 해법 </h3> <h4 id="isbst-문제"> <a href="#isbst-문제" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> isBST 문제 </h4> <p>Binary Tree가 BST인지 확인하는 문제이다. 5가지 경우를 처리하면 된다.</p> <ul> <li>노드가 NULL : BST 속성을 해치지 않는다.</li> <li>노드의 자식 노드가 모두 없음 : BST 속성을 해치지 않는다.</li> <li>노드의 오른쪽 자식이 있고 왼쪽 자식이 없음: 왼쪽 자식에 대한 속성(왼쪽 자식보다 노드의 값이 더 커야 한다. 그리고 자식 트리도 그 속성을 만족해야 한다.)을 유지하는 지 확인해야 한다.</li> <li>노드의 왼쪽 자식이 있고 오른쪽 자식이 없음: 오른쪽 자식에 대한 속성(오른쪽 자식보다 노드의 값이 더 작아야 하고 자식 트리도 만족해야 한다.)을 유지하는 지 확인해야 한다.</li> <li>노드의 양 자식이 모두 존재: 두 자식에 대한 속성을 모두 확인해야 한다. 그리고 양 자식 트리도 그 속성을 만족해야 한다.</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">bool</span> <span class="nf">isbst</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h4 id="binary-search-tree의-최대-최소-노드-찾기"> <a href="#binary-search-tree의-최대-최소-노드-찾기" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Binary Search Tree의 최대, 최소 노드 찾기 </h4> <p>BST 속성상 가장 작은 노드는 왼쪽 끝에 위치하고 가장 큰 노드는 오른쪽 끝에 위치한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">minVal</span><span class="p">(){</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//empty</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">maxVal</span><span class="p">(){</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//empty</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="코드"> <a href="#코드" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 코드 </h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">l_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">r_child</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">l_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">r_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">BST</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">isbst</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">r_depth</span> <span class="o">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">l_depth</span><span class="p">,</span> <span class="n">r_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printPath</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
        <span class="n">T</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">printPath</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">printPath</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">m_dia</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l_depth</span> <span class="o">=</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span> <span class="c1">//max depth of l_child tree</span>
        <span class="kt">int</span> <span class="n">r_depth</span> <span class="o">=</span> <span class="n">maxDiameter</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span> <span class="c1">//max depth of r_child tree</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m_dia</span> <span class="o">&lt;</span> <span class="n">l_depth</span> <span class="o">+</span> <span class="n">r_depth</span><span class="p">)</span> <span class="c1">//l_depth + r_depth : diameter of this node</span>
            <span class="n">m_dia</span> <span class="o">=</span> <span class="n">l_depth</span> <span class="o">+</span> <span class="n">r_depth</span><span class="p">;</span> <span class="c1">//update the max diameter</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">l_depth</span><span class="p">,</span> <span class="n">r_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//max depth at this node</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">inorder_traversal</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">inorder_traversal</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
        <span class="n">T</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
        <span class="n">inorder_traversal</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">postorder_traversal</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">postorder_traversal</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
        <span class="n">postorder_traversal</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
        <span class="n">T</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">public:</span>
    <span class="n">BST</span><span class="p">(){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BST</span><span class="p">(){</span>
        <span class="n">removeTree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">insertItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">isBST</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">isbst</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">minVal</span><span class="p">(){</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//empty</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxVal</span><span class="p">(){</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//empty</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printAllPath</span><span class="p">(){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">printPath</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">maxDiameter</span><span class="p">(){</span>
        <span class="n">m_dia</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">maxDiameter</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_dia</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">findTheLowestCommonAncenstor</span><span class="p">(</span><span class="kt">int</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyB</span><span class="p">){</span>
        <span class="c1">//in-order traversal의 속성으로 keyA부터 key B까지의 영역이 하나의 subtree의 일부분</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">I</span><span class="p">;</span>
        <span class="n">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>
        <span class="c1">//post-order traversal의 속성으로 한 subtree의 root는 맨 뒤에 위치</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">P</span><span class="p">;</span>
        <span class="n">postorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
        <span class="c1">//keyA와 keyB 영역을 in-order 결과에서 찾는다. index를 찾고 작은 것을 앞으로 위치 시킴</span>
        <span class="kt">int</span> <span class="n">first_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">I</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">keyA</span><span class="p">)</span> <span class="n">first_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">keyB</span><span class="p">)</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">first_index</span> <span class="o">&gt;</span> <span class="n">last_index</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">first_index</span><span class="p">;</span>
            <span class="n">first_index</span> <span class="o">=</span> <span class="n">last_index</span><span class="p">;</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//in-order의 keyA와 keyB의 아이템 중 post-order로 순회된 아이템 중 가장 뒤의 것을 찾는다.</span>
        <span class="kt">int</span> <span class="n">last_mark</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first_index</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span> <span class="n">last_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">P</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">last_mark</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">){</span>
                        <span class="n">last_mark</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="n">last_mark</span><span class="p">];</span> <span class="c1">//post-order로 찾은 것중 마지막 것이 root</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">BST</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">400</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insertItem</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">700</span><span class="p">);</span>
    <span class="cm">/*
              10
         1         20
       0   5    15
            7     17
     */</span>
    <span class="cm">/* check if the tree is a BST */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">isBST</span><span class="p">())</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"BST"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//must be "BST"</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"NOT BST"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="cm">/* get the size of binary tree */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// must be 8</span>
    <span class="cm">/* get the maximum depth of binary tree*/</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//msut be 4</span>
    <span class="cm">/* get the min &amp; max value of binary search tree */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">minVal</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">maxVal</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 20</span>
    <span class="cm">/* print all the possible paths in a binary tree*/</span>
    <span class="n">b</span><span class="p">.</span><span class="n">printAllPath</span><span class="p">();</span> <span class="c1">//must be 10 1 0, 10 1 5 7, 10 20 15 17</span>
    <span class="cm">/* find the max diameter of the binary tree */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">maxDiameter</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 6 (num of edges)</span>
    <span class="cm">/* Find the lowest common ancestor from two nodes in binary tree */</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">findTheLowestCommonAncenstor</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">findTheLowestCommonAncenstor</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 10</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">findTheLowestCommonAncenstor</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//must be 10</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
