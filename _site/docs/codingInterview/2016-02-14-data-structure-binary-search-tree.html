<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Data Structure - binary search tree - Clean Code</title> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Data Structure - binary search tree | Clean Code</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Data Structure - binary search tree" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Clean Code" /> <meta property="og:description" content="Clean Code" /> <link rel="canonical" href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" /> <meta property="og:url" content="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" /> <meta property="og:site_name" content="Clean Code" /> <script type="application/ld+json"> {"description":"Clean Code","@type":"WebPage","url":"http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html","headline":"Data Structure - binary search tree","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Clean Code</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview" class="navigation-list-link">Coding Interview</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html" class="navigation-list-link">Algorithm - sliding window algorithm</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html" class="navigation-list-link">Algorithm - Dijkstra's shortest path</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html" class="navigation-list-link">Data Structure - disjoints-set</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html" class="navigation-list-link">Data Structure - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html" class="navigation-list-link">Algorithm - Minimum Spanning Tree - Kruskal</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html" class="navigation-list-link">Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html" class="navigation-list-link">Algorithm - 부분 문자열의 사전순 정렬</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html" class="navigation-list-link">Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html" class="navigation-list-link">Algorithm - Floyd-Warshall</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html" class="navigation-list-link">Algorithm - 확률에 대한 간단 정리</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html" class="navigation-list-link">Algorithm - 0-1 Knapsack 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html" class="navigation-list-link">Algorithm - LCS(Longest Common Subsequence) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html" class="navigation-list-link">Algorithm - 순열과 조합</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html" class="navigation-list-link">Algorithm - Travelling Salesman Problem(TSP)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html" class="navigation-list-link">Algorithm - 독립 시행 확률</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html" class="navigation-list-link">Algorithm - combination</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html" class="navigation-list-link">Algorithm - quick sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html" class="navigation-list-link">Algorithm - 이분 탐색</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" class="navigation-list-link">Algorithm - Longest Increasing Subsequence</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html" class="navigation-list-link">Algorithm - maximum sum subarray</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html" class="navigation-list-link">Data Structure - hash table</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" class="navigation-list-link active">Data Structure - binary search tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" class="navigation-list-link">Algorithm - binary tree 및 binary search tree 문제들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html" class="navigation-list-link">Algorithm - k번째 큰(작은) 아이템 찾기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html" class="navigation-list-link">Algorithm - merge sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html" class="navigation-list-link">Algorithm - Topological Sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html" class="navigation-list-link">Data Structure - LRU(Least Recently Used)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html" class="navigation-list-link">Algorithm - 2D Matrix 회전</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" class="navigation-list-link">Data Structure - B-tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html" class="navigation-list-link">Algorithm - DFS와 BFS</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/java" class="navigation-list-link">Java</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html" class="navigation-list-link">Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-collections-api.html" class="navigation-list-link">Java - Collections API</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html" class="navigation-list-link">Java - Comparable과 Comparator</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-lambda.html" class="navigation-list-link">Java - Lambda</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html" class="navigation-list-link">Java - Collection Framework</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-30-java-collection-list.html" class="navigation-list-link">Java - List 인터페이스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-arraylist.html" class="navigation-list-link">Java - ArrayList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html" class="navigation-list-link">Java - LinkedList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-04-java-stream.html" class="navigation-list-link">Java - Stream</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html" class="navigation-list-link">Java - StringBuilder</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html" class="navigation-list-link">Java - Comparator Interface 사용</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-generic-function.html" class="navigation-list-link">Java - Generic function</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-bitset.html" class="navigation-list-link">Java - BitSet class 예제</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html" class="navigation-list-link">Java - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html" class="navigation-list-link">Java - (멀티쓰레딩 1) Thread 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html" class="navigation-list-link">Java - (멀티쓰레딩 2) Executor 기본</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html" class="navigation-list-link">Java - vararg을 stream으로 변환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-annotation.html" class="navigation-list-link">Java - Annotation</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-name-threads.html" class="navigation-list-link">Java - (멀티쓰레딩 3) 쓰레드 이름 설정</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html" class="navigation-list-link">Java - (멀티쓰레딩 5) 데몬 쓰레드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html" class="navigation-list-link">Java - (멀티쓰레딩 4) 쓰레드에서 값 반환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html" class="navigation-list-link">Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html" class="navigation-list-link">Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html" class="navigation-list-link">Java - (멀티쓰레딩 9) 쓰레드 Join하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html" class="navigation-list-link">Java - (멀티쓰레딩 10) 쓰레드 스케쥴링</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html" class="navigation-list-link">Java - (멀티쓰레딩 7) 쓰레드 중지하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-02-java-naming.html" class="navigation-list-link">Java - 네이밍</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html" class="navigation-list-link">Java - final 키워드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-14-java-lombok.html" class="navigation-list-link">Java - Lombok</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-22-java-big-number.html" class="navigation-list-link">Java - Big Number(BigInteger와 BigDecimal)</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/javascript" class="navigation-list-link">Javascript</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" class="navigation-list-link">Javascript - scope에 대해 알고자 했던 모든 것</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html" class="navigation-list-link">Javascript - deep copy가 필요할 때 무얼 사용해야 할까?</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/systemDesignInterview" class="navigation-list-link">System Design Interview</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/tool" class="navigation-list-link">Tool</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html" class="navigation-list-link">Tool - Mac에서 터미널 작업 실행후 notification</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html" class="navigation-list-link">Git - pull request</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html" class="navigation-list-link">Git - 수정한 것 되돌리기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html" class="navigation-list-link">shell - 폴더에서 파일 내용 검색하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-07-git-diff.html" class="navigation-list-link">Git - diff 사용하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html" class="navigation-list-link">Tool - patch하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html" class="navigation-list-link">grep 명령 - 빈 줄이나 특정 줄 제거하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html" class="navigation-list-link">sed 명령 - 특정 문자열을 변경하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html" class="navigation-list-link">sort 명령 - 크기 역순으로 정렬하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html" class="navigation-list-link">유용한 bash 명령들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html" class="navigation-list-link">uml - plantuml</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html" class="navigation-list-link">Tool - Quick directory alias</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2015-07-21-uml-tools.html" class="navigation-list-link">Design - 좋은 UML 툴 추천</a></li></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Clean Code" aria-label="Search Clean Code" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/codingInterview">Coding Interview</a></li> <li class="breadcrumb-nav-list-item"><span>Data Structure - binary search tree</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <p>직접 구현해 본 binary search tree. iterative binary tree travasal에 익숙해져야 한다.</p> <h3 id="구조"> <a href="#구조" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 구조 </h3> <p>tree를 design할때 가장 먼저 고민할 것은 tree를 구성하는 Node의 정의이다. 입력 데이터는 key와 value 조합으로 했으며, 삽입, 검색, 삭제의 기준은 key로 했다. array가 아닌 pointer로 tree를 구성하고자 다음과 같이 Node를 정의했다. 구현을 용이하게 하기 위해 constructor를 담은 struct로 정의했다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">l_child</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">r_child</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">l_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">r_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>   
</code></pre></div></div> <p>public interface인 함수 프로토타입은 다음과 같이 선언했다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BST</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">BST</span><span class="p">();</span> <span class="c1">//자료구조(root) 초기화</span>
    <span class="o">~</span><span class="n">BST</span><span class="p">();</span> <span class="c1">//할당된 resource 모두 해제</span>
    <span class="kt">void</span> <span class="n">insertItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span> <span class="c1">//item 삽입</span>
    <span class="kt">void</span> <span class="n">removeItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">);</span> <span class="c1">//item 삭제</span>
    <span class="kt">bool</span> <span class="n">findItem</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span> <span class="c1">//item을 key로 검색해서 value를 획득. 없으면 false를 리턴</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">();</span> <span class="c1">//tree의 모든 아이템을 inorder로 출력 </span>
<span class="p">};</span>
</code></pre></div></div> <p>위의 프로토타입을 뒷바침하기 위한 private 멤버는 다음과 같이 도출했다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BST</span><span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>   
    <span class="kt">void</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span> <span class="c1">//root r인 tree에 할당된 resource를 모두 해제 </span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">getBiggest</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span><span class="n">r</span><span class="p">);</span> <span class="c1">//root r인 tree 중 가장 큰 key를 가진 Node를 삭제하고 그 key와 value를 반환 </span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">getSmallest</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span><span class="n">r</span><span class="p">);</span> <span class="c1">//root r인 tree 중 가장 작은 key를 가진 Node를 삭제하고 그 key와 value를 반환 </span>
    <span class="kt">void</span> <span class="n">printInorder</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span> <span class="c1">///root r인 tree를 inorder로 순회하며 출력 </span>
<span class="p">};</span>
</code></pre></div></div> <p>getBiggest와 getSmallest의 경우 root가 삭제되면 NULL로 root가 변경되어야 하므로 더블포인터를 파라미터로 사용한다.</p> <p>binary tree의 iterative search는 기본적으로 아래와 같은 방식으로 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">){</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>삽입이나 삭제를 위해서는 Parent Node를 기억하고 있어야 하므로 조금 변형이 필요하다. root node는 parent가 없는 node이므로 먼저 확인을 한다. tmp를 이동시키기 전에 parent를 가리키는 pointer로 tmp를 가리키게 하면 간단히 parent를 저장할 수 있다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>tree의 resource해제나 print는 간단히 recursion을 이용해서 한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">removeTree</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">removeTree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printInorder</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">)</span> <span class="n">printInorder</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">value</span> <span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">)</span> <span class="n">printInorder</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="code"> <a href="#code" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> code </h3> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="o">;</span>
<span class="n">struct</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="o">*</span><span class="n">l_child</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="o">*</span><span class="n">r_child</span><span class="o">;</span>
    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">){</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="n">l_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
        <span class="n">r_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
    <span class="o">};</span>
<span class="o">};</span>
<span class="kd">class</span> <span class="nc">BST</span> <span class="o">{</span>
<span class="kd">private</span><span class="o">:</span>
    <span class="nc">Node</span> <span class="o">*</span><span class="n">root</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">removeTree</span><span class="o">(</span><span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">)</span> <span class="n">removeTree</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">)</span> <span class="n">removeTree</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">);</span>
        <span class="n">delete</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="nf">getBiggest</span><span class="o">(</span><span class="nc">Node</span> <span class="o">**</span><span class="n">r</span><span class="o">){</span> <span class="c1">//root의 pointer를 NULL로 변경할 수 있도록 이중 pointer로 입력받음</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">!=</span> <span class="no">NULL</span><span class="o">){</span> <span class="c1">//r_child가 없을때까지 이동</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="nf">ret</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">){</span> <span class="c1">//만약 l_child가 있을 경우 l_child tree의 가장 큰 아이템으로 대체</span>
            <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">getBiggest</span><span class="o">(&amp;(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">));</span>
            <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">second</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//l_child와 r_child가 모두 없는 node는 그 node를 가리키는 포인터를 NULL로!</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">p</span><span class="o">){</span> <span class="c1">//tree의 root가 아닌 경우</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//root인 경우</span>
                <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span> <span class="c1">//!!!!</span>
            <span class="o">}</span>
            <span class="n">delete</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="nf">getSmallest</span><span class="o">(</span><span class="nc">Node</span> <span class="o">**</span><span class="n">r</span><span class="o">){</span> <span class="c1">//root의 pointer를 NULL로 변경할 수 있도록 이중 pointer로 입력 받음</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">!=</span> <span class="no">NULL</span><span class="o">){</span> <span class="c1">//l_child가 없을때까지 이동</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="nf">ret</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">){</span>
            <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">getSmallest</span><span class="o">(&amp;(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">));</span>
            <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">second</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">p</span><span class="o">){</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span> <span class="c1">//root인 경우 NULL로 변경</span>
            <span class="o">}</span>
            <span class="n">delete</span><span class="o">(</span><span class="n">tmp</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">printInorder</span><span class="o">(</span><span class="nc">Node</span> <span class="o">*</span><span class="n">r</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">)</span> <span class="n">printInorder</span><span class="o">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">") "</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">)</span> <span class="n">printInorder</span><span class="o">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">);</span>
    <span class="o">}</span>
<span class="kd">public</span><span class="o">:</span>
    <span class="no">BST</span><span class="o">(){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">virtual</span> <span class="o">~</span><span class="no">BST</span><span class="o">(){</span>
        <span class="n">removeTree</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">insertItem</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">){</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">tmp</span><span class="o">!=</span> <span class="no">NULL</span><span class="o">){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">bool</span> <span class="nf">findItem</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">val</span><span class="o">){</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="no">NULL</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">//빈 tree</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="no">NULL</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">){</span> <span class="c1">//r_child가 있는 경우 r_child tree의 가장 작은 item으로 Node를 대체</span>
                    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">=</span> <span class="n">getSmallest</span><span class="o">(&amp;(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">));</span>
                    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
                    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">second</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">){</span> <span class="c1">//r_child가 없고 l_child만 있는 경우 l_child의 가장 큰 item으로 Node를 대체</span>
                    <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">=</span> <span class="n">getBiggest</span><span class="o">(&amp;(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">));</span>
                    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">first</span><span class="o">;</span>
                    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">second</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//leaf node인 경우 그냥 지운다. 이때 그 node를 가리키던 pointer를 NULL로 만든다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">root</span><span class="o">){</span> <span class="c1">//root일 경우</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>
                            <span class="n">p</span><span class="o">-&gt;</span><span class="n">l_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                            <span class="n">p</span><span class="o">-&gt;</span><span class="n">r_child</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">delete</span> <span class="n">tmp</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">){</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">l_child</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">r_child</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
        <span class="n">printInorder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="o">(){</span>
    <span class="no">BST</span> <span class="n">b</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">300</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">20</span><span class="o">,</span> <span class="mi">400</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">15</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">17</span><span class="o">,</span> <span class="mi">600</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">insertItem</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">700</span><span class="o">);</span>
    <span class="n">b</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="c1">//remove middle node</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 5 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 5 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">removeItem</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 5 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 5 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    
    <span class="c1">//remove leaf node</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 0 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 0 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">removeItem</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 0 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 0 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    
    <span class="c1">//remove root node</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 10 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 10 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">removeItem</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">findItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">val</span><span class="o">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 10 : "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Key 10 : Not found"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">;</span>
    <span class="n">b</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
