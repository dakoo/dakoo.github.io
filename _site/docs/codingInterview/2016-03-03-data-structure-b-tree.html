<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Data Structure - B-tree - Clean Code</title> <meta name="Description" content="B-tree"> <link rel="shortcut icon" href="http://localhost:4000/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="http://localhost:4000/assets/css/just-the-docs.css"> <script type="text/javascript" src="http://localhost:4000/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>Data Structure - B-tree | Clean Code</title> <meta name="generator" content="Jekyll v3.8.6" /> <meta property="og:title" content="Data Structure - B-tree" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="B-tree" /> <meta property="og:description" content="B-tree" /> <link rel="canonical" href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" /> <meta property="og:url" content="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" /> <meta property="og:site_name" content="Clean Code" /> <script type="application/ld+json"> {"description":"B-tree","@type":"WebPage","url":"http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html","headline":"Data Structure - B-tree","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000" class="site-title lh-tight">Clean Code</a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="http://localhost:4000/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview" class="navigation-list-link">Coding Interview</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2018-07-28-algorithm-sliding-window.html" class="navigation-list-link">Algorithm - sliding window algorithm</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-dijkstra-algorithm.html" class="navigation-list-link">Algorithm - Dijkstra's shortest path</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-disjoints-set.html" class="navigation-list-link">Data Structure - disjoints-set</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-priority-queue.html" class="navigation-list-link">Data Structure - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-07-mst-kruskal.html" class="navigation-list-link">Algorithm - Minimum Spanning Tree - Kruskal</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-11-string-pattern-search.html" class="navigation-list-link">Algorithm - 문자열 패턴 검색 보이어-무어 알고리즘에 대한 이해와 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-12-substring-sorting.html" class="navigation-list-link">Algorithm - 부분 문자열의 사전순 정렬</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-Longest%20Increasing%20Subsequence.html" class="navigation-list-link">Algorithm - LIS(Longest Increasing Subsequence) O(N*N) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-floyd-warshall.html" class="navigation-list-link">Algorithm - Floyd-Warshall</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-14-probability_summary.html" class="navigation-list-link">Algorithm - 확률에 대한 간단 정리</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-01knapsack.html" class="navigation-list-link">Algorithm - 0-1 Knapsack 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-longest-common-subsequence.html" class="navigation-list-link">Algorithm - LCS(Longest Common Subsequence) 알고리즘</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-permutation-composition-summary.html" class="navigation-list-link">Algorithm - 순열과 조합</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-15-travelling-salesman-problem.html" class="navigation-list-link">Algorithm - Travelling Salesman Problem(TSP)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-16-independent_probability_problem.html" class="navigation-list-link">Algorithm - 독립 시행 확률</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-27-combination-in-c.html" class="navigation-list-link">Algorithm - combination</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-05-algorithm-quicksort.html" class="navigation-list-link">Algorithm - quick sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-bisectional-search.html" class="navigation-list-link">Algorithm - 이분 탐색</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-longest-increasing-subsequence-nlogn.html" class="navigation-list-link">Algorithm - Longest Increasing Subsequence</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-09-algorithm-maximum-sum-subarray.html" class="navigation-list-link">Algorithm - maximum sum subarray</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-13-data-structure-hash-table.html" class="navigation-list-link">Data Structure - hash table</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-14-data-structure-binary-search-tree.html" class="navigation-list-link">Data Structure - binary search tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-15-data-structure-binary-tree-problems.html" class="navigation-list-link">Algorithm - binary tree 및 binary search tree 문제들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-find-kth-item.html" class="navigation-list-link">Algorithm - k번째 큰(작은) 아이템 찾기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-22-algorithm-merge-sort.html" class="navigation-list-link">Algorithm - merge sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-25-algorithm-topological-sort.html" class="navigation-list-link">Algorithm - Topological Sort</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-02-29-data-structure-LRU-cache.html" class="navigation-list-link">Data Structure - LRU(Least Recently Used)</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2016-03-01-algorithm-2d-matrix-rotation.html" class="navigation-list-link">Algorithm - 2D Matrix 회전</a></li><li class="navigation-list-item active"><a href="http://localhost:4000/docs/codingInterview/2016-03-03-data-structure-b-tree.html" class="navigation-list-link active">Data Structure - B-tree</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/codingInterview/2015-08-06-algorithm-dfs-bfs.html" class="navigation-list-link">Algorithm - DFS와 BFS</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/java" class="navigation-list-link">Java</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-11-27-java-intellij-shortcut.html" class="navigation-list-link">Java - OSX에서 vim 모드와 함께 쓸 만한 Intellij 단축키</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-collections-api.html" class="navigation-list-link">Java - Collections API</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-comparable-comparator.html" class="navigation-list-link">Java - Comparable과 Comparator</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-23-java-lambda.html" class="navigation-list-link">Java - Lambda</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-29-java-collection-framework.html" class="navigation-list-link">Java - Collection Framework</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-30-java-collection-list.html" class="navigation-list-link">Java - List 인터페이스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-arraylist.html" class="navigation-list-link">Java - ArrayList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-31-java-linkedlist.html" class="navigation-list-link">Java - LinkedList 클래스</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-04-java-stream.html" class="navigation-list-link">Java - Stream</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-06-java-stringbuilder.html" class="navigation-list-link">Java - StringBuilder</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-comparator-interface.html" class="navigation-list-link">Java - Comparator Interface 사용</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-12-java-generic-function.html" class="navigation-list-link">Java - Generic function</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-bitset.html" class="navigation-list-link">Java - BitSet class 예제</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-13-java-priority-queue.html" class="navigation-list-link">Java - Priority Queue</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-15-java-multithreading-thread-thread-implementation.html" class="navigation-list-link">Java - (멀티쓰레딩 1) Thread 구현</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-multithreading-executor-basic.html" class="navigation-list-link">Java - (멀티쓰레딩 2) Executor 기본</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-16-java-vararg-stream-conversion.html" class="navigation-list-link">Java - vararg을 stream으로 변환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-annotation.html" class="navigation-list-link">Java - Annotation</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-17-java-name-threads.html" class="navigation-list-link">Java - (멀티쓰레딩 3) 쓰레드 이름 설정</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-mulitthreading-daemon-thread.html" class="navigation-list-link">Java - (멀티쓰레딩 5) 데몬 쓰레드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-18-java-multithreading-returning-values-from-task.html" class="navigation-list-link">Java - (멀티쓰레딩 4) 쓰레드에서 값 반환</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-19-java-multithreading-check-aliveness.html" class="navigation-list-link">Java - (멀티쓰레딩 6) 쓰레드 동작의 완료를 확인하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-exception-handling.html" class="navigation-list-link">Java - (멀티쓰레딩 8) 쓰레드 Exception 처리하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-join.html" class="navigation-list-link">Java - (멀티쓰레딩 9) 쓰레드 Join하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-scheduling.html" class="navigation-list-link">Java - (멀티쓰레딩 10) 쓰레드 스케쥴링</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-09-20-java-multithreading-thread-termination.html" class="navigation-list-link">Java - (멀티쓰레딩 7) 쓰레드 중지하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-02-java-naming.html" class="navigation-list-link">Java - 네이밍</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-12-java-final-keyword.html" class="navigation-list-link">Java - final 키워드</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-10-14-java-lombok.html" class="navigation-list-link">Java - Lombok</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/java/2016-08-22-java-big-number.html" class="navigation-list-link">Java - Big Number(BigInteger와 BigDecimal)</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/javascript" class="navigation-list-link">Javascript</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2015-08-24-everything-about-javascript-scope.html" class="navigation-list-link">Javascript - scope에 대해 알고자 했던 모든 것</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/javascript/2018-02-22-javascript-best-deepcopy.html" class="navigation-list-link">Javascript - deep copy가 필요할 때 무얼 사용해야 할까?</a></li></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/systemDesignInterview" class="navigation-list-link">System Design Interview</a><ul class="navigation-list-child-list "></ul></li><li class="navigation-list-item"><a href="http://localhost:4000/docs/tool" class="navigation-list-link">Tool</a><ul class="navigation-list-child-list "><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-tool-notification-after-job-finish-mac-terminal.html" class="navigation-list-link">Tool - Mac에서 터미널 작업 실행후 notification</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-04-git-pull-request.html" class="navigation-list-link">Git - pull request</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-10-05-git-revert-changes.html" class="navigation-list-link">Git - 수정한 것 되돌리기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-03-bash-find-pattern-in-directories.html" class="navigation-list-link">shell - 폴더에서 파일 내용 검색하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-07-git-diff.html" class="navigation-list-link">Git - diff 사용하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-11-08-how-to-patch.html" class="navigation-list-link">Tool - patch하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-grep-remove-useless-lines.html" class="navigation-list-link">grep 명령 - 빈 줄이나 특정 줄 제거하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sed-replace-string.html" class="navigation-list-link">sed 명령 - 특정 문자열을 변경하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2016-12-30-tool-sort-reverse-order.html" class="navigation-list-link">sort 명령 - 크기 역순으로 정렬하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-01-07-linux-useful-bash-commands.html" class="navigation-list-link">유용한 bash 명령들</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2017-03-13-uml-plantuml.html" class="navigation-list-link">uml - plantuml</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-quick-directory-alias.html" class="navigation-list-link">Tool - Quick directory alias</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-command-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 작업을 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2018-11-12-run-ssh-in-new-terminal-tab.html" class="navigation-list-link">Tool - Mac iterm2에서 ssh를 다른 tab에서 실행하기</a></li><li class="navigation-list-item "><a href="http://localhost:4000/docs/tool/2015-07-21-uml-tools.html" class="navigation-list-link">Design - 좋은 UML 툴 추천</a></li></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search Clean Code" aria-label="Search Clean Code" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> </div> <div class="page"> <nav class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/docs/codingInterview">Coding Interview</a></li> <li class="breadcrumb-nav-list-item"><span>Data Structure - B-tree</span></li> </ol> </nav> <div id="main-content" class="page-content" role="main"> <p>B 트리는 자식을 두개만 가질 수 잇는 이진 트리를 확장하여 더 많은 자식을 가질 수 있게 고안한 것이다. 오라클과 같은 상용 DB에서 많이 사용하는 자료구조로 외부 검색(주 저장장치인 메모리 외의 저장장치에서의 검색)에 유용하다.</p> <h3 id="balanced-tree란"> <a href="#balanced-tree란" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Balanced Tree란? </h3> <p>이진 트리는 O(NlogN)의 시간 복잡도를 가지지만, 좌우 균형이 맞지 않으면 비효율적인 성능을 낸다. 예를 들어 정렬이 되어 있는 자료를 순차적으로 삽입하면 한쪽으로만 치우치게 되고 O(N*N)의 시간 복잡도를 갖게된다. 이와 같은 이진트리의 문제를 해결하고 항상 삽입/삭제/검색이 O(NlogN)의 성능을 내도록 삽입과 삭제시에 스스로 좌우 균형을 유지하는 트리를 Balanced Tree라고 한다.</p> <h4 id="balanced-tree의-종류"> <a href="#balanced-tree의-종류" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Balanced Tree의 종류 </h4> <p>Balanced 트리의 종류는 다음과 같다.</p> <ul> <li>AVL 트리</li> <li>2-3 트리</li> <li>2-3-4 트리</li> <li>Red-Black 트리</li> <li>B 트리</li> </ul> <p>위 중 AVL트리와 Red-Black트리는 유사하고 2-3/2-3-4트리와 B트리는 유사하다.</p> <h3 id="b-트리란"> <a href="#b-트리란" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리란? </h3> <p>이진 트리와 달리 하나의 노드가 여러 데이터를 가진다. 한 노드에 최대 M개의 자료가 배치될 수 있으면 M차 B트리라고 한다. 이 M이 짝수냐 홀수냐에 따라 알고리즘이 상당히 다르다. 2, 4, 6차 B트리와 3,5,7차 B트리는 상당히 다른 알고리즘을 사용한다. 홀수 B 트리가 짝수 B 트리에 비해 알고리즘이 많이 쉽다. 2-3 트리는 2차 B 트리와 같은 것이고, 2-3-4 트리는 3차 B 트리와 같다.</p> <figure> <img src="/images/btree1.png" alt="" /> </figure> <h3 id="b-트리의-정의와-규칙"> <a href="#b-트리의-정의와-규칙" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리의 정의와 규칙 </h3> <h4 id="간단한-규칙"> <a href="#간단한-규칙" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 간단한 규칙 </h4> <p>B 트리는 다음과 같은 규칙을 갖는다.</p> <ul> <li>노드의 데이터 수가 N이면 자식의 수는 항상 N+1이여야 한다. 즉, 노드 2개의 데이터를 가진다면 그 노드의 자식은 반드시 3개여야 한다는 것이다.</li> <li>노드내의 데이터는 반드시 정렬된 상태여야 한다.</li> <li>노드의 데이터 D1의 왼쪽 서브 트리는 D1보다 작은 값들로 이루어져 있어야 하고, D1의 오른쪽 서브트리는 D1보다 큰 값들로 이루어져 있어야 한다. 이진 검색 트리의 성질과 유사하다.</li> </ul> <figure> <img src="/images/b-tree5.png" alt="" /> </figure> <h4 id="복잡한-규칙"> <a href="#복잡한-규칙" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 복잡한 규칙 </h4> <ul> <li>Root 노드는 자식이 있다면 적어도 2개 이상의 자식을 가져야 한다.</li> <li>Root 노드를 제외한 모든 노드는 적어도 M/2개의 데이터를 가지고 있어야 한다. 예를 들어 5차 B트리라면 적어도 2개의 데이터를 가지고 있어야 한다.</li> <li>Leaf 노드로 가는 경로의 길이는 모두 같다. 즉, leaf 노드는 모두 같은 레벨에 존재한다.</li> <li>입력 자료는 중복될 수 없다.</li> </ul> <h3 id="b-트리-구현"> <a href="#b-트리-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리 구현 </h3> <h4 id="b-트리-노드"> <a href="#b-트리-노드" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리 노드 </h4> <h5 id="노드의-구조"> <a href="#노드의-구조" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 노드의 구조 </h5> <p>B 트리 노드는 N개의 데이터를 저장하는 배열, Child를 가리키는 포인터를 N+1개 저장하는 배열이 필요하다. 데이터 배열의 데이터 index i에 대해 Children 배열의 인덱스는 다음과 같은 관계를 가진다.</p> <ul> <li>index i: i 데이터의 left child node를 가리키는 포인터가 저장된 index</li> <li>index i+1: i 데이터의 right child node를 가리키는 포인터가 저장된 index</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Datum</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Datum</span> <span class="p">(){</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;</span> <span class="n">Data</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span> <span class="o">*&gt;</span> <span class="n">Children</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Dim</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">){</span>
        <span class="n">Dim</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">Keys</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">Children</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="데이터의-값-반환"> <a href="#데이터의-값-반환" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 데이터의 값 반환 </h5> <p>데이터 배열의 인덱스를 넣으면 그 키 값을 반환하거나 value를 반환한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">keyAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">valueAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">Data</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="데이터의-child-반환"> <a href="#데이터의-child-반환" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 데이터의 child 반환 </h5> <p>노드의 배열 구조를 이용한다. 데이터의 index를 받으면 left 혹은 right child의 포인터를 반환한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">leftChildOf</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">Children</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">rightChildOf</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">Children</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="노드에서-데이터-삽입"> <a href="#노드에서-데이터-삽입" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 노드에서 데이터 삽입 </h5> <p>노드의 데이터는 B 트리의 규칙에 따라 정렬되어 있어야 한다. 그러므로 정렬된 데이터들에게 데이터를 삽입하는 상황이므로 삽입 정렬과 같은 방식으로 삽입을 한다. 맨 뒤에서부터 하나씩 shift하면서 비교해서 적당한 위치에 놓으면 된다. 그리고 이때 Children 배열도 함께 Shift해야 한다. 쉽게 하기 위해 left child와 right child의 포인터를 이미 알고 있다고 하자. 그러면, 데이터 배열에서의 데이터의 index를 정하면 Children 배열의 index에는 left child를 넣고, index + 1에는 right child를 넣는다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">insertKey</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">rightChild</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">Dim</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">//last index prior to insertion</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
            <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">leftChild</span><span class="p">;</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rightChild</span><span class="p">;</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div></div> <h5 id="노드에서-데이터-검색"> <a href="#노드에서-데이터-검색" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 노드에서 데이터 검색 </h5> <p>노드는 정렬된 값을 가지고 있다. 차수가 작은 경우엔 순차적으로 검색하고, 차수가 큰 경우엔 이분 검색등을 이용한다. 찾으면 그 index를 반환하고, 못찾으면 -1을 반환한다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">findKey</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h5 id="노드에서-데이터-삭제"> <a href="#노드에서-데이터-삭제" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 노드에서 데이터 삭제 </h5> <p>데이터 삽입과 달리 데이터의 index를 이미 알고 있는 상황이라고 생각하자. 그러면 그 index만 지우면 되는데 이때 Children 배열에서는 Left child의 값을 지우는 것으로 하자.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">deleteKey</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
            <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div></div> <h5 id="노드-구현"> <a href="#노드-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 노드 구현 </h5> <p>key가 int인 경우로 구현한 노드는 다음과 같다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Datum</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">Datum</span> <span class="p">(){</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;</span> <span class="n">Data</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span> <span class="o">*&gt;</span> <span class="n">Children</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Dim</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">){</span>
        <span class="n">Dim</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">Data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Dim</span><span class="p">);</span>
        <span class="n">Children</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">Dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="o">~</span><span class="n">Node</span><span class="p">(){};</span>
    <span class="kt">int</span> <span class="n">keyAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">valueAt</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">Data</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">leftChildOf</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">Children</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">};</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">rightChildOf</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">Children</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">};</span>
    <span class="kt">void</span> <span class="n">insertKey</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">rightChild</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">Dim</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">//last index prior to insertion</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
            <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">leftChild</span><span class="p">;</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rightChild</span><span class="p">;</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">void</span> <span class="n">deleteKey</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
            <span class="n">Data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">;</span>
            <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">findKey</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">Data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="b-트리의-구조"> <a href="#b-트리의-구조" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리의 구조 </h4> <p>Root Node를 가리키는 HeadNode를 만들어 둔다. key가 하나도 없어도 HeadNode는 존재하는 것이다. 그리고 HeadNode의 Children[0]이 Root Node를 가리킨다. key가 없을 때는 <code class="highlighter-rouge">HeadNode-&gt;Children[0]</code>이 NULL이다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BTree</span> <span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
	<span class="nl">public:</span>
		<span class="n">BTree</span><span class="p">(){</span>
			<span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//5차 Btree</span>
		<span class="p">};</span>
		<span class="o">~</span><span class="n">BTree</span><span class="p">(){</span>
			<span class="k">delete</span> <span class="n">head</span><span class="p">;</span>	
		<span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="b-트리의-검색"> <a href="#b-트리의-검색" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> B 트리의 검색 </h4> <p>다음과 같은 순서에 따라 iteration하며 검색한다.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Root Node에서부터 시작하며 입력된 key값을 찾는다. 
2. Node가 NULL이 아니고 자신의 노드에서 key를 찾지 못하면 
3. Keys[]를 index 0부터 마지막 index까지 돌면서 입력 key보다 큰 key를 가진 index의 왼쪽 Child 노드를 현재 Node로 갱신해서 
4. 2-3을 반복한다. 
5. 만약 Node가 NULL이기 때문에 2-3 반복이 종료된 것이면 찾지 못한 것이다.
6. 만약 Node가 NULL이 아니면서 종료된 것이면 해당 index를 이용해 그 값을 반환한다.  
</code></pre></div></div> <figure> <img src="/images/btree-search.gif" alt="" /> </figure> <h5 id="검색의-구현"> <a href="#검색의-구현" class="anchor-heading"><svg class="d-inline-block v-align-middle" viewBox="0 0 16 16" version="1.1" width="18" height="18" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> 검색의 구현 </h5> <p>위의 검색 알고리즘을 코드로 구현하면 다음과 같다.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">){</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">Children</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	
	<span class="k">while</span><span class="p">(</span> <span class="n">temp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="cm">/* Node의 key값 확인 */</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">findKey</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">//Found!</span>
			<span class="n">value</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">valueAt</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Children 확인*/</span>
		<span class="kt">int</span> <span class="n">c_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(;</span> <span class="n">c_index</span><span class="o">&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">c_index</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">keyAt</span><span class="p">(</span><span class="n">c_index</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>	
		<span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">leftChildOf</span><span class="p">(</span><span class="n">c_index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </div> </div> </div> </body> </html>
